<?xml version="1.0" encoding="UTF-8"?>
<doc>
<assembly><name>library</name></assembly>
<members>
<member name="T:HealthDataManager">
</member>
<member name="M:HealthDataManager.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:HealthDataQrCode">
</member>
<member name="T:HealthDataToken">
</member>
<member name="T:Validator">
</member>
<member name="T:BaconQrCode.Common.BitArray">
<summary>
A simple, fast array of bits.
</summary>
</member>
<member name="F:BaconQrCode.Common.BitArray.bits">
<summary>
Bits represented as an array of integers.
</summary>

</member>
<member name="F:BaconQrCode.Common.BitArray.size">
<summary>
Size of the bit array in bits.
</summary>

</member>
<member name="M:BaconQrCode.Common.BitArray.#ctor(System.Int64)">
<summary>
Creates a new bit array with a given size.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.#ctor(Pchp.Core.Context,System.Int64)">
<summary>
Creates a new bit array with a given size.
</summary>
</member>
<member name="T:BaconQrCode.Common.BitMatrix">
<summary>
Bit matrix.
Represents a 2D matrix of bits. In function arguments below, and throughout
the common module, x is the column position, and y is the row position. The
ordering is always x, y. The origin is at the top-left.
</summary>
</member>
<member name="F:BaconQrCode.Common.BitMatrix.width">
<summary>
Width of the bit matrix.
</summary>

</member>
<member name="F:BaconQrCode.Common.BitMatrix.height">
<summary>
Height of the bit matrix.
</summary>

</member>
<member name="F:BaconQrCode.Common.BitMatrix.rowSize">
<summary>
Size in bits of each individual row.
</summary>

</member>
<member name="F:BaconQrCode.Common.BitMatrix.bits">
<summary>
Bits representation.
</summary>

</member>
<member name="M:BaconQrCode.Common.BitMatrix.#ctor(System.Int64,Pchp.Core.PhpValue)">
<exception cref="InvalidArgumentException">if a dimension is smaller than zero</exception>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.#ctor(Pchp.Core.Context,System.Int64,Pchp.Core.PhpValue)">
<exception cref="InvalidArgumentException">if a dimension is smaller than zero</exception>
</member>
<member name="T:BaconQrCode.Common.BitUtils">
<summary>
General bit utilities.
All utility methods are based on 32-bit integers and also work on 64-bit
systems.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitUtils.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Common.CharacterSetEci">
<summary>
Encapsulates a Character Set ECI, according to "Extended Channel Interpretations" 5.3.1.1 of ISO 18004.
</summary>
</member>
<member name="M:BaconQrCode.Common.CharacterSetEci.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Common.EcBlock">
<summary>
Encapsulates the parameters for one error-correction block in one symbol version.
This includes the number of data codewords, and the number of times a block with these parameters is used
consecutively in the QR code version's format.
</summary>
</member>
<member name="F:BaconQrCode.Common.EcBlock.count">
<summary>
How many times the block is used.
</summary>

</member>
<member name="F:BaconQrCode.Common.EcBlock.dataCodewords">
<summary>
Number of data codewords.
</summary>

</member>
<member name="M:BaconQrCode.Common.EcBlock.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Common.EcBlocks">
<summary>
Encapsulates a set of error-correction blocks in one symbol version.
Most versions will use blocks of differing sizes within one version, so, this encapsulates the parameters for each
set of blocks. It also holds the number of error-correction codewords per block since it will be the same across all
blocks within one version.
</summary>
</member>
<member name="F:BaconQrCode.Common.EcBlocks.ecCodewordsPerBlock">
<summary>
Number of EC codewords per block.
</summary>

</member>
<member name="F:BaconQrCode.Common.EcBlocks.ecBlocks">
<summary>
List of EC blocks.
</summary>

</member>
<member name="M:BaconQrCode.Common.EcBlocks.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Common.ErrorCorrectionLevel">
<summary>
Enum representing the four error correction levels.
</summary>
</member>
<member name="M:BaconQrCode.Common.ErrorCorrectionLevel.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Common.FormatInformation">
<summary>
Encapsulates a QR Code's format information, including the data mask used and error correction level.
</summary>
</member>
<member name="F:BaconQrCode.Common.FormatInformation.ecLevel">
<summary>
Error correction level.
</summary>

</member>
<member name="F:BaconQrCode.Common.FormatInformation.dataMask">
<summary>
Data mask.
</summary>

</member>
<member name="F:BaconQrCode.Common.FormatInformation.FORMAT_INFO_MASK_QR">
<summary>
Mask for format information.
</summary>

</member>
<member name="M:BaconQrCode.Common.FormatInformation.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Common.Mode">
<summary>
Enum representing various modes in which data can be encoded to bits.
</summary>
</member>
<member name="M:BaconQrCode.Common.Mode.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Common.ReedSolomonCodec">
<summary>
Reed-Solomon codec for 8-bit characters.
Based on libfec by Phil Karn, KA9Q.
</summary>
</member>
<member name="F:BaconQrCode.Common.ReedSolomonCodec.symbolSize">
<summary>
Symbol size in bits.
</summary>

</member>
<member name="F:BaconQrCode.Common.ReedSolomonCodec.blockSize">
<summary>
Block size in symbols.
</summary>

</member>
<member name="F:BaconQrCode.Common.ReedSolomonCodec.firstRoot">
<summary>
First root of RS code generator polynomial, index form.
</summary>

</member>
<member name="F:BaconQrCode.Common.ReedSolomonCodec.primitive">
<summary>
Primitive element to generate polynomial roots, index form.
</summary>

</member>
<member name="F:BaconQrCode.Common.ReedSolomonCodec.iPrimitive">
<summary>
Prim-th root of 1, index form.
</summary>

</member>
<member name="F:BaconQrCode.Common.ReedSolomonCodec.numRoots">
<summary>
RS code generator polynomial degree (number of roots).
</summary>

</member>
<member name="F:BaconQrCode.Common.ReedSolomonCodec.padding">
<summary>
Padding bytes at front of shortened block.
</summary>

</member>
<member name="F:BaconQrCode.Common.ReedSolomonCodec.alphaTo">
<summary>
Log lookup table.
</summary>

</member>
<member name="F:BaconQrCode.Common.ReedSolomonCodec.indexOf">
<summary>
Anti-Log lookup table.
</summary>

</member>
<member name="F:BaconQrCode.Common.ReedSolomonCodec.generatorPoly">
<summary>
Generator polynomial.
</summary>

</member>
<member name="M:BaconQrCode.Common.ReedSolomonCodec.#ctor(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
<exception cref="InvalidArgumentException">if symbol size ist not between 0 and 8</exception>
<exception cref="InvalidArgumentException">if first root is invalid</exception>
<exception cref="InvalidArgumentException">if num roots is invalid</exception>
<exception cref="InvalidArgumentException">if padding is invalid</exception>
<exception cref="RuntimeException">if field generator polynomial is not primitive</exception>
</member>
<member name="M:BaconQrCode.Common.ReedSolomonCodec.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Common.ReedSolomonCodec.#ctor(Pchp.Core.Context,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
<exception cref="InvalidArgumentException">if symbol size ist not between 0 and 8</exception>
<exception cref="InvalidArgumentException">if first root is invalid</exception>
<exception cref="InvalidArgumentException">if num roots is invalid</exception>
<exception cref="InvalidArgumentException">if padding is invalid</exception>
<exception cref="RuntimeException">if field generator polynomial is not primitive</exception>
</member>
<member name="T:BaconQrCode.Common.Version">
<summary>
Version representation.
</summary>
</member>
<member name="F:BaconQrCode.Common.Version.versionNumber">
<summary>
Version number of this version.
</summary>

</member>
<member name="F:BaconQrCode.Common.Version.alignmentPatternCenters">
<summary>
Alignment pattern centers.
</summary>

</member>
<member name="F:BaconQrCode.Common.Version.ecBlocks">
<summary>
Error correction blocks.
</summary>

</member>
<member name="F:BaconQrCode.Common.Version.totalCodewords">
<summary>
Total number of codewords.
</summary>

</member>
<member name="M:BaconQrCode.Common.Version.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Common.Version.#ctor(Pchp.Core.Context,System.Int64,Pchp.Core.PhpArray,BaconQrCode.Common.EcBlocks[])">
<param name="alignmentPatternCenters" type="int[]"></param>
</member>
<member name="T:BaconQrCode.Encoder.BlockPair">
<summary>
Block pair.
</summary>
</member>
<member name="F:BaconQrCode.Encoder.BlockPair.dataBytes">
<summary>
Data bytes in the block.
</summary>

</member>
<member name="F:BaconQrCode.Encoder.BlockPair.errorCorrectionBytes">
<summary>
Error correction bytes in the block.
</summary>

</member>
<member name="M:BaconQrCode.Encoder.BlockPair.#ctor(Pchp.Library.Spl.SplFixedArray,Pchp.Library.Spl.SplFixedArray)">
<summary>
Creates a new block pair.
</summary>
<param name="data" type="SplFixedArray&lt;int&gt;"></param>
<param name="errorCorrection" type="SplFixedArray&lt;int&gt;"></param>
</member>
<member name="M:BaconQrCode.Encoder.BlockPair.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.BlockPair.#ctor(Pchp.Core.Context,Pchp.Library.Spl.SplFixedArray,Pchp.Library.Spl.SplFixedArray)">
<summary>
Creates a new block pair.
</summary>
<param name="data" type="SplFixedArray&lt;int&gt;"></param>
<param name="errorCorrection" type="SplFixedArray&lt;int&gt;"></param>
</member>
<member name="T:BaconQrCode.Encoder.ByteMatrix">
<summary>
Byte matrix.
</summary>
</member>
<member name="F:BaconQrCode.Encoder.ByteMatrix.bytes">
<summary>
Bytes in the matrix, represented as array.
</summary>

</member>
<member name="F:BaconQrCode.Encoder.ByteMatrix.width">
<summary>
Width of the matrix.
</summary>

</member>
<member name="F:BaconQrCode.Encoder.ByteMatrix.height">
<summary>
Height of the matrix.
</summary>

</member>
<member name="M:BaconQrCode.Encoder.ByteMatrix.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Encoder.Encoder">
<summary>
Encoder.
</summary>
</member>
<member name="F:BaconQrCode.Encoder.Encoder.DEFAULT_BYTE_MODE_ECODING">
<summary>
Default byte encoding.
</summary>

</member>
<member name="T:BaconQrCode.Encoder.MaskUtil">
<summary>
Mask utility.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MaskUtil.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Encoder.MatrixUtil">
<summary>
Matrix utility.
</summary>
</member>
<member name="F:BaconQrCode.Encoder.MatrixUtil.VERSION_INFO_POLY">
<summary>
Version information polynomial.
</summary>

</member>
<member name="F:BaconQrCode.Encoder.MatrixUtil.TYPE_INFO_POLY">
<summary>
Type information polynomial.
</summary>

</member>
<member name="F:BaconQrCode.Encoder.MatrixUtil.TYPE_INFO_MASK_PATTERN">
<summary>
Type information mask pattern.
</summary>

</member>
<member name="T:BaconQrCode.Encoder.QrCode">
<summary>
QR code.
</summary>
</member>
<member name="F:BaconQrCode.Encoder.QrCode.mode">
<summary>
Mode of the QR code.
</summary>

</member>
<member name="F:BaconQrCode.Encoder.QrCode.errorCorrectionLevel">
<summary>
EC level of the QR code.
</summary>

</member>
<member name="F:BaconQrCode.Encoder.QrCode.version">
<summary>
Version of the QR code.
</summary>

</member>
<member name="F:BaconQrCode.Encoder.QrCode.maskPattern">
<summary>
Mask pattern of the QR code.
</summary>

</member>
<member name="F:BaconQrCode.Encoder.QrCode.matrix">
<summary>
Matrix of the QR code.
</summary>

</member>
<member name="F:BaconQrCode.Encoder.QrCode.NUM_MASK_PATTERNS">
<summary>
Number of possible mask patterns.
</summary>

</member>
<member name="M:BaconQrCode.Encoder.QrCode.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Exception.ExceptionInterface">
</member>
<member name="T:BaconQrCode.Exception.InvalidArgumentException">
</member>
<member name="T:BaconQrCode.Exception.OutOfBoundsException">
</member>
<member name="T:BaconQrCode.Exception.RuntimeException">
</member>
<member name="T:BaconQrCode.Exception.UnexpectedValueException">
</member>
<member name="T:BaconQrCode.Exception.WriterException">
</member>
<member name="T:BaconQrCode.Renderer.Color.Alpha">
</member>
<member name="M:BaconQrCode.Renderer.Color.Alpha.#ctor(System.Int64,BaconQrCode.Renderer.Color.ColorInterface)">
<param name="alpha" type="int">the alpha value, 0 to 100</param>
</member>
<member name="M:BaconQrCode.Renderer.Color.Alpha.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Color.Alpha.#ctor(Pchp.Core.Context,System.Int64,BaconQrCode.Renderer.Color.ColorInterface)">
<param name="alpha" type="int">the alpha value, 0 to 100</param>
</member>
<member name="T:BaconQrCode.Renderer.Color.Cmyk">
</member>
<member name="M:BaconQrCode.Renderer.Color.Cmyk.#ctor(System.Int64,System.Int64,System.Int64,System.Int64)">
<param name="cyan" type="int">the cyan amount, 0 to 100</param>
<param name="magenta" type="int">the magenta amount, 0 to 100</param>
<param name="yellow" type="int">the yellow amount, 0 to 100</param>
<param name="black" type="int">the black amount, 0 to 100</param>
</member>
<member name="M:BaconQrCode.Renderer.Color.Cmyk.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Color.Cmyk.#ctor(Pchp.Core.Context,System.Int64,System.Int64,System.Int64,System.Int64)">
<param name="cyan" type="int">the cyan amount, 0 to 100</param>
<param name="magenta" type="int">the magenta amount, 0 to 100</param>
<param name="yellow" type="int">the yellow amount, 0 to 100</param>
<param name="black" type="int">the black amount, 0 to 100</param>
</member>
<member name="T:BaconQrCode.Renderer.Color.ColorInterface">
</member>
<member name="T:BaconQrCode.Renderer.Color.Gray">
</member>
<member name="M:BaconQrCode.Renderer.Color.Gray.#ctor(System.Int64)">
<param name="gray" type="int">the gray value between 0 (black) and 100 (white)</param>
</member>
<member name="M:BaconQrCode.Renderer.Color.Gray.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Color.Gray.#ctor(Pchp.Core.Context,System.Int64)">
<param name="gray" type="int">the gray value between 0 (black) and 100 (white)</param>
</member>
<member name="T:BaconQrCode.Renderer.Color.Rgb">
</member>
<member name="M:BaconQrCode.Renderer.Color.Rgb.#ctor(System.Int64,System.Int64,System.Int64)">
<param name="red" type="int">the red amount of the color, 0 to 255</param>
<param name="green" type="int">the green amount of the color, 0 to 255</param>
<param name="blue" type="int">the blue amount of the color, 0 to 255</param>
</member>
<member name="M:BaconQrCode.Renderer.Color.Rgb.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Color.Rgb.#ctor(Pchp.Core.Context,System.Int64,System.Int64,System.Int64)">
<param name="red" type="int">the red amount of the color, 0 to 255</param>
<param name="green" type="int">the green amount of the color, 0 to 255</param>
<param name="blue" type="int">the blue amount of the color, 0 to 255</param>
</member>
<member name="T:BaconQrCode.Renderer.Eye.CompositeEye">
<summary>
Combines the style of two different eyes.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Eye.CompositeEye.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Eye.EyeInterface">
<summary>
Interface for describing the look of an eye.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Eye.ModuleEye">
<summary>
Renders an eye based on a module renderer.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Eye.ModuleEye.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Eye.SimpleCircleEye">
<summary>
Renders the inner eye as a circle.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Eye.SimpleCircleEye.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Eye.SquareEye">
<summary>
Renders the eyes in their default square shape.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Eye.SquareEye.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Image.EpsImageBackEnd">
</member>
<member name="T:BaconQrCode.Renderer.Image.ImageBackEndInterface">
<summary>
Interface for back ends able to to produce path based images.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Image.ImagickImageBackEnd">
</member>
<member name="M:BaconQrCode.Renderer.Image.ImagickImageBackEnd.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Image.SvgImageBackEnd">
</member>
<member name="M:BaconQrCode.Renderer.Image.SvgImageBackEnd.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Image.TransformationMatrix">
</member>
<member name="M:BaconQrCode.Renderer.Image.TransformationMatrix.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.ImageRenderer">
</member>
<member name="M:BaconQrCode.Renderer.ImageRenderer.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Module.DotsModule">
<summary>
Renders individual modules as dots.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Module.DotsModule.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Module.EdgeIterator.Edge">
</member>
<member name="M:BaconQrCode.Renderer.Module.EdgeIterator.Edge.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Module.EdgeIterator.EdgeIterator">
<summary>
Edge iterator based on potrace.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Module.EdgeIterator.EdgeIterator.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Module.ModuleInterface">
<summary>
Interface describing how modules should be rendered.
A module always receives a byte matrix (with values either being 1 or 0). It returns a path, where the origin
coordinate (0, 0) equals the top left corner of the first matrix value.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Module.RoundnessModule">
<summary>
Rounds the corners of module groups.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Module.RoundnessModule.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Module.SquareModule">
<summary>
Groups modules together to a single path.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Module.SquareModule.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Path.Close">
</member>
<member name="M:BaconQrCode.Renderer.Path.Close.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Path.Curve">
</member>
<member name="M:BaconQrCode.Renderer.Path.Curve.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Path.EllipticArc">
</member>
<member name="M:BaconQrCode.Renderer.Path.EllipticArc.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Path.Line">
</member>
<member name="M:BaconQrCode.Renderer.Path.Line.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Path.Move">
</member>
<member name="M:BaconQrCode.Renderer.Path.Move.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.Path.OperationInterface">
</member>
<member name="T:BaconQrCode.Renderer.Path.Path">
<summary>
Internal Representation of a vector path.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.PlainTextRenderer">
</member>
<member name="M:BaconQrCode.Renderer.PlainTextRenderer.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.RendererInterface">
</member>
<member name="T:BaconQrCode.Renderer.RendererStyle.EyeFill">
</member>
<member name="M:BaconQrCode.Renderer.RendererStyle.EyeFill.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.RendererStyle.Fill">
</member>
<member name="M:BaconQrCode.Renderer.RendererStyle.Fill.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.RendererStyle.Gradient">
</member>
<member name="M:BaconQrCode.Renderer.RendererStyle.Gradient.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.RendererStyle.GradientType">
</member>
<member name="M:BaconQrCode.Renderer.RendererStyle.GradientType.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.RendererStyle.GradientType.#ctor(Pchp.Core.Context)">
<summary>
The constructor is private by default to avoid arbitrary enum creation.
When creating your own constructor for a parameterized enum, make sure to declare it as protected, so that
the static methods are able to construct it. Avoid making it public, as that would allow creation of
non-singleton enum instances.
</summary>
</member>
<member name="T:BaconQrCode.Renderer.RendererStyle.RendererStyle">
</member>
<member name="M:BaconQrCode.Renderer.RendererStyle.RendererStyle.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:BaconQrCode.Writer">
<summary>
QR code writer.
</summary>
</member>
<member name="F:BaconQrCode.Writer.renderer">
<summary>
Renderer instance.
</summary>

</member>
<member name="M:BaconQrCode.Writer.#ctor(BaconQrCode.Renderer.RendererInterface)">
<summary>
Creates a new writer with a specific renderer.
</summary>
</member>
<member name="M:BaconQrCode.Writer.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:BaconQrCode.Writer.#ctor(Pchp.Core.Context,BaconQrCode.Renderer.RendererInterface)">
<summary>
Creates a new writer with a specific renderer.
</summary>
</member>
<member name="T:ComposerAutoloaderInit0f004dd85c03cdf085379b6e359f9671">
</member>
<member name="T:Composer.Autoload.ComposerStaticInit0f004dd85c03cdf085379b6e359f9671">
</member>
<member name="T:Composer.Autoload.ClassLoader">
<summary>
ClassLoader implements a PSR-0, PSR-4 and classmap class loader.
$loader = new \Composer\Autoload\ClassLoader();

// register classes with namespaces
$loader-&gt;add('Symfony\Component', __DIR__.'/component');
$loader-&gt;add('Symfony',           __DIR__.'/framework');

// activate the autoloader
$loader-&gt;register();

// to enable searching the include path (eg. for PEAR packages)
$loader-&gt;setUseIncludePath(true);

In this example, if you try to use a class in the Symfony\Component
namespace or one of its children (Symfony\Component\Console for instance),
the autoloader will first look for the class under the component/
directory, and it will then fallback to the framework/ directory if not
found before giving up.

This class is loosely based on the Symfony UniversalClassLoader.
</summary>
</member>
<member name="M:Composer.Autoload.ClassLoader.#ctor(Pchp.Core.PhpValue)">
<param name="vendorDir" type="?string"></param>
</member>
<member name="M:Composer.Autoload.ClassLoader.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Composer.Autoload.ClassLoader.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<param name="vendorDir" type="?string"></param>
</member>
<member name="T:Composer.InstalledVersions">
<summary>
This class is copied in every Composer installed project and available to all
See also https://getcomposer.org/doc/07-runtime.md#installed-versions

To require its presence, you can require `composer-runtime-api ^2.0`
</summary>
</member>
<member name="T:DASPRiD.Enum.AbstractEnum">
</member>
<member name="T:DASPRiD.Enum.EnumMap">
<summary>
A specialized map implementation for use with enum type keys.
All of the keys in an enum map must come from a single enum type that is specified, when the map is created. Enum
maps are represented internally as arrays. This representation is extremely compact and efficient.

Enum maps are maintained in the natural order of their keys (the order in which the enum constants are declared).
This is reflected in the iterators returned by the collection views {@see self::getIterator()} and
{@see self::values()}.

Iterators returned by the collection views are not consistent: They may or may not show the effects of modifications
to the map that occur while the iteration is in progress.
</summary>
</member>
<member name="F:DASPRiD.Enum.EnumMap.keyType">
<summary>
The class name of the key.
</summary>

</member>
<member name="F:DASPRiD.Enum.EnumMap.valueType">
<summary>
The type of the value.
</summary>

</member>
<member name="F:DASPRiD.Enum.EnumMap.keyUniverse">
<summary>
All of the constants comprising the enum, cached for performance.
</summary>

</member>
<member name="F:DASPRiD.Enum.EnumMap.values">
<summary>
Array representation of this map. The ith element is the value to which universe[i] is currently mapped, or null
if it isn't mapped to anything, or NullValue if it's mapped to null.
</summary>

</member>
<member name="M:DASPRiD.Enum.EnumMap.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpString,System.Boolean)">
<summary>
Creates a new enum map.
</summary>
<param name="keyType" type="string">the type of the keys, must extend AbstractEnum</param>
<param name="valueType" type="string">the type of the values</param>
<param name="allowNullValues" type="bool">whether to allow null values</param>
<exception cref="IllegalArgumentException">when key type does not extend AbstractEnum</exception>
</member>
<member name="M:DASPRiD.Enum.EnumMap.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:DASPRiD.Enum.EnumMap.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString,System.Boolean)">
<summary>
Creates a new enum map.
</summary>
<param name="keyType" type="string">the type of the keys, must extend AbstractEnum</param>
<param name="valueType" type="string">the type of the values</param>
<param name="allowNullValues" type="bool">whether to allow null values</param>
<exception cref="IllegalArgumentException">when key type does not extend AbstractEnum</exception>
</member>
<member name="T:DASPRiD.Enum.Exception.CloneNotSupportedException">
</member>
<member name="T:DASPRiD.Enum.Exception.ExceptionInterface">
</member>
<member name="T:DASPRiD.Enum.Exception.ExpectationException">
</member>
<member name="T:DASPRiD.Enum.Exception.IllegalArgumentException">
</member>
<member name="T:DASPRiD.Enum.Exception.MismatchException">
</member>
<member name="T:DASPRiD.Enum.Exception.SerializeNotSupportedException">
</member>
<member name="T:DASPRiD.Enum.Exception.UnserializeNotSupportedException">
</member>
<member name="T:DASPRiD.Enum.NullValue">
</member>
<member name="M:DASPRiD.Enum.NullValue.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Bacon.ErrorCorrectionLevelConverter">
</member>
<member name="T:Endroid.QrCode.Bacon.MatrixFactory">
</member>
<member name="T:Endroid.QrCode.Builder.Builder">
</member>
<member name="F:Endroid.QrCode.Builder.Builder.options">
<summary>
array&lt;mixed&gt;{
data: string,
writer: WriterInterface,
writerOptions: array,
qrCodeClass: class-string,
logoClass: class-string,
labelClass: class-string,
validateResult: bool,
size?: int,
encoding?: EncodingInterface,
errorCorrectionLevel?: ErrorCorrectionLevelInterface,
roundBlockSizeMode?: RoundBlockSizeModeInterface,
margin?: int,
backgroundColor?: ColorInterface,
foregroundColor?: ColorInterface,
labelText?: string,
labelFont?: FontInterface,
labelAlignment?: LabelAlignmentInterface,
labelMargin?: MarginInterface,
labelTextColor?: ColorInterface,
logoPath?: string,
logoResizeToWidth?: int,
logoResizeToHeight?: int,
logoPunchoutBackground?: bool
}
</summary>

</member>
<member name="M:Endroid.QrCode.Builder.Builder.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Builder.BuilderInterface">
</member>
<member name="T:Endroid.QrCode.Builder.BuilderRegistry">
</member>
<member name="T:Endroid.QrCode.Builder.BuilderRegistryInterface">
</member>
<member name="T:Endroid.QrCode.Color.Color">
</member>
<member name="M:Endroid.QrCode.Color.Color.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Color.ColorInterface">
</member>
<member name="T:Endroid.QrCode.Encoding.Encoding">
</member>
<member name="M:Endroid.QrCode.Encoding.Encoding.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Encoding.EncodingInterface">
</member>
<member name="T:Endroid.QrCode.ErrorCorrectionLevel.ErrorCorrectionLevelHigh">
</member>
<member name="T:Endroid.QrCode.ErrorCorrectionLevel.ErrorCorrectionLevelInterface">
</member>
<member name="T:Endroid.QrCode.ErrorCorrectionLevel.ErrorCorrectionLevelLow">
</member>
<member name="T:Endroid.QrCode.ErrorCorrectionLevel.ErrorCorrectionLevelMedium">
</member>
<member name="T:Endroid.QrCode.ErrorCorrectionLevel.ErrorCorrectionLevelQuartile">
</member>
<member name="T:Endroid.QrCode.Exception.ValidationException">
</member>
<member name="T:Endroid.QrCode.ImageData.LabelImageData">
</member>
<member name="M:Endroid.QrCode.ImageData.LabelImageData.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.ImageData.LogoImageData">
</member>
<member name="M:Endroid.QrCode.ImageData.LogoImageData.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Endroid.QrCode.ImageData.LogoImageData.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpString,System.Int64,System.Int64,System.Boolean)">
<param name="image" type="mixed"></param>
</member>
<member name="T:Endroid.QrCode.Label.Alignment.LabelAlignmentCenter">
</member>
<member name="T:Endroid.QrCode.Label.Alignment.LabelAlignmentInterface">
</member>
<member name="T:Endroid.QrCode.Label.Alignment.LabelAlignmentLeft">
</member>
<member name="T:Endroid.QrCode.Label.Alignment.LabelAlignmentRight">
</member>
<member name="T:Endroid.QrCode.Label.Font.Font">
</member>
<member name="M:Endroid.QrCode.Label.Font.Font.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Label.Font.FontInterface">
</member>
<member name="T:Endroid.QrCode.Label.Font.NotoSans">
</member>
<member name="M:Endroid.QrCode.Label.Font.NotoSans.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Label.Font.OpenSans">
</member>
<member name="M:Endroid.QrCode.Label.Font.OpenSans.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Label.Label">
</member>
<member name="M:Endroid.QrCode.Label.Label.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Label.LabelInterface">
</member>
<member name="T:Endroid.QrCode.Label.Margin.Margin">
</member>
<member name="M:Endroid.QrCode.Label.Margin.Margin.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Label.Margin.MarginInterface">
</member>
<member name="T:Endroid.QrCode.Logo.Logo">
</member>
<member name="M:Endroid.QrCode.Logo.Logo.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Logo.LogoInterface">
</member>
<member name="T:Endroid.QrCode.Matrix.Matrix">
</member>
<member name="F:Endroid.QrCode.Matrix.Matrix.blockValues">
<summary>
array&lt;int, array&lt;int, int&gt;&gt;
</summary>

</member>
<member name="M:Endroid.QrCode.Matrix.Matrix.#ctor(Pchp.Core.PhpArray,System.Int64,System.Int64,Endroid.QrCode.RoundBlockSizeMode.RoundBlockSizeModeInterface)">
<param name="blockValues" type="array&lt;array&lt;int&gt;&gt;"></param>
</member>
<member name="M:Endroid.QrCode.Matrix.Matrix.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Endroid.QrCode.Matrix.Matrix.#ctor(Pchp.Core.Context,Pchp.Core.PhpArray,System.Int64,System.Int64,Endroid.QrCode.RoundBlockSizeMode.RoundBlockSizeModeInterface)">
<param name="blockValues" type="array&lt;array&lt;int&gt;&gt;"></param>
</member>
<member name="T:Endroid.QrCode.Matrix.MatrixFactoryInterface">
</member>
<member name="T:Endroid.QrCode.Matrix.MatrixInterface">
</member>
<member name="T:Endroid.QrCode.QrCode">
</member>
<member name="M:Endroid.QrCode.QrCode.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.QrCodeInterface">
</member>
<member name="T:Endroid.QrCode.RoundBlockSizeMode.RoundBlockSizeModeEnlarge">
</member>
<member name="T:Endroid.QrCode.RoundBlockSizeMode.RoundBlockSizeModeInterface">
</member>
<member name="T:Endroid.QrCode.RoundBlockSizeMode.RoundBlockSizeModeMargin">
</member>
<member name="T:Endroid.QrCode.RoundBlockSizeMode.RoundBlockSizeModeNone">
</member>
<member name="T:Endroid.QrCode.RoundBlockSizeMode.RoundBlockSizeModeShrink">
</member>
<member name="T:WritableInterface">
</member>
<member name="T:Endroid.QrCode.Writer.BinaryWriter">
</member>
<member name="T:Endroid.QrCode.Writer.ConsoleWriter">
<summary>
Writer of QR Code for CLI.
</summary>
</member>
<member name="T:Endroid.QrCode.Writer.DebugWriter">
</member>
<member name="T:Endroid.QrCode.Writer.EpsWriter">
</member>
<member name="T:Endroid.QrCode.Writer.PdfWriter">
</member>
<member name="T:Endroid.QrCode.Writer.PngWriter">
</member>
<member name="T:Endroid.QrCode.Writer.Result.AbstractResult">
</member>
<member name="T:Endroid.QrCode.Writer.Result.BinaryResult">
</member>
<member name="M:Endroid.QrCode.Writer.Result.BinaryResult.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Writer.Result.ConsoleResult">
</member>
<member name="M:Endroid.QrCode.Writer.Result.ConsoleResult.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Writer.Result.DebugResult">
</member>
<member name="M:Endroid.QrCode.Writer.Result.DebugResult.#ctor(Endroid.QrCode.Matrix.MatrixInterface,Endroid.QrCode.QrCodeInterface,Endroid.QrCode.Logo.LogoInterface,Endroid.QrCode.Label.LabelInterface,Pchp.Core.PhpArray)">
<param name="options" type="array&lt;mixed&gt;"></param>
</member>
<member name="M:Endroid.QrCode.Writer.Result.DebugResult.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Endroid.QrCode.Writer.Result.DebugResult.#ctor(Pchp.Core.Context,Endroid.QrCode.Matrix.MatrixInterface,Endroid.QrCode.QrCodeInterface,Endroid.QrCode.Logo.LogoInterface,Endroid.QrCode.Label.LabelInterface,Pchp.Core.PhpArray)">
<param name="options" type="array&lt;mixed&gt;"></param>
</member>
<member name="T:Endroid.QrCode.Writer.Result.EpsResult">
</member>
<member name="M:Endroid.QrCode.Writer.Result.EpsResult.#ctor(Endroid.QrCode.Matrix.MatrixInterface,Pchp.Core.PhpArray)">
<param name="lines" type="array&lt;string&gt;"></param>
</member>
<member name="M:Endroid.QrCode.Writer.Result.EpsResult.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Endroid.QrCode.Writer.Result.EpsResult.#ctor(Pchp.Core.Context,Endroid.QrCode.Matrix.MatrixInterface,Pchp.Core.PhpArray)">
<param name="lines" type="array&lt;string&gt;"></param>
</member>
<member name="T:Endroid.QrCode.Writer.Result.PdfResult">
</member>
<member name="M:Endroid.QrCode.Writer.Result.PdfResult.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Writer.Result.PngResult">
</member>
<member name="M:Endroid.QrCode.Writer.Result.PngResult.#ctor(Endroid.QrCode.Matrix.MatrixInterface,Pchp.Core.PhpValue)">
<param name="image" type="mixed"></param>
</member>
<member name="M:Endroid.QrCode.Writer.Result.PngResult.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Endroid.QrCode.Writer.Result.PngResult.#ctor(Pchp.Core.Context,Endroid.QrCode.Matrix.MatrixInterface,Pchp.Core.PhpValue)">
<param name="image" type="mixed"></param>
</member>
<member name="T:Endroid.QrCode.Writer.Result.ResultInterface">
</member>
<member name="T:Endroid.QrCode.Writer.Result.SvgResult">
</member>
<member name="M:Endroid.QrCode.Writer.Result.SvgResult.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:Endroid.QrCode.Writer.SvgWriter">
</member>
<member name="T:Endroid.QrCode.Writer.ValidatingWriterInterface">
</member>
<member name="T:Endroid.QrCode.Writer.WriterInterface">
</member>
<member name="T:GuzzleHttp.BodySummarizer">
</member>
<member name="M:GuzzleHttp.BodySummarizer.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.BodySummarizerInterface">
</member>
<member name="T:GuzzleHttp.Client">
</member>
<member name="F:GuzzleHttp.Client.config">
<summary>
Default request options
</summary>
<value>array</value>
</member>
<member name="M:GuzzleHttp.Client.#ctor(Pchp.Core.PhpArray)">
<summary>
Clients accept an array of constructor parameters.
Here's an example of creating a client using a base_uri and an array of
default request options to apply to each request:

$client = new Client([
'base_uri'        =&gt; 'http://www.foo.com/1.0/',
'timeout'         =&gt; 0,
'allow_redirects' =&gt; false,
'proxy'           =&gt; '192.168.16.1:10'
]);

Client configuration settings include the following options:

- handler: (callable) Function that transfers HTTP requests over the
wire. The function is called with a Psr7\Http\Message\RequestInterface
and array of transfer options, and must return a
GuzzleHttp\Promise\PromiseInterface that is fulfilled with a
Psr7\Http\Message\ResponseInterface on success.
If no handler is provided, a default handler will be created
that enables all of the request options below by attaching all of the
default middleware to the handler.
- base_uri: (string|UriInterface) Base URI of the client that is merged
into relative URIs. Can be a string or instance of UriInterface.
- **: any request option
</summary>
<param name="config" type="array">Client configuration settings.</param>
</member>
<member name="M:GuzzleHttp.Client.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Client.#ctor(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Clients accept an array of constructor parameters.
Here's an example of creating a client using a base_uri and an array of
default request options to apply to each request:

$client = new Client([
'base_uri'        =&gt; 'http://www.foo.com/1.0/',
'timeout'         =&gt; 0,
'allow_redirects' =&gt; false,
'proxy'           =&gt; '192.168.16.1:10'
]);

Client configuration settings include the following options:

- handler: (callable) Function that transfers HTTP requests over the
wire. The function is called with a Psr7\Http\Message\RequestInterface
and array of transfer options, and must return a
GuzzleHttp\Promise\PromiseInterface that is fulfilled with a
Psr7\Http\Message\ResponseInterface on success.
If no handler is provided, a default handler will be created
that enables all of the request options below by attaching all of the
default middleware to the handler.
- base_uri: (string|UriInterface) Base URI of the client that is merged
into relative URIs. Can be a string or instance of UriInterface.
- **: any request option
</summary>
<param name="config" type="array">Client configuration settings.</param>
</member>
<member name="T:GuzzleHttp.ClientInterface">
<summary>
Client interface for sending HTTP requests.
</summary>
</member>
<member name="F:GuzzleHttp.ClientInterface.MAJOR_VERSION">
<summary>
The Guzzle major version.
</summary>

</member>
<member name="T:GuzzleHttp.ClientTrait`1`1">
<summary>
Client interface for sending HTTP requests.
</summary>
</member>
<member name="T:GuzzleHttp.Cookie.CookieJar">
<summary>
Cookie jar that stores cookies as an array
</summary>
</member>
<member name="F:GuzzleHttp.Cookie.CookieJar.cookies">
<summary>
Loaded cookie data
</summary>
<value>SetCookie[]</value>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.#ctor(System.Boolean,Pchp.Core.PhpArray)">
<param name="strictMode" type="bool">Set to true to throw exceptions when invalid
cookies are added to the cookie jar.</param>
<param name="cookieArray" type="array">Array of SetCookie objects or a hash of
arrays that can be used with the SetCookie
constructor</param>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.#ctor(Pchp.Core.Context,System.Boolean,Pchp.Core.PhpArray)">
<param name="strictMode" type="bool">Set to true to throw exceptions when invalid
cookies are added to the cookie jar.</param>
<param name="cookieArray" type="array">Array of SetCookie objects or a hash of
arrays that can be used with the SetCookie
constructor</param>
</member>
<member name="T:GuzzleHttp.Cookie.CookieJarInterface">
<summary>
Stores HTTP cookies.
It extracts cookies from HTTP requests, and returns them in HTTP responses.
CookieJarInterface instances automatically expire contained cookies when
necessary. Subclasses are also responsible for storing and retrieving
cookies from a file, database, etc.
</summary>
</member>
<member name="T:GuzzleHttp.Cookie.FileCookieJar">
<summary>
Persists non-session cookies using a JSON formatted file
</summary>
</member>
<member name="F:GuzzleHttp.Cookie.FileCookieJar.filename">
<summary>
filename
</summary>
<value>string</value>
</member>
<member name="F:GuzzleHttp.Cookie.FileCookieJar.storeSessionCookies">
<summary>
Control whether to persist session cookies or not.
</summary>
<value>bool</value>
</member>
<member name="M:GuzzleHttp.Cookie.FileCookieJar.#ctor(Pchp.Core.PhpString,System.Boolean)">
<summary>
Create a new FileCookieJar object
</summary>
<param name="cookieFile" type="string">File to store the cookie data</param>
<param name="storeSessionCookies" type="bool">Set to true to store session cookies
in the cookie jar.</param>
<exception cref="RuntimeException">if the file cannot be found or created</exception>
</member>
<member name="M:GuzzleHttp.Cookie.FileCookieJar.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.FileCookieJar.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,System.Boolean)">
<summary>
Create a new FileCookieJar object
</summary>
<param name="cookieFile" type="string">File to store the cookie data</param>
<param name="storeSessionCookies" type="bool">Set to true to store session cookies
in the cookie jar.</param>
<exception cref="RuntimeException">if the file cannot be found or created</exception>
</member>
<member name="T:GuzzleHttp.Cookie.SessionCookieJar">
<summary>
Persists cookies in the client session
</summary>
</member>
<member name="F:GuzzleHttp.Cookie.SessionCookieJar.sessionKey">
<summary>
session key
</summary>
<value>string</value>
</member>
<member name="F:GuzzleHttp.Cookie.SessionCookieJar.storeSessionCookies">
<summary>
Control whether to persist session cookies or not.
</summary>
<value>bool</value>
</member>
<member name="M:GuzzleHttp.Cookie.SessionCookieJar.#ctor(Pchp.Core.PhpString,System.Boolean)">
<summary>
Create a new SessionCookieJar object
</summary>
<param name="sessionKey" type="string">Session key name to store the cookie
data in session</param>
<param name="storeSessionCookies" type="bool">Set to true to store session cookies
in the cookie jar.</param>
</member>
<member name="M:GuzzleHttp.Cookie.SessionCookieJar.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SessionCookieJar.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,System.Boolean)">
<summary>
Create a new SessionCookieJar object
</summary>
<param name="sessionKey" type="string">Session key name to store the cookie
data in session</param>
<param name="storeSessionCookies" type="bool">Set to true to store session cookies
in the cookie jar.</param>
</member>
<member name="T:GuzzleHttp.Cookie.SetCookie">
<summary>
Set-Cookie object
</summary>
</member>
<member name="F:GuzzleHttp.Cookie.SetCookie.data">
<summary>
Cookie data
</summary>
<value>array</value>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.#ctor(Pchp.Core.PhpArray)">
<param name="data" type="array">Array of cookie data provided by a Cookie parser</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.#ctor(Pchp.Core.Context,Pchp.Core.PhpArray)">
<param name="data" type="array">Array of cookie data provided by a Cookie parser</param>
</member>
<member name="T:GuzzleHttp.Exception.BadResponseException">
<summary>
Exception when an HTTP error occurs (4xx or 5xx error)
</summary>
</member>
<member name="M:GuzzleHttp.Exception.BadResponseException.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Exception.ClientException">
<summary>
Exception when a client error is encountered (4xx codes)
</summary>
</member>
<member name="M:GuzzleHttp.Exception.ClientException.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Exception.ConnectException">
<summary>
Exception thrown when a connection cannot be established.
Note that no response is present for a ConnectException
</summary>
</member>
<member name="M:GuzzleHttp.Exception.ConnectException.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Exception.GuzzleException">
</member>
<member name="T:GuzzleHttp.Exception.InvalidArgumentException">
</member>
<member name="T:GuzzleHttp.Exception.RequestException">
<summary>
HTTP Request exception
</summary>
</member>
<member name="M:GuzzleHttp.Exception.RequestException.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Exception.ServerException">
<summary>
Exception when a server error is encountered (5xx codes)
</summary>
</member>
<member name="M:GuzzleHttp.Exception.ServerException.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Exception.TooManyRedirectsException">
</member>
<member name="M:GuzzleHttp.Exception.TooManyRedirectsException.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Exception.TransferException">
</member>
<member name="T:GuzzleHttp.Handler.CurlFactory">
<summary>
Creates curl resources from a request
</summary>
</member>
<member name="F:GuzzleHttp.Handler.CurlFactory.maxHandles">
<summary>
Total number of idle handles to keep in cache
</summary>
<value>int</value>
</member>
<member name="M:GuzzleHttp.Handler.CurlFactory.#ctor(System.Int64)">
<param name="maxHandles" type="int">Maximum number of idle handles.</param>
</member>
<member name="M:GuzzleHttp.Handler.CurlFactory.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlFactory.#ctor(Pchp.Core.Context,System.Int64)">
<param name="maxHandles" type="int">Maximum number of idle handles.</param>
</member>
<member name="T:GuzzleHttp.Handler.CurlFactoryInterface">
</member>
<member name="T:GuzzleHttp.Handler.CurlHandler">
<summary>
HTTP handler that uses cURL easy handles as a transport layer.
When using the CurlHandler, custom curl options can be specified as an
associative array of curl option constants mapping to values in the
**curl** key of the "client" key of the request.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlHandler.#ctor(Pchp.Core.PhpArray)">
<summary>
Accepts an associative array of options:
- handle_factory: Optional curl factory used to create cURL handles.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlHandler.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlHandler.#ctor(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Accepts an associative array of options:
- handle_factory: Optional curl factory used to create cURL handles.
</summary>
</member>
<member name="T:GuzzleHttp.Handler.CurlMultiHandler">
</member>
<member name="F:GuzzleHttp.Handler.CurlMultiHandler.active">
<summary>
Will be higher than 0 when `curl_multi_exec` is still running.
</summary>
<value>int</value>
</member>
<member name="F:GuzzleHttp.Handler.CurlMultiHandler.handles">
<summary>
Request entry handles, indexed by handle id in `addRequest`.
</summary>
<value>array</value>
</member>
<member name="F:GuzzleHttp.Handler.CurlMultiHandler.delays">
<summary>
array&lt;int, float&gt; An array of delay times, indexed by handle id in `addRequest`.
</summary>

</member>
<member name="F:GuzzleHttp.Handler.CurlMultiHandler.options">
<summary>
An associative array of CURLMOPT_* options and corresponding values for curl_multi_setopt()
</summary>
<value>array&lt;mixed&gt;</value>
</member>
<member name="M:GuzzleHttp.Handler.CurlMultiHandler.#ctor(Pchp.Core.PhpArray)">
<summary>
This handler accepts the following options:
- handle_factory: An optional factory  used to create curl handles
- select_timeout: Optional timeout (in seconds) to block before timing
out while selecting curl handles. Defaults to 1 second.
- options: An associative array of CURLMOPT_* options and
corresponding values for curl_multi_setopt()
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlMultiHandler.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlMultiHandler.#ctor(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
This handler accepts the following options:
- handle_factory: An optional factory  used to create curl handles
- select_timeout: Optional timeout (in seconds) to block before timing
out while selecting curl handles. Defaults to 1 second.
- options: An associative array of CURLMOPT_* options and
corresponding values for curl_multi_setopt()
</summary>
</member>
<member name="T:GuzzleHttp.Handler.EasyHandle">
<summary>
Represents a cURL easy handle and the data it populates.
</summary>
</member>
<member name="F:GuzzleHttp.Handler.EasyHandle.handle">
<summary>
cURL resource
</summary>
<value>resource|\CurlHandle</value>
</member>
<member name="F:GuzzleHttp.Handler.EasyHandle.sink">
<summary>
Where data is being written
</summary>
<value>StreamInterface</value>
</member>
<member name="F:GuzzleHttp.Handler.EasyHandle.headers">
<summary>
Received HTTP headers so far
</summary>
<value>array</value>
</member>
<member name="F:GuzzleHttp.Handler.EasyHandle.response">
<summary>
Received response (if any)
</summary>
<value>ResponseInterface|null</value>
</member>
<member name="F:GuzzleHttp.Handler.EasyHandle.request">
<summary>
Request being sent
</summary>
<value>RequestInterface</value>
</member>
<member name="F:GuzzleHttp.Handler.EasyHandle.options">
<summary>
Request options
</summary>
<value>array</value>
</member>
<member name="F:GuzzleHttp.Handler.EasyHandle.errno">
<summary>
cURL error number (if any)
</summary>
<value>int</value>
</member>
<member name="F:GuzzleHttp.Handler.EasyHandle.onHeadersException">
<summary>
Exception during on_headers (if any)
</summary>
<value>\Throwable|null</value>
</member>
<member name="F:GuzzleHttp.Handler.EasyHandle.createResponseException">
<summary>
Exception during createResponse (if any)
</summary>
<value>\Exception|null</value>
</member>
<member name="T:GuzzleHttp.Handler.HeaderProcessor">
</member>
<member name="T:GuzzleHttp.Handler.MockHandler">
<summary>
Handler that returns responses or throw exceptions from a queue.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.MockHandler.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
The passed in value must be an array of
{@see \Psr\Http\Message\ResponseInterface} objects, Exceptions,
callables, or Promises.
</summary>
<param name="onFulfilled" type="callable|null">Callback to invoke when the return value is fulfilled.</param>
<param name="onRejected" type="callable|null">Callback to invoke when the return value is rejected.</param>
</member>
<member name="M:GuzzleHttp.Handler.MockHandler.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.MockHandler.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
The passed in value must be an array of
{@see \Psr\Http\Message\ResponseInterface} objects, Exceptions,
callables, or Promises.
</summary>
<param name="onFulfilled" type="callable|null">Callback to invoke when the return value is fulfilled.</param>
<param name="onRejected" type="callable|null">Callback to invoke when the return value is rejected.</param>
</member>
<member name="T:GuzzleHttp.Handler.Proxy">
<summary>
Provides basic proxies for handlers.
</summary>
</member>
<member name="T:GuzzleHttp.Handler.StreamHandler">
<summary>
HTTP handler that uses PHP's HTTP stream wrapper.
</summary>
</member>
<member name="T:GuzzleHttp.HandlerStack">
<summary>
Creates a composed Guzzle handler function by stacking middlewares on top of
an HTTP handler function.
</summary>
</member>
<member name="F:GuzzleHttp.HandlerStack.handler">
<summary>
(callable(RequestInterface, array): PromiseInterface)|null
</summary>

</member>
<member name="F:GuzzleHttp.HandlerStack.stack">
<summary>
array{(callable(callable(RequestInterface, array): PromiseInterface): callable), (string|null)}[]
</summary>

</member>
<member name="F:GuzzleHttp.HandlerStack.cached">
<summary>
(callable(RequestInterface, array): PromiseInterface)|null
</summary>

</member>
<member name="M:GuzzleHttp.HandlerStack.#ctor(Pchp.Core.PhpValue)">
</member>
<member name="M:GuzzleHttp.HandlerStack.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.HandlerStack.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
</member>
<member name="T:GuzzleHttp.MessageFormatter">
<summary>
Formats log messages using variable substitutions for requests, responses,
and other transactional data.
The following variable substitutions are supported:

- {request}:        Full HTTP request message
- {response}:       Full HTTP response message
- {ts}:             ISO 8601 date in GMT
- {date_iso_8601}   ISO 8601 date in GMT
- {date_common_log} Apache common log date using the configured timezone.
- {host}:           Host of the request
- {method}:         Method of the request
- {uri}:            URI of the request
- {version}:        Protocol version
- {target}:         Request target of the request (path + query + fragment)
- {hostname}:       Hostname of the machine that sent the request
- {code}:           Status code of the response (if available)
- {phrase}:         Reason phrase of the response  (if available)
- {error}:          Any error messages (if available)
- {req_header_*}:   Replace `*` with the lowercased name of a request header to add to the message
- {res_header_*}:   Replace `*` with the lowercased name of a response header to add to the message
- {req_headers}:    Request headers
- {res_headers}:    Response headers
- {req_body}:       Request body
- {res_body}:       Response body
</summary>
</member>
<member name="F:GuzzleHttp.MessageFormatter.template">
<summary>
Template used to format log messages
</summary>
<value>string</value>
</member>
<member name="F:GuzzleHttp.MessageFormatter.CLF">
<summary>
Apache Common Log Format.
</summary>

</member>
<member name="M:GuzzleHttp.MessageFormatter.#ctor(Pchp.Core.PhpValue)">
<param name="template" type="string">Log message template</param>
</member>
<member name="M:GuzzleHttp.MessageFormatter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.MessageFormatter.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<param name="template" type="string">Log message template</param>
</member>
<member name="T:GuzzleHttp.MessageFormatterInterface">
</member>
<member name="T:GuzzleHttp.Middleware">
<summary>
Functions used to create and wrap handlers with handler middleware.
</summary>
</member>
<member name="T:GuzzleHttp.Pool">
<summary>
Sends an iterator of requests concurrently using a capped pool size.
The pool will read from an iterator until it is cancelled or until the
iterator is consumed. When a request is yielded, the request is sent after
applying the "request_options" request options (if provided in the ctor).

When a function is yielded by the iterator, the function is provided the
"request_options" array that should be merged on top of any existing
options, and the function MUST then return a wait-able promise.
</summary>
</member>
<member name="M:GuzzleHttp.Pool.#ctor(GuzzleHttp.ClientInterface,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<param name="client" type="ClientInterface">Client used to send the requests.</param>
<param name="requests" type="array|\Iterator">Requests or functions that return
requests to send concurrently.</param>
<param name="config" type="array">Associative array of options
- concurrency: (int) Maximum number of requests to send concurrently
- options: Array of request options to apply to each request.
- fulfilled: (callable) Function to invoke when a request completes.
- rejected: (callable) Function to invoke when a request is rejected.</param>
</member>
<member name="M:GuzzleHttp.Pool.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Pool.#ctor(Pchp.Core.Context,GuzzleHttp.ClientInterface,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<param name="client" type="ClientInterface">Client used to send the requests.</param>
<param name="requests" type="array|\Iterator">Requests or functions that return
requests to send concurrently.</param>
<param name="config" type="array">Associative array of options
- concurrency: (int) Maximum number of requests to send concurrently
- options: Array of request options to apply to each request.
- fulfilled: (callable) Function to invoke when a request completes.
- rejected: (callable) Function to invoke when a request is rejected.</param>
</member>
<member name="T:GuzzleHttp.PrepareBodyMiddleware">
<summary>
Prepares requests that contain a body, adding the Content-Length,
Content-Type, and Expect headers.
</summary>
</member>
<member name="F:GuzzleHttp.PrepareBodyMiddleware.nextHandler">
<summary>
callable(RequestInterface, array): PromiseInterface
</summary>

</member>
<member name="M:GuzzleHttp.PrepareBodyMiddleware.#ctor(Pchp.Core.PhpValue)">
</member>
<member name="M:GuzzleHttp.PrepareBodyMiddleware.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.PrepareBodyMiddleware.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
</member>
<member name="T:GuzzleHttp.RedirectMiddleware">
<summary>
Request redirect middleware.
Apply this middleware like other middleware using
{@see \GuzzleHttp\Middleware::redirect()}.
</summary>
</member>
<member name="F:GuzzleHttp.RedirectMiddleware.nextHandler">
<summary>
callable(RequestInterface, array): PromiseInterface
</summary>

</member>
<member name="M:GuzzleHttp.RedirectMiddleware.#ctor(Pchp.Core.PhpValue)">
</member>
<member name="M:GuzzleHttp.RedirectMiddleware.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.RedirectMiddleware.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
</member>
<member name="T:GuzzleHttp.RequestOptions">
<summary>
This class contains a list of built-in Guzzle request options.
More documentation for each option can be found at http://guzzlephp.org/.
</summary>
</member>
<member name="F:GuzzleHttp.RequestOptions.ALLOW_REDIRECTS">
<summary>
allow_redirects: (bool|array) Controls redirect behavior. Pass false
to disable redirects, pass true to enable redirects, pass an
associative to provide custom redirect settings. Defaults to "false".
This option only works if your handler has the RedirectMiddleware. When
passing an associative array, you can provide the following key value
pairs:

- max: (int, default=5) maximum number of allowed redirects.
- strict: (bool, default=false) Set to true to use strict redirects
meaning redirect POST requests with POST requests vs. doing what most
browsers do which is redirect POST requests with GET requests
- referer: (bool, default=false) Set to true to enable the Referer
header.
- protocols: (array, default=['http', 'https']) Allowed redirect
protocols.
- on_redirect: (callable) PHP callable that is invoked when a redirect
is encountered. The callable is invoked with the request, the redirect
response that was received, and the effective URI. Any return value
from the on_redirect function is ignored.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.AUTH">
<summary>
auth: (array) Pass an array of HTTP authentication parameters to use
with the request. The array must contain the username in index [0],
the password in index [1], and you can optionally provide a built-in
authentication type in index [2]. Pass null to disable authentication
for a request.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.BODY">
<summary>
body: (resource|string|null|int|float|StreamInterface|callable|\Iterator)
Body to send in the request.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.CERT">
<summary>
cert: (string|array) Set to a string to specify the path to a file
containing a PEM formatted SSL client side certificate. If a password
is required, then set cert to an array containing the path to the PEM
file in the first array element followed by the certificate password
in the second array element.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.COOKIES">
<summary>
cookies: (bool|GuzzleHttp\Cookie\CookieJarInterface, default=false)
Specifies whether or not cookies are used in a request or what cookie
jar to use or what cookies to send. This option only works if your
handler has the `cookie` middleware. Valid values are `false` and
an instance of {@see \GuzzleHttp\Cookie\CookieJarInterface}.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.CONNECT_TIMEOUT">
<summary>
connect_timeout: (float, default=0) Float describing the number of
seconds to wait while trying to connect to a server. Use 0 to wait
indefinitely (the default behavior).
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.DEBUG">
<summary>
debug: (bool|resource) Set to true or set to a PHP stream returned by
fopen()  enable debug output with the HTTP handler used to send a
request.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.DECODE_CONTENT">
<summary>
decode_content: (bool, default=true) Specify whether or not
Content-Encoding responses (gzip, deflate, etc.) are automatically
decoded.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.DELAY">
<summary>
delay: (int) The amount of time to delay before sending in milliseconds.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.EXPECT">
<summary>
expect: (bool|integer) Controls the behavior of the
"Expect: 100-Continue" header.
Set to `true` to enable the "Expect: 100-Continue" header for all
requests that sends a body. Set to `false` to disable the
"Expect: 100-Continue" header for all requests. Set to a number so that
the size of the payload must be greater than the number in order to send
the Expect header. Setting to a number will send the Expect header for
all requests in which the size of the payload cannot be determined or
where the body is not rewindable.

By default, Guzzle will add the "Expect: 100-Continue" header when the
size of the body of a request is greater than 1 MB and a request is
using HTTP/1.1.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.FORM_PARAMS">
<summary>
form_params: (array) Associative array of form field names to values
where each value is a string or array of strings. Sets the Content-Type
header to application/x-www-form-urlencoded when no Content-Type header
is already present.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.HEADERS">
<summary>
headers: (array) Associative array of HTTP headers. Each value MUST be
a string or array of strings.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.HTTP_ERRORS">
<summary>
http_errors: (bool, default=true) Set to false to disable exceptions
when a non- successful HTTP response is received. By default,
exceptions will be thrown for 4xx and 5xx responses. This option only
works if your handler has the `httpErrors` middleware.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.IDN_CONVERSION">
<summary>
idn: (bool|int, default=true) A combination of IDNA_* constants for
idn_to_ascii() PHP's function (see "options" parameter). Set to false to
disable IDN support completely, or to true to use the default
configuration (IDNA_DEFAULT constant).
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.JSON">
<summary>
json: (mixed) Adds JSON data to a request. The provided value is JSON
encoded and a Content-Type header of application/json will be added to
the request if no Content-Type header is already present.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.MULTIPART">
<summary>
multipart: (array) Array of associative arrays, each containing a
required "name" key mapping to the form field, name, a required
"contents" key mapping to a StreamInterface|resource|string, an
optional "headers" associative array of custom headers, and an
optional "filename" key mapping to a string to send as the filename in
the part. If no "filename" key is present, then no "filename" attribute
will be added to the part.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.ON_HEADERS">
<summary>
on_headers: (callable) A callable that is invoked when the HTTP headers
of the response have been received but the body has not yet begun to
download.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.ON_STATS">
<summary>
on_stats: (callable) allows you to get access to transfer statistics of
a request and access the lower level transfer details of the handler
associated with your client. ``on_stats`` is a callable that is invoked
when a handler has finished sending a request. The callback is invoked
with transfer statistics about the request, the response received, or
the error encountered. Included in the data is the total amount of time
taken to send the request.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.PROGRESS">
<summary>
progress: (callable) Defines a function to invoke when transfer
progress is made. The function accepts the following positional
arguments: the total number of bytes expected to be downloaded, the
number of bytes downloaded so far, the number of bytes expected to be
uploaded, the number of bytes uploaded so far.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.PROXY">
<summary>
proxy: (string|array) Pass a string to specify an HTTP proxy, or an
array to specify different proxies for different protocols (where the
key is the protocol and the value is a proxy string).
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.QUERY">
<summary>
query: (array|string) Associative array of query string values to add
to the request. This option uses PHP's http_build_query() to create
the string representation. Pass a string value if you need more
control than what this method provides
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.SINK">
<summary>
sink: (resource|string|StreamInterface) Where the data of the
response is written to. Defaults to a PHP temp stream. Providing a
string will write data to a file by the given name.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.SYNCHRONOUS">
<summary>
synchronous: (bool) Set to true to inform HTTP handlers that you intend
on waiting on the response. This can be useful for optimizations. Note
that a promise is still returned if you are using one of the async
client methods.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.SSL_KEY">
<summary>
ssl_key: (array|string) Specify the path to a file containing a private
SSL key in PEM format. If a password is required, then set to an array
containing the path to the SSL key in the first array element followed
by the password required for the certificate in the second element.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.STREAM">
<summary>
stream: Set to true to attempt to stream a response rather than
download it all up-front.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.VERIFY">
<summary>
verify: (bool|string, default=true) Describes the SSL certificate
verification behavior of a request. Set to true to enable SSL
certificate verification using the system CA bundle when available
(the default). Set to false to disable certificate verification (this
is insecure!). Set to a string to provide the path to a CA bundle on
disk to enable verification using a custom certificate.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.TIMEOUT">
<summary>
timeout: (float, default=0) Float describing the timeout of the
request in seconds. Use 0 to wait indefinitely (the default behavior).
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.READ_TIMEOUT">
<summary>
read_timeout: (float, default=default_socket_timeout ini setting) Float describing
the body read timeout, for stream requests.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.VERSION">
<summary>
version: (float) Specifies the HTTP protocol version to attempt to use.
</summary>

</member>
<member name="F:GuzzleHttp.RequestOptions.FORCE_IP_RESOLVE">
<summary>
force_ip_resolve: (bool) Force client to use only ipv4 or ipv6 protocol
</summary>

</member>
<member name="T:GuzzleHttp.RetryMiddleware">
<summary>
Middleware that retries requests based on the boolean result of
invoking the provided "decider" function.
</summary>
</member>
<member name="F:GuzzleHttp.RetryMiddleware.nextHandler">
<summary>
callable(RequestInterface, array): PromiseInterface
</summary>

</member>
<member name="F:GuzzleHttp.RetryMiddleware.delay">
<summary>
callable(int)
</summary>

</member>
<member name="M:GuzzleHttp.RetryMiddleware.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="decider" type="callable">Function that accepts the number of retries,
a request, [response], and [exception] and
returns true if the request is to be
retried.</param>
</member>
<member name="M:GuzzleHttp.RetryMiddleware.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.RetryMiddleware.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="decider" type="callable">Function that accepts the number of retries,
a request, [response], and [exception] and
returns true if the request is to be
retried.</param>
</member>
<member name="T:GuzzleHttp.TransferStats">
<summary>
Represents data at the point after it was transferred either successfully
or after a network error.
</summary>
</member>
<member name="M:GuzzleHttp.TransferStats.#ctor(Psr.Http.Message.RequestInterface,Psr.Http.Message.ResponseInterface,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<param name="request" type="RequestInterface">Request that was sent.</param>
<param name="response" type="ResponseInterface|null">Response received (if any)</param>
<param name="transferTime" type="float|null">Total handler transfer time.</param>
<param name="handlerErrorData" type="mixed">Handler error data.</param>
<param name="handlerStats" type="array">Handler specific stats.</param>
</member>
<member name="M:GuzzleHttp.TransferStats.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.TransferStats.#ctor(Pchp.Core.Context,Psr.Http.Message.RequestInterface,Psr.Http.Message.ResponseInterface,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<param name="request" type="RequestInterface">Request that was sent.</param>
<param name="response" type="ResponseInterface|null">Response received (if any)</param>
<param name="transferTime" type="float|null">Total handler transfer time.</param>
<param name="handlerErrorData" type="mixed">Handler error data.</param>
<param name="handlerStats" type="array">Handler specific stats.</param>
</member>
<member name="T:GuzzleHttp.Utils">
</member>
<member name="T:GuzzleHttp.Promise.AggregateException">
<summary>
Exception thrown when too many errors occur in the some() or any() methods.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.AggregateException.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Promise.CancellationException">
<summary>
Exception that is set as the reason for a promise that has been cancelled.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.CancellationException.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="reason" type="mixed">Rejection reason.</param>
<param name="description" type="string">Optional description</param>
</member>
<member name="M:GuzzleHttp.Promise.CancellationException.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.CancellationException.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="reason" type="mixed">Rejection reason.</param>
<param name="description" type="string">Optional description</param>
</member>
<member name="T:GuzzleHttp.Promise.Coroutine">
<summary>
Creates a promise that is resolved using a generator that yields values or
promises (somewhat similar to C#'s async keyword).
When called, the Coroutine::of method will start an instance of the generator
and returns a promise that is fulfilled with its final yielded value.

Control is returned back to the generator when the yielded promise settles.
This can lead to less verbose code when doing lots of sequential async calls
with minimal processing in between.

use GuzzleHttp\Promise;

function createPromise($value) {
return new Promise\FulfilledPromise($value);
}

$promise = Promise\Coroutine::of(function () {
$value = (yield createPromise('a'));
try {
$value = (yield createPromise($value . 'b'));
} catch (\Exception $e) {
// The promise was rejected.
}
yield $value . 'c';
});

// Outputs "abc"
$promise-&gt;then(function ($v) { echo $v; });
</summary>
</member>
<member name="M:GuzzleHttp.Promise.Coroutine.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Promise.Create">
</member>
<member name="T:GuzzleHttp.Promise.Each">
</member>
<member name="T:GuzzleHttp.Promise.EachPromise">
<summary>
Represents a promise that iterates over many promises and invokes
side-effect functions in the process.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.EachPromise.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Configuration hash can include the following key value pairs:
- fulfilled: (callable) Invoked when a promise fulfills. The function
is invoked with three arguments: the fulfillment value, the index
position from the iterable list of the promise, and the aggregate
promise that manages all of the promises. The aggregate promise may
be resolved from within the callback to short-circuit the promise.
- rejected: (callable) Invoked when a promise is rejected. The
function is invoked with three arguments: the rejection reason, the
index position from the iterable list of the promise, and the
aggregate promise that manages all of the promises. The aggregate
promise may be resolved from within the callback to short-circuit
the promise.
- concurrency: (integer) Pass this configuration option to limit the
allowed number of outstanding concurrently executing promises,
creating a capped pool of promises. There is no limit by default.
</summary>
<param name="iterable" type="mixed">Promises or values to iterate.</param>
<param name="config" type="array">Configuration options</param>
</member>
<member name="M:GuzzleHttp.Promise.EachPromise.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.EachPromise.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Configuration hash can include the following key value pairs:
- fulfilled: (callable) Invoked when a promise fulfills. The function
is invoked with three arguments: the fulfillment value, the index
position from the iterable list of the promise, and the aggregate
promise that manages all of the promises. The aggregate promise may
be resolved from within the callback to short-circuit the promise.
- rejected: (callable) Invoked when a promise is rejected. The
function is invoked with three arguments: the rejection reason, the
index position from the iterable list of the promise, and the
aggregate promise that manages all of the promises. The aggregate
promise may be resolved from within the callback to short-circuit
the promise.
- concurrency: (integer) Pass this configuration option to limit the
allowed number of outstanding concurrently executing promises,
creating a capped pool of promises. There is no limit by default.
</summary>
<param name="iterable" type="mixed">Promises or values to iterate.</param>
<param name="config" type="array">Configuration options</param>
</member>
<member name="T:GuzzleHttp.Promise.FulfilledPromise">
<summary>
A promise that has been fulfilled.
Thenning off of this promise will invoke the onFulfilled callback
immediately and ignore other callbacks.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.FulfilledPromise.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Promise.Is">
</member>
<member name="T:GuzzleHttp.Promise.Promise">
<summary>
Promises/A+ implementation that avoids recursion when possible.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.Promise.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="waitFn" type="callable">Fn that when invoked resolves the promise.</param>
<param name="cancelFn" type="callable">Fn that when invoked cancels the promise.</param>
</member>
<member name="M:GuzzleHttp.Promise.Promise.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.Promise.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="waitFn" type="callable">Fn that when invoked resolves the promise.</param>
<param name="cancelFn" type="callable">Fn that when invoked cancels the promise.</param>
</member>
<member name="T:GuzzleHttp.Promise.PromiseInterface">
<summary>
A promise represents the eventual result of an asynchronous operation.
The primary way of interacting with a promise is through its then method,
which registers callbacks to receive either a promise’s eventual value or
the reason why the promise cannot be fulfilled.
</summary>
</member>
<member name="T:GuzzleHttp.Promise.PromisorInterface">
<summary>
Interface used with classes that return a promise.
</summary>
</member>
<member name="T:GuzzleHttp.Promise.RejectedPromise">
<summary>
A promise that has been rejected.
Thenning off of this promise will invoke the onRejected callback
immediately and ignore other callbacks.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.RejectedPromise.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Promise.RejectionException">
<summary>
A special exception that is thrown when waiting on a rejected promise.
The reason value is available via the getReason() method.
</summary>
</member>
<member name="F:GuzzleHttp.Promise.RejectionException.reason">
<summary>
Rejection reason.
</summary>
<value>mixed</value>
</member>
<member name="M:GuzzleHttp.Promise.RejectionException.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="reason" type="mixed">Rejection reason.</param>
<param name="description" type="string">Optional description</param>
</member>
<member name="M:GuzzleHttp.Promise.RejectionException.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.RejectionException.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="reason" type="mixed">Rejection reason.</param>
<param name="description" type="string">Optional description</param>
</member>
<member name="T:GuzzleHttp.Promise.TaskQueue">
<summary>
A task queue that executes tasks in a FIFO order.
This task queue class is used to settle promises asynchronously and
maintains a constant stack size. You can use the task queue asynchronously
by calling the `run()` function of the global task queue in an event loop.

GuzzleHttp\Promise\Utils::queue()-&gt;run();
</summary>
</member>
<member name="M:GuzzleHttp.Promise.TaskQueue.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Promise.TaskQueueInterface">
</member>
<member name="T:GuzzleHttp.Promise.Utils">
</member>
<member name="T:GuzzleHttp.Psr7.AppendStream">
<summary>
Reads from multiple streams, one after the other.
This is a read-only stream decorator.
</summary>
</member>
<member name="F:GuzzleHttp.Psr7.AppendStream.streams">
<summary>
Streams being decorated
</summary>
<value>StreamInterface[]</value>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.#ctor(Pchp.Core.PhpArray)">
<param name="streams" type="StreamInterface[]">Streams to decorate. Each stream must
be readable.</param>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.#ctor(Pchp.Core.Context,Pchp.Core.PhpArray)">
<param name="streams" type="StreamInterface[]">Streams to decorate. Each stream must
be readable.</param>
</member>
<member name="T:GuzzleHttp.Psr7.BufferStream">
<summary>
Provides a buffer stream that can be written to to fill a buffer, and read
from to remove bytes from the buffer.
This stream returns a "hwm" metadata value that tells upstream consumers
what the configured high water mark of the stream is, or the maximum
preferred size of the buffer.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.BufferStream.#ctor(System.Int64)">
<param name="hwm" type="int">High water mark, representing the preferred maximum
buffer size. If the size of the buffer exceeds the high
water mark, then calls to write will continue to succeed
but will return 0 to inform writers to slow down
until the buffer has been drained by reading from it.</param>
</member>
<member name="M:GuzzleHttp.Psr7.BufferStream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.BufferStream.#ctor(Pchp.Core.Context,System.Int64)">
<param name="hwm" type="int">High water mark, representing the preferred maximum
buffer size. If the size of the buffer exceeds the high
water mark, then calls to write will continue to succeed
but will return 0 to inform writers to slow down
until the buffer has been drained by reading from it.</param>
</member>
<member name="T:GuzzleHttp.Psr7.CachingStream">
<summary>
Stream decorator that can cache previously read bytes from a sequentially
read stream.
</summary>
</member>
<member name="F:GuzzleHttp.Psr7.CachingStream.remoteStream">
<summary>
Stream being wrapped
</summary>
<value>StreamInterface</value>
</member>
<member name="F:GuzzleHttp.Psr7.CachingStream.skipReadBytes">
<summary>
Number of bytes to skip reading due to a write on the buffer
</summary>
<value>int</value>
</member>
<member name="M:GuzzleHttp.Psr7.CachingStream.#ctor(Psr.Http.Message.StreamInterface,Psr.Http.Message.StreamInterface)">
<summary>
We will treat the buffer object as the body of the stream
</summary>
<param name="stream" type="StreamInterface">Stream to cache. The cursor is assumed to be at the beginning of the stream.</param>
<param name="target" type="StreamInterface">Optionally specify where data is cached</param>
</member>
<member name="M:GuzzleHttp.Psr7.CachingStream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.CachingStream.#ctor(Pchp.Core.Context,Psr.Http.Message.StreamInterface,Psr.Http.Message.StreamInterface)">
<summary>
We will treat the buffer object as the body of the stream
</summary>
<param name="stream" type="StreamInterface">Stream to cache. The cursor is assumed to be at the beginning of the stream.</param>
<param name="target" type="StreamInterface">Optionally specify where data is cached</param>
</member>
<member name="T:GuzzleHttp.Psr7.DroppingStream">
<summary>
Stream decorator that begins dropping data once the size of the underlying
stream becomes too full.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.DroppingStream.#ctor(Psr.Http.Message.StreamInterface,System.Int64)">
<param name="stream" type="StreamInterface">Underlying stream to decorate.</param>
<param name="maxLength" type="int">Maximum size before dropping data.</param>
</member>
<member name="M:GuzzleHttp.Psr7.DroppingStream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.DroppingStream.#ctor(Pchp.Core.Context,Psr.Http.Message.StreamInterface,System.Int64)">
<param name="stream" type="StreamInterface">Underlying stream to decorate.</param>
<param name="maxLength" type="int">Maximum size before dropping data.</param>
</member>
<member name="T:GuzzleHttp.Psr7.Exception.MalformedUriException">
<summary>
Exception thrown if a URI cannot be parsed because it's malformed.
</summary>
</member>
<member name="T:GuzzleHttp.Psr7.FnStream">
</member>
<member name="F:GuzzleHttp.Psr7.FnStream.methods">
<summary>
array&lt;string, callable&gt;
</summary>

</member>
<member name="M:GuzzleHttp.Psr7.FnStream.#ctor(Pchp.Core.PhpArray)">
</member>
<member name="M:GuzzleHttp.Psr7.FnStream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.FnStream.#ctor(Pchp.Core.Context,Pchp.Core.PhpArray)">
</member>
<member name="T:GuzzleHttp.Psr7.Header">
</member>
<member name="T:GuzzleHttp.Psr7.HttpFactory">
<summary>
Implements all of the PSR-17 interfaces.
Note: in consuming code it is recommended to require the implemented interfaces
and inject the instance of this class multiple times.
</summary>
</member>
<member name="T:GuzzleHttp.Psr7.InflateStream">
<summary>
Uses PHP's zlib.inflate filter to inflate zlib (HTTP deflate, RFC1950) or gzipped (RFC1952) content.
This stream decorator converts the provided stream to a PHP stream resource,
then appends the zlib.inflate filter. The stream is then converted back
to a Guzzle stream resource to be used as a Guzzle stream.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.InflateStream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Psr7.LazyOpenStream">
</member>
<member name="M:GuzzleHttp.Psr7.LazyOpenStream.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<param name="filename" type="string">File to lazily open</param>
<param name="mode" type="string">fopen mode to use when opening the stream</param>
</member>
<member name="M:GuzzleHttp.Psr7.LazyOpenStream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.LazyOpenStream.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<param name="filename" type="string">File to lazily open</param>
<param name="mode" type="string">fopen mode to use when opening the stream</param>
</member>
<member name="T:GuzzleHttp.Psr7.LimitStream">
<summary>
Decorator used to return only a subset of a stream.
</summary>
</member>
<member name="F:GuzzleHttp.Psr7.LimitStream.offset">
<summary>
Offset to start reading from
</summary>
<value>int</value>
</member>
<member name="F:GuzzleHttp.Psr7.LimitStream.limit">
<summary>
Limit the number of bytes that can be read
</summary>
<value>int</value>
</member>
<member name="M:GuzzleHttp.Psr7.LimitStream.#ctor(Psr.Http.Message.StreamInterface,System.Int64,System.Int64)">
<param name="stream" type="StreamInterface">Stream to wrap</param>
<param name="limit" type="int">Total number of bytes to allow to be read
from the stream. Pass -1 for no limit.</param>
<param name="offset" type="int">Position to seek to before reading (only
works on seekable streams).</param>
</member>
<member name="M:GuzzleHttp.Psr7.LimitStream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.LimitStream.#ctor(Pchp.Core.Context,Psr.Http.Message.StreamInterface,System.Int64,System.Int64)">
<param name="stream" type="StreamInterface">Stream to wrap</param>
<param name="limit" type="int">Total number of bytes to allow to be read
from the stream. Pass -1 for no limit.</param>
<param name="offset" type="int">Position to seek to before reading (only
works on seekable streams).</param>
</member>
<member name="T:GuzzleHttp.Psr7.Message">
</member>
<member name="T:GuzzleHttp.Psr7.MessageTrait`1`1">
<summary>
Trait implementing functionality common to requests and responses.
</summary>
</member>
<member name="F:GuzzleHttp.Psr7.MessageTrait`1`1.headers">
<summary>
array&lt;string, string[]&gt; Map of all registered headers, as original name =&gt; array of values
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.MessageTrait`1`1.headerNames">
<summary>
array&lt;string, string&gt; Map of lowercase header name =&gt; original name at registration
</summary>

</member>
<member name="T:GuzzleHttp.Psr7.MimeType">
</member>
<member name="T:GuzzleHttp.Psr7.MultipartStream">
<summary>
Stream that when read returns bytes for a streaming multipart or
multipart/form-data stream.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.MultipartStream.#ctor(Pchp.Core.PhpArray,Pchp.Core.PhpValue)">
<param name="elements" type="array">Array of associative arrays, each containing a
required "name" key mapping to the form field,
name, a required "contents" key mapping to a
StreamInterface/resource/string, an optional
"headers" associative array of custom headers,
and an optional "filename" key mapping to a
string to send as the filename in the part.</param>
<param name="boundary" type="string">You can optionally provide a specific boundary</param>
</member>
<member name="M:GuzzleHttp.Psr7.MultipartStream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.MultipartStream.#ctor(Pchp.Core.Context,Pchp.Core.PhpArray,Pchp.Core.PhpValue)">
<param name="elements" type="array">Array of associative arrays, each containing a
required "name" key mapping to the form field,
name, a required "contents" key mapping to a
StreamInterface/resource/string, an optional
"headers" associative array of custom headers,
and an optional "filename" key mapping to a
string to send as the filename in the part.</param>
<param name="boundary" type="string">You can optionally provide a specific boundary</param>
</member>
<member name="T:GuzzleHttp.Psr7.NoSeekStream">
<summary>
Stream decorator that prevents a stream from being seeked.
</summary>
</member>
<member name="T:GuzzleHttp.Psr7.PumpStream">
<summary>
Provides a read only stream that pumps data from a PHP callable.
When invoking the provided callable, the PumpStream will pass the amount of
data requested to read to the callable. The callable can choose to ignore
this value and return fewer or more bytes than requested. Any extra data
returned by the provided callable is buffered internally until drained using
the read() function of the PumpStream. The provided callable MUST return
false when there is no more data to read.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.PumpStream.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
</member>
<member name="M:GuzzleHttp.Psr7.PumpStream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.PumpStream.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
</member>
<member name="T:GuzzleHttp.Psr7.Query">
</member>
<member name="T:GuzzleHttp.Psr7.Request">
<summary>
PSR-7 request implementation.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Request.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray,Pchp.Core.PhpValue,Pchp.Core.PhpString)">
<param name="method" type="string">HTTP method</param>
<param name="uri" type="string|UriInterface">URI</param>
<param name="body" type="string|resource|StreamInterface|null">Request body</param>
<param name="version" type="string">Protocol version</param>
</member>
<member name="M:GuzzleHttp.Psr7.Request.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Request.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray,Pchp.Core.PhpValue,Pchp.Core.PhpString)">
<param name="method" type="string">HTTP method</param>
<param name="uri" type="string|UriInterface">URI</param>
<param name="body" type="string|resource|StreamInterface|null">Request body</param>
<param name="version" type="string">Protocol version</param>
</member>
<member name="T:GuzzleHttp.Psr7.Response">
<summary>
PSR-7 response implementation.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Response.#ctor(System.Int64,Pchp.Core.PhpArray,Pchp.Core.PhpValue,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<param name="status" type="int">Status code</param>
<param name="body" type="string|resource|StreamInterface|null">Response body</param>
<param name="version" type="string">Protocol version</param>
<param name="reason" type="string|null">Reason phrase (when empty a default will be used based on the status code)</param>
</member>
<member name="M:GuzzleHttp.Psr7.Response.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Response.#ctor(Pchp.Core.Context,System.Int64,Pchp.Core.PhpArray,Pchp.Core.PhpValue,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<param name="status" type="int">Status code</param>
<param name="body" type="string|resource|StreamInterface|null">Response body</param>
<param name="version" type="string">Protocol version</param>
<param name="reason" type="string|null">Reason phrase (when empty a default will be used based on the status code)</param>
</member>
<member name="T:GuzzleHttp.Psr7.Rfc7230">
</member>
<member name="T:GuzzleHttp.Psr7.ServerRequest">
<summary>
Server-side HTTP request
Extends the Request definition to add methods for accessing incoming data,
specifically server parameters, cookies, matched path parameters, query
string arguments, body parameters, and upload file information.

"Attributes" are discovered via decomposing the request (and usually
specifically the URI path), and typically will be injected by the application.

Requests are considered immutable; all methods that might change state are
implemented such that they retain the internal state of the current
message and return a new instance that contains the changed state.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray,Pchp.Core.PhpValue,Pchp.Core.PhpString,Pchp.Core.PhpArray)">
<param name="method" type="string">HTTP method</param>
<param name="uri" type="string|UriInterface">URI</param>
<param name="body" type="string|resource|StreamInterface|null">Request body</param>
<param name="version" type="string">Protocol version</param>
<param name="serverParams" type="array">Typically the $_SERVER superglobal</param>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray,Pchp.Core.PhpValue,Pchp.Core.PhpString,Pchp.Core.PhpArray)">
<param name="method" type="string">HTTP method</param>
<param name="uri" type="string|UriInterface">URI</param>
<param name="body" type="string|resource|StreamInterface|null">Request body</param>
<param name="version" type="string">Protocol version</param>
<param name="serverParams" type="array">Typically the $_SERVER superglobal</param>
</member>
<member name="T:GuzzleHttp.Psr7.Stream">
<summary>
PHP stream implementation.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Stream.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
This constructor accepts an associative array of options.
- size: (int) If a read stream would otherwise have an indeterminate
size, but the size is known due to foreknowledge, then you can
provide that size, in bytes.
- metadata: (array) Any additional metadata to return when the metadata
of the stream is accessed.
</summary>
<param name="stream" type="resource">Stream resource to wrap.</param>
<exception cref="InvalidArgumentException">if the stream is not a stream resource</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Stream.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Stream.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
This constructor accepts an associative array of options.
- size: (int) If a read stream would otherwise have an indeterminate
size, but the size is known due to foreknowledge, then you can
provide that size, in bytes.
- metadata: (array) Any additional metadata to return when the metadata
of the stream is accessed.
</summary>
<param name="stream" type="resource">Stream resource to wrap.</param>
<exception cref="InvalidArgumentException">if the stream is not a stream resource</exception>
</member>
<member name="T:GuzzleHttp.Psr7.StreamDecoratorTrait`1`1">
<summary>
Stream decorator trait
</summary>
</member>
<member name="T:GuzzleHttp.Psr7.StreamWrapper">
<summary>
Converts Guzzle streams into PHP stream resources.
</summary>
</member>
<member name="F:GuzzleHttp.Psr7.StreamWrapper.mode">
<summary>
r, r+, or w
</summary>
<value>string</value>
</member>
<member name="T:GuzzleHttp.Psr7.UploadedFile">
</member>
<member name="M:GuzzleHttp.Psr7.UploadedFile.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpValue,System.Int64,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="streamOrFile" type="StreamInterface|string|resource"></param>
</member>
<member name="M:GuzzleHttp.Psr7.UploadedFile.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.UploadedFile.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,System.Int64,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="streamOrFile" type="StreamInterface|string|resource"></param>
</member>
<member name="T:GuzzleHttp.Psr7.Uri">
<summary>
PSR-7 URI implementation.
</summary>
</member>
<member name="F:GuzzleHttp.Psr7.Uri.scheme">
<summary>
Uri scheme.
</summary>
<value>string</value>
</member>
<member name="F:GuzzleHttp.Psr7.Uri.userInfo">
<summary>
Uri user info.
</summary>
<value>string</value>
</member>
<member name="F:GuzzleHttp.Psr7.Uri.host">
<summary>
Uri host.
</summary>
<value>string</value>
</member>
<member name="F:GuzzleHttp.Psr7.Uri.port">
<summary>
Uri port.
</summary>
<value>int|null</value>
</member>
<member name="F:GuzzleHttp.Psr7.Uri.path">
<summary>
Uri path.
</summary>
<value>string</value>
</member>
<member name="F:GuzzleHttp.Psr7.Uri.query">
<summary>
Uri query string.
</summary>
<value>string</value>
</member>
<member name="F:GuzzleHttp.Psr7.Uri.fragment">
<summary>
Uri fragment.
</summary>
<value>string</value>
</member>
<member name="F:GuzzleHttp.Psr7.Uri.composedComponents">
<summary>
String representation
</summary>
<value>string|null</value>
</member>
<member name="F:GuzzleHttp.Psr7.Uri.HTTP_DEFAULT_HOST">
<summary>
Absolute http and https URIs require a host per RFC 7230 Section 2.7
but in generic URIs the host can be empty. So for http(s) URIs
we apply this default host when no host is given yet to form a
valid URI.
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.Uri.CHAR_UNRESERVED">
<summary>
Unreserved characters for use in a regex.
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.Uri.CHAR_SUB_DELIMS">
<summary>
Sub-delims for use in a regex.
</summary>

</member>
<member name="M:GuzzleHttp.Psr7.Uri.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Psr7.UriComparator">
<summary>
Provides methods to determine if a modified URL should be considered cross-origin.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.UriComparator.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Psr7.UriNormalizer">
<summary>
Provides methods to normalize and compare URIs.
</summary>
</member>
<member name="F:GuzzleHttp.Psr7.UriNormalizer.PRESERVING_NORMALIZATIONS">
<summary>
Default normalizations which only include the ones that preserve semantics.
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.UriNormalizer.CAPITALIZE_PERCENT_ENCODING">
<summary>
All letters within a percent-encoding triplet (e.g., "%3A") are case-insensitive, and should be capitalized.
Example: http://example.org/a%c2%b1b → http://example.org/a%C2%B1b
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.UriNormalizer.DECODE_UNRESERVED_CHARACTERS">
<summary>
Decodes percent-encoded octets of unreserved characters.
For consistency, percent-encoded octets in the ranges of ALPHA (%41–%5A and %61–%7A), DIGIT (%30–%39),
hyphen (%2D), period (%2E), underscore (%5F), or tilde (%7E) should not be created by URI producers and,
when found in a URI, should be decoded to their corresponding unreserved characters by URI normalizers.

Example: http://example.org/%7Eusern%61me/ → http://example.org/~username/
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.UriNormalizer.CONVERT_EMPTY_PATH">
<summary>
Converts the empty path to "/" for http and https URIs.
Example: http://example.org → http://example.org/
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.UriNormalizer.REMOVE_DEFAULT_HOST">
<summary>
Removes the default host of the given URI scheme from the URI.
Only the "file" scheme defines the default host "localhost".
All of `file:/myfile`, `file:///myfile`, and `file://localhost/myfile`
are equivalent according to RFC 3986. The first format is not accepted
by PHPs stream functions and thus already normalized implicitly to the
second format in the Uri class. See `GuzzleHttp\Psr7\Uri::composeComponents`.

Example: file://localhost/myfile → file:///myfile
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.UriNormalizer.REMOVE_DEFAULT_PORT">
<summary>
Removes the default port of the given URI scheme from the URI.
Example: http://example.org:80/ → http://example.org/
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.UriNormalizer.REMOVE_DOT_SEGMENTS">
<summary>
Removes unnecessary dot-segments.
Dot-segments in relative-path references are not removed as it would
change the semantics of the URI reference.

Example: http://example.org/../a/b/../c/./d.html → http://example.org/a/c/d.html
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.UriNormalizer.REMOVE_DUPLICATE_SLASHES">
<summary>
Paths which include two or more adjacent slashes are converted to one.
Webservers usually ignore duplicate slashes and treat those URIs equivalent.
But in theory those URIs do not need to be equivalent. So this normalization
may change the semantics. Encoded slashes (%2F) are not removed.

Example: http://example.org//foo///bar.html → http://example.org/foo/bar.html
</summary>

</member>
<member name="F:GuzzleHttp.Psr7.UriNormalizer.SORT_QUERY_PARAMETERS">
<summary>
Sort query parameters with their values in alphabetical order.
However, the order of parameters in a URI may be significant (this is not defined by the standard).
So this normalization is not safe and may change the semantics of the URI.

Example: ?lang=en&amp;article=fred → ?article=fred&amp;lang=en

Note: The sorting is neither locale nor Unicode aware (the URI query does not get decoded at all) as the
purpose is to be able to compare URIs in a reproducible way, not to have the params sorted perfectly.
</summary>

</member>
<member name="M:GuzzleHttp.Psr7.UriNormalizer.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Psr7.UriResolver">
<summary>
Resolves a URI reference in the context of a base URI and the opposite way.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.UriResolver.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="T:GuzzleHttp.Psr7.Utils">
</member>
<member name="T:Psr.Http.Client.ClientExceptionInterface">
<summary>
Every HTTP client related exception MUST implement this interface.
</summary>
</member>
<member name="T:Psr.Http.Client.ClientInterface">
</member>
<member name="T:Psr.Http.Client.NetworkExceptionInterface">
<summary>
Thrown when the request cannot be completed because of network issues.
There is no response object as this exception is thrown when no response has been received.

Example: the target host name can not be resolved or the connection failed.
</summary>
</member>
<member name="T:Psr.Http.Client.RequestExceptionInterface">
<summary>
Exception for when a request failed.
Examples:
- Request is invalid (e.g. method is missing)
- Runtime request errors (e.g. the body stream is not seekable)
</summary>
</member>
<member name="T:Psr.Http.Message.RequestFactoryInterface">
</member>
<member name="T:Psr.Http.Message.ResponseFactoryInterface">
</member>
<member name="T:Psr.Http.Message.ServerRequestFactoryInterface">
</member>
<member name="T:Psr.Http.Message.StreamFactoryInterface">
</member>
<member name="T:Psr.Http.Message.UploadedFileFactoryInterface">
</member>
<member name="T:Psr.Http.Message.UriFactoryInterface">
</member>
<member name="T:Psr.Http.Message.MessageInterface">
<summary>
HTTP messages consist of requests from a client to a server and responses
from a server to a client. This interface defines the methods common to
each.
Messages are considered immutable; all methods that might change state MUST
be implemented such that they retain the internal state of the current
message and return an instance that contains the changed state.
</summary>
</member>
<member name="T:Psr.Http.Message.RequestInterface">
<summary>
Representation of an outgoing, client-side request.
Per the HTTP specification, this interface includes properties for
each of the following:

- Protocol version
- HTTP method
- URI
- Headers
- Message body

During construction, implementations MUST attempt to set the Host header from
a provided URI if no Host header is provided.

Requests are considered immutable; all methods that might change state MUST
be implemented such that they retain the internal state of the current
message and return an instance that contains the changed state.
</summary>
</member>
<member name="T:Psr.Http.Message.ResponseInterface">
<summary>
Representation of an outgoing, server-side response.
Per the HTTP specification, this interface includes properties for
each of the following:

- Protocol version
- Status code and reason phrase
- Headers
- Message body

Responses are considered immutable; all methods that might change state MUST
be implemented such that they retain the internal state of the current
message and return an instance that contains the changed state.
</summary>
</member>
<member name="T:Psr.Http.Message.ServerRequestInterface">
<summary>
Representation of an incoming, server-side HTTP request.
Per the HTTP specification, this interface includes properties for
each of the following:

- Protocol version
- HTTP method
- URI
- Headers
- Message body

Additionally, it encapsulates all data as it has arrived to the
application from the CGI and/or PHP environment, including:

- The values represented in $_SERVER.
- Any cookies provided (generally via $_COOKIE)
- Query string arguments (generally via $_GET, or as parsed via parse_str())
- Upload files, if any (as represented by $_FILES)
- Deserialized body parameters (generally from $_POST)

$_SERVER values MUST be treated as immutable, as they represent application
state at the time of request; as such, no methods are provided to allow
modification of those values. The other values provide such methods, as they
can be restored from $_SERVER or the request body, and may need treatment
during the application (e.g., body parameters may be deserialized based on
content type).

Additionally, this interface recognizes the utility of introspecting a
request to derive and match additional parameters (e.g., via URI path
matching, decrypting cookie values, deserializing non-form-encoded body
content, matching authorization headers to users, etc). These parameters
are stored in an "attributes" property.

Requests are considered immutable; all methods that might change state MUST
be implemented such that they retain the internal state of the current
message and return an instance that contains the changed state.
</summary>
</member>
<member name="T:Psr.Http.Message.StreamInterface">
<summary>
Describes a data stream.
Typically, an instance will wrap a PHP stream; this interface provides
a wrapper around the most common operations, including serialization of
the entire stream to a string.
</summary>
</member>
<member name="T:Psr.Http.Message.UploadedFileInterface">
<summary>
Value object representing a file uploaded through an HTTP request.
Instances of this interface are considered immutable; all methods that
might change state MUST be implemented such that they retain the internal
state of the current instance and return an instance that contains the
changed state.
</summary>
</member>
<member name="T:Psr.Http.Message.UriInterface">
<summary>
Value object representing a URI.
This interface is meant to represent URIs according to RFC 3986 and to
provide methods for most common operations. Additional functionality for
working with URIs can be provided on top of the interface or externally.
Its primary use is for HTTP requests, but may also be used in other
contexts.

Instances of this interface are considered immutable; all methods that
might change state MUST be implemented such that they retain the internal
state of the current instance and return an instance that contains the
changed state.

Typically the Host header will be also be present in the request message.
For server-side requests, the scheme will typically be discoverable in the
server parameters.
</summary>
</member>
<member name="T:Sop.AESKW.AESKeyWrapAlgorithm">
<summary>
Interface for AES Key Wrap Algorithm (RFC 3394) and
AES Key Wrap Padding Algorithm (RFC 5649).
</summary>
</member>
<member name="T:Sop.AESKW.AESKW128">
<summary>
Implements AES key wrap with 128 bit key size.
</summary>
</member>
<member name="M:Sop.AESKW.AESKW128.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="iv" type="string">Initial value</param>
</member>
<member name="M:Sop.AESKW.AESKW128.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.AESKW.AESKW128.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="iv" type="string">Initial value</param>
</member>
<member name="T:Sop.AESKW.AESKW192">
<summary>
Implements AES key wrap with 192 bit key size.
</summary>
</member>
<member name="M:Sop.AESKW.AESKW192.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="iv" type="string">Initial value</param>
</member>
<member name="M:Sop.AESKW.AESKW192.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.AESKW.AESKW192.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="iv" type="string">Initial value</param>
</member>
<member name="T:Sop.AESKW.AESKW256">
<summary>
Implements AES key wrap with 256 bit key size.
</summary>
</member>
<member name="M:Sop.AESKW.AESKW256.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="iv" type="string">Initial value</param>
</member>
<member name="M:Sop.AESKW.AESKW256.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.AESKW.AESKW256.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="iv" type="string">Initial value</param>
</member>
<member name="T:Sop.AESKW.Algorithm">
<summary>
Base class for AES key wrap algorithms with varying key sizes.
</summary>
</member>
<member name="F:Sop.AESKW.Algorithm._iv">
<summary>
Initial value.
</summary>

</member>
<member name="T:Sop.ASN1.Component.Identifier">
<summary>
Class to represent BER/DER identifier octets.
</summary>
</member>
<member name="F:Sop.ASN1.Component.Identifier._class">
<summary>
Type class.
</summary>

</member>
<member name="F:Sop.ASN1.Component.Identifier._pc">
<summary>
Primitive or Constructed.
</summary>

</member>
<member name="F:Sop.ASN1.Component.Identifier._tag">
<summary>
Content type tag.
</summary>

</member>
<member name="M:Sop.ASN1.Component.Identifier.#ctor(System.Int64,System.Int64,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="class" type="int">Type class</param>
<param name="pc" type="int">Primitive / Constructed</param>
<param name="tag" type="\GMP|int|string">Type tag number</param>
</member>
<member name="M:Sop.ASN1.Component.Identifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.#ctor(Pchp.Core.Context,System.Int64,System.Int64,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="class" type="int">Type class</param>
<param name="pc" type="int">Primitive / Constructed</param>
<param name="tag" type="\GMP|int|string">Type tag number</param>
</member>
<member name="T:Sop.ASN1.Component.Length">
<summary>
Class to represent BER/DER length octets.
</summary>
</member>
<member name="F:Sop.ASN1.Component.Length._length">
<summary>
Length.
</summary>

</member>
<member name="F:Sop.ASN1.Component.Length._indefinite">
<summary>
Whether length is indefinite.
</summary>

</member>
<member name="M:Sop.ASN1.Component.Length.#ctor(Pchp.Core.PhpValue,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="length" type="\GMP|int|string">Length</param>
<param name="indefinite" type="bool">Whether length is indefinite</param>
</member>
<member name="M:Sop.ASN1.Component.Length.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Length.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="length" type="\GMP|int|string">Length</param>
<param name="indefinite" type="bool">Whether length is indefinite</param>
</member>
<member name="T:Sop.ASN1.DERData">
<summary>
Container for raw DER encoded data.
May be inserted into structure without decoding first.
</summary>
</member>
<member name="F:Sop.ASN1.DERData._der">
<summary>
DER encoded data.
</summary>

</member>
<member name="F:Sop.ASN1.DERData._identifier">
<summary>
Identifier of the underlying type.
</summary>

</member>
<member name="F:Sop.ASN1.DERData._contentOffset">
<summary>
Offset to the content in DER data.
</summary>

</member>
<member name="M:Sop.ASN1.DERData.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="data" type="string">DER encoded data</param>
<exception cref="Sop.ASN1.Exception.DecodeException">If data does not adhere to DER</exception>
</member>
<member name="M:Sop.ASN1.DERData.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.DERData.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="data" type="string">DER encoded data</param>
<exception cref="Sop.ASN1.Exception.DecodeException">If data does not adhere to DER</exception>
</member>
<member name="T:Sop.ASN1.Element">
<summary>
Base class for all ASN.1 type elements.
</summary>
</member>
<member name="F:Sop.ASN1.Element._typeTag">
<summary>
Element's type tag.
</summary>

</member>
<member name="F:Sop.ASN1.Element._indefiniteLength">
<summary>
Whether type shall be encoded with indefinite length.
</summary>

</member>
<member name="F:Sop.ASN1.Element.TYPE_STRING">
<summary>
Pseudotype for all string types.
May be used as an expectation parameter.
</summary>

</member>
<member name="F:Sop.ASN1.Element.TYPE_TIME">
<summary>
Pseudotype for all time types.
May be used as an expectation parameter.
</summary>

</member>
<member name="F:Sop.ASN1.Element.TYPE_CONSTRUCTED_STRING">
<summary>
Pseudotype for constructed strings.
May be used as an expectation parameter.
</summary>

</member>
<member name="T:Sop.ASN1.Exception.DecodeException">
<summary>
Exception thrown on decoding errors.
</summary>
</member>
<member name="T:Sop.ASN1.Feature.ElementBase">
<summary>
Base interface for ASN.1 type elements.
</summary>
</member>
<member name="T:Sop.ASN1.Feature.Encodable">
<summary>
Interface for classes that may be encoded to DER.
</summary>
</member>
<member name="T:Sop.ASN1.Feature.Stringable">
<summary>
Interface for classes that may be cast to string.
</summary>
</member>
<member name="T:Sop.ASN1.Type.BaseString">
<summary>
Base class for all string types.
</summary>
</member>
<member name="F:Sop.ASN1.Type.BaseString._string">
<summary>
String value.
</summary>

</member>
<member name="T:Sop.ASN1.Type.BaseTime">
<summary>
Base class for all types representing a point in time.
</summary>
</member>
<member name="F:Sop.ASN1.Type.BaseTime._dateTime">
<summary>
Date and time.
</summary>

</member>
<member name="F:Sop.ASN1.Type.BaseTime.TZ_UTC">
<summary>
UTC timezone.
</summary>

</member>
<member name="T:Sop.ASN1.Type.Constructed.ConstructedString">
<summary>
Implements constructed type of simple strings.
Constructed strings only exist in BER encodings, and often with
indefinite length. Generally constructed string must contain only elements
that have the same type tag as the constructing element.
For example:
```
OCTET STRING (cons) {
OCTET STRING (prim) "ABC"
OCTET STRING (prim) "DEF"
}
```
Canonically this corresponds to a payload of "ABCDEF" string.

From API standpoint this can also be seen as a string type
(as it implements `StringType`), and thus `UnspecifiedType::asString()`
method may return `ConstructedString` instances.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.ConstructedString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.ConstructedString.#ctor(Pchp.Core.Context,Sop.ASN1.Element[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Constructed.Sequence">
<summary>
Implements *SEQUENCE* and *SEQUENCE OF* types.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.Sequence.#ctor(Sop.ASN1.Element[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.Sequence.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.Sequence.#ctor(Pchp.Core.Context,Sop.ASN1.Element[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Constructed.Set">
<summary>
Implements *SET* and *SET OF* types.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.Set.#ctor(Sop.ASN1.Element[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.Set.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.Set.#ctor(Pchp.Core.Context,Sop.ASN1.Element[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.BitString">
<summary>
Implements *BIT STRING* type.
</summary>
</member>
<member name="F:Sop.ASN1.Type.Primitive.BitString._unusedBits">
<summary>
Number of unused bits in the last octet.
</summary>

</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString.#ctor(Pchp.Core.PhpString,System.Int64)">
<summary>
Constructor.
</summary>
<param name="string" type="string">Content octets</param>
<param name="unused_bits" type="int">Number of unused bits in the last octet</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,System.Int64)">
<summary>
Constructor.
</summary>
<param name="string" type="string">Content octets</param>
<param name="unused_bits" type="int">Number of unused bits in the last octet</param>
</member>
<member name="T:Sop.ASN1.Type.Primitive.BMPString">
<summary>
Implements *BMPString* type.
BMP stands for Basic Multilingual Plane. This is generally an Unicode string
with UCS-2 encoding.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BMPString.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BMPString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BMPString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.Boolean">
<summary>
Implements *BOOLEAN* type.
</summary>
</member>
<member name="F:Sop.ASN1.Type.Primitive.Boolean._bool">
<summary>
Value.
</summary>

</member>
<member name="M:Sop.ASN1.Type.Primitive.Boolean.#ctor(System.Boolean)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Boolean.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Boolean.#ctor(Pchp.Core.Context,System.Boolean)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.CharacterString">
<summary>
Implements *CHARACTER STRING* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.CharacterString.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.CharacterString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.CharacterString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.Enumerated">
<summary>
Implements *ENUMERATED* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Enumerated.#ctor(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="number" type="int|string"></param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Enumerated.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Enumerated.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="number" type="int|string"></param>
</member>
<member name="T:Sop.ASN1.Type.Primitive.EOC">
<summary>
Implements *End-of-contents* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.EOC.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.EOC.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.EOC.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.GeneralizedTime">
<summary>
Implements *GeneralizedTime* type.
</summary>
</member>
<member name="F:Sop.ASN1.Type.Primitive.GeneralizedTime._formatted">
<summary>
Cached formatted date.
</summary>

</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralizedTime.#ctor(Pchp.Library.DateTime.DateTimeImmutable)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralizedTime.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralizedTime.#ctor(Pchp.Core.Context,Pchp.Library.DateTime.DateTimeImmutable)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.GeneralString">
<summary>
Implements *GeneralString* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralString.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.GraphicString">
<summary>
Implements *GraphicString* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GraphicString.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GraphicString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GraphicString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.IA5String">
<summary>
Implements *IA5String* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.IA5String.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.IA5String.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.IA5String.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.Integer">
<summary>
Implements *INTEGER* type.
</summary>
</member>
<member name="F:Sop.ASN1.Type.Primitive.Integer._number">
<summary>
The number.
</summary>

</member>
<member name="M:Sop.ASN1.Type.Primitive.Integer.#ctor(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="number" type="\GMP|int|string">Base 10 integer</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Integer.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Integer.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="number" type="\GMP|int|string">Base 10 integer</param>
</member>
<member name="T:Sop.ASN1.Type.Primitive.NullType">
<summary>
Implements *NULL* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NullType.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NullType.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NullType.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.NumericString">
<summary>
Implements *NumericString* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NumericString.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NumericString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NumericString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.ObjectDescriptor">
<summary>
Implements *ObjectDescriptor* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectDescriptor.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectDescriptor.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectDescriptor.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.ObjectIdentifier">
<summary>
Implements *OBJECT IDENTIFIER* type.
</summary>
</member>
<member name="F:Sop.ASN1.Type.Primitive.ObjectIdentifier._oid">
<summary>
Object identifier in dotted format.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Primitive.ObjectIdentifier._subids">
<summary>
Object identifier split to sub ID's.
</summary>

</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="oid" type="string">OID in dotted format</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="oid" type="string">OID in dotted format</param>
</member>
<member name="T:Sop.ASN1.Type.Primitive.OctetString">
<summary>
Implements *OCTET STRING* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.OctetString.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.OctetString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.OctetString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.PrintableString">
<summary>
Implements *PrintableString* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.PrintableString.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.PrintableString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.PrintableString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.Real">
<summary>
Implements *REAL* type.
</summary>
</member>
<member name="F:Sop.ASN1.Type.Primitive.Real._mantissa">
<summary>
Signed integer mantissa.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Primitive.Real._exponent">
<summary>
Signed integer exponent.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Primitive.Real._base">
<summary>
Abstract value base.
Must be 2 or 10.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Primitive.Real._strictDer">
<summary>
Whether to encode strictly in DER.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Primitive.Real._float">
<summary>
Number as a native float.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Primitive.Real.INF_EXPONENT">
<summary>
Exponent when value is positive or negative infinite.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Primitive.Real.EXP_BIAS">
<summary>
Exponent bias for IEEE 754 double precision float.
</summary>

</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpValue,System.Int64)">
<summary>
Constructor.
</summary>
<param name="mantissa" type="\GMP|int|string">Integer mantissa</param>
<param name="exponent" type="\GMP|int|string">Integer exponent</param>
<param name="base" type="int">Base, 2 or 10</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,System.Int64)">
<summary>
Constructor.
</summary>
<param name="mantissa" type="\GMP|int|string">Integer mantissa</param>
<param name="exponent" type="\GMP|int|string">Integer exponent</param>
<param name="base" type="int">Base, 2 or 10</param>
</member>
<member name="T:Sop.ASN1.Type.Primitive.RelativeOID">
<summary>
Implements *RELATIVE-OID* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.RelativeOID.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="oid" type="string">OID in dotted format</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.RelativeOID.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.RelativeOID.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="oid" type="string">OID in dotted format</param>
</member>
<member name="T:Sop.ASN1.Type.Primitive.T61String">
<summary>
Implements *T61String* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.T61String.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.T61String.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.T61String.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.UniversalString">
<summary>
Implements *UniversalString* type.
Universal string is an Unicode string with UCS-4 encoding.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UniversalString.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UniversalString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UniversalString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.UTCTime">
<summary>
Implements *UTCTime* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTCTime.#ctor(Pchp.Library.DateTime.DateTimeImmutable)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTCTime.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTCTime.#ctor(Pchp.Core.Context,Pchp.Library.DateTime.DateTimeImmutable)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.UTF8String">
<summary>
Implements *UTF8String* type.
*UTF8String* is an Unicode string with UTF-8 encoding.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTF8String.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTF8String.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTF8String.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.VideotexString">
<summary>
Implements *VideotexString* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.VideotexString.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.VideotexString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.VideotexString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Primitive.VisibleString">
<summary>
Implements *VisibleString* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.VisibleString.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.VisibleString.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.VisibleString.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Type.PrimitiveString">
<summary>
Base class for primitive strings.
Used by types that don't require special processing of the encoded string data.
</summary>
</member>
<member name="T:Sop.ASN1.Type.PrimitiveType`1`1">
<summary>
Trait for primitive types.
</summary>
</member>
<member name="T:Sop.ASN1.Type.StringType">
<summary>
Interface to mark types that correspond to ASN.1 specification's
character strings. That being all simple strings and time types.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Structure">
<summary>
Base class for the constructed types.
</summary>
</member>
<member name="F:Sop.ASN1.Type.Structure._elements">
<summary>
Array of elements in the structure.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Structure._taggedMap">
<summary>
Lookup table for the tagged elements.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Structure._unspecifiedTypes">
<summary>
Cache variable of elements wrapped into `UnspecifiedType` objects.
</summary>

</member>
<member name="T:Sop.ASN1.Type.Tagged.ApplicationType">
<summary>
Intermediate class to store DER data of an application specific type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ApplicationType.#ctor(Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,System.Int64,System.Int64,System.Int64,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="identifier" type="Identifier">Pre-parsed identifier</param>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to next byte after identifier</param>
<param name="value_offset" type="int">Offset to content</param>
<param name="value_length" type="int">Content length</param>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ApplicationType.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ApplicationType.#ctor(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,System.Int64,System.Int64,System.Int64,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="identifier" type="Identifier">Pre-parsed identifier</param>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to next byte after identifier</param>
<param name="value_offset" type="int">Offset to content</param>
<param name="value_length" type="int">Content length</param>
</member>
<member name="T:Sop.ASN1.Type.Tagged.ContextSpecificType">
<summary>
Intermediate class to store DER data of context specific type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ContextSpecificType.#ctor(Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,System.Int64,System.Int64,System.Int64,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="identifier" type="Identifier">Pre-parsed identifier</param>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to next byte after identifier</param>
<param name="value_offset" type="int">Offset to content</param>
<param name="value_length" type="int">Content length</param>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ContextSpecificType.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ContextSpecificType.#ctor(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,System.Int64,System.Int64,System.Int64,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="identifier" type="Identifier">Pre-parsed identifier</param>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to next byte after identifier</param>
<param name="value_offset" type="int">Offset to content</param>
<param name="value_length" type="int">Content length</param>
</member>
<member name="T:Sop.ASN1.Type.Tagged.DERTaggedType">
<summary>
Intermediate class to store tagged DER data.
`implicit($tag)` or `explicit()` method is used to decode the actual element,
which is only known by the abstract syntax of data structure.

May be encoded back to complete DER encoding.
</summary>
</member>
<member name="F:Sop.ASN1.Type.Tagged.DERTaggedType._identifier">
<summary>
Identifier.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Tagged.DERTaggedType._data">
<summary>
DER data.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Tagged.DERTaggedType._offset">
<summary>
Offset to next byte after identifier.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Tagged.DERTaggedType._valueOffset">
<summary>
Offset to content.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Tagged.DERTaggedType._valueLength">
<summary>
Length of the content.
</summary>

</member>
<member name="M:Sop.ASN1.Type.Tagged.DERTaggedType.#ctor(Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,System.Int64,System.Int64,System.Int64,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="identifier" type="Identifier">Pre-parsed identifier</param>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to next byte after identifier</param>
<param name="value_offset" type="int">Offset to content</param>
<param name="value_length" type="int">Content length</param>
</member>
<member name="M:Sop.ASN1.Type.Tagged.DERTaggedType.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.DERTaggedType.#ctor(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,System.Int64,System.Int64,System.Int64,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="identifier" type="Identifier">Pre-parsed identifier</param>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to next byte after identifier</param>
<param name="value_offset" type="int">Offset to content</param>
<param name="value_length" type="int">Content length</param>
</member>
<member name="T:Sop.ASN1.Type.Tagged.ExplicitlyTaggedType">
<summary>
Implements explicit tagging mode.
Explicit tagging wraps a type by prepending a tag. Underlying DER encoding
is not changed.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ExplicitlyTaggedType.#ctor(System.Int64,Sop.ASN1.Element,System.Int64)">
<summary>
Constructor.
</summary>
<param name="tag" type="int">Tag number</param>
<param name="element" type="Element">Wrapped element</param>
<param name="class" type="int">Type class</param>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ExplicitlyTaggedType.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ExplicitlyTaggedType.#ctor(Pchp.Core.Context,System.Int64,Sop.ASN1.Element,System.Int64)">
<summary>
Constructor.
</summary>
<param name="tag" type="int">Tag number</param>
<param name="element" type="Element">Wrapped element</param>
<param name="class" type="int">Type class</param>
</member>
<member name="T:Sop.ASN1.Type.Tagged.ExplicitTagging">
<summary>
Interface for classes providing explicit tagging.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Tagged.ImplicitlyTaggedType">
<summary>
Implements implicit tagging mode.
Implicit tagging changes the tag of the tagged type. This changes the
DER encoding of the type, and hence the abstract syntax must be known when
decoding the data.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ImplicitlyTaggedType.#ctor(System.Int64,Sop.ASN1.Element,System.Int64)">
<summary>
Constructor.
</summary>
<param name="tag" type="int">Tag number</param>
<param name="element" type="Element">Wrapped element</param>
<param name="class" type="int">Type class</param>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ImplicitlyTaggedType.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ImplicitlyTaggedType.#ctor(Pchp.Core.Context,System.Int64,Sop.ASN1.Element,System.Int64)">
<summary>
Constructor.
</summary>
<param name="tag" type="int">Tag number</param>
<param name="element" type="Element">Wrapped element</param>
<param name="class" type="int">Type class</param>
</member>
<member name="T:Sop.ASN1.Type.Tagged.ImplicitTagging">
<summary>
Interface for classes providing implicit tagging.
</summary>
</member>
<member name="T:Sop.ASN1.Type.Tagged.PrivateType">
<summary>
Intermediate class to store DER data of a private tagging type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.PrivateType.#ctor(Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,System.Int64,System.Int64,System.Int64,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="identifier" type="Identifier">Pre-parsed identifier</param>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to next byte after identifier</param>
<param name="value_offset" type="int">Offset to content</param>
<param name="value_length" type="int">Content length</param>
</member>
<member name="M:Sop.ASN1.Type.Tagged.PrivateType.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.PrivateType.#ctor(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,System.Int64,System.Int64,System.Int64,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="identifier" type="Identifier">Pre-parsed identifier</param>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to next byte after identifier</param>
<param name="value_offset" type="int">Offset to content</param>
<param name="value_length" type="int">Content length</param>
</member>
<member name="T:Sop.ASN1.Type.Tagged.TaggedTypeWrap">
<summary>
Base class to wrap inner element for tagging.
</summary>
</member>
<member name="F:Sop.ASN1.Type.Tagged.TaggedTypeWrap._element">
<summary>
Wrapped element.
</summary>

</member>
<member name="F:Sop.ASN1.Type.Tagged.TaggedTypeWrap._class">
<summary>
Type class.
</summary>

</member>
<member name="T:Sop.ASN1.Type.TaggedType">
<summary>
Base class for context-specific types.
</summary>
</member>
<member name="T:Sop.ASN1.Type.TimeType">
<summary>
Interface to mark types that encode a time as a string.
</summary>
</member>
<member name="T:Sop.ASN1.Type.UniversalClass`1`1">
<summary>
Trait for types of universal class.
</summary>
</member>
<member name="T:Sop.ASN1.Type.UnspecifiedType">
<summary>
Decorator class to wrap an element without already knowing the specific
underlying type.
Provides accessor methods to test the underlying type and return a type
hinted instance of the concrete element.
</summary>
</member>
<member name="F:Sop.ASN1.Type.UnspecifiedType._element">
<summary>
The wrapped element.
</summary>

</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.#ctor(Sop.ASN1.Element)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.#ctor(Pchp.Core.Context,Sop.ASN1.Element)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.ASN1.Util.BigInt">
<summary>
Class to wrap an integer of arbirtary length.
</summary>
</member>
<member name="F:Sop.ASN1.Util.BigInt._gmp">
<summary>
Number as a GMP object.
</summary>

</member>
<member name="F:Sop.ASN1.Util.BigInt._num">
<summary>
Number as a base 10 integer string.
</summary>

</member>
<member name="F:Sop.ASN1.Util.BigInt._intNum">
<summary>
Number as an integer type.
</summary>

</member>
<member name="M:Sop.ASN1.Util.BigInt.#ctor(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="num" type="\GMP|int|string">Integer number in base 10</param>
</member>
<member name="M:Sop.ASN1.Util.BigInt.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Util.BigInt.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="num" type="\GMP|int|string">Integer number in base 10</param>
</member>
<member name="T:Sop.ASN1.Util.Flags">
<summary>
Class to handle a bit string as a field of flags.
</summary>
</member>
<member name="F:Sop.ASN1.Util.Flags._flags">
<summary>
Flag octets.
</summary>

</member>
<member name="F:Sop.ASN1.Util.Flags._width">
<summary>
Number of flags.
</summary>

</member>
<member name="M:Sop.ASN1.Util.Flags.#ctor(Pchp.Core.PhpValue,System.Int64)">
<summary>
Constructor.
</summary>
<param name="flags" type="int|string">Flags</param>
<param name="width" type="int">The number of flags. If width is larger than
number of bits in $flags, zeroes are prepended
to flag field.</param>
</member>
<member name="M:Sop.ASN1.Util.Flags.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.ASN1.Util.Flags.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,System.Int64)">
<summary>
Constructor.
</summary>
<param name="flags" type="int|string">Flags</param>
<param name="width" type="int">The number of flags. If width is larger than
number of bits in $flags, zeroes are prepended
to flag field.</param>
</member>
<member name="T:Sop.CryptoEncoding.PEM">
<summary>
Implements PEM file encoding and decoding.
</summary>
</member>
<member name="F:Sop.CryptoEncoding.PEM._type">
<summary>
Content type.
</summary>

</member>
<member name="F:Sop.CryptoEncoding.PEM._data">
<summary>
Payload.
</summary>

</member>
<member name="M:Sop.CryptoEncoding.PEM.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="type" type="string">Content type</param>
<param name="data" type="string">Payload</param>
</member>
<member name="M:Sop.CryptoEncoding.PEM.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEM.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="type" type="string">Content type</param>
<param name="data" type="string">Payload</param>
</member>
<member name="T:Sop.CryptoEncoding.PEMBundle">
<summary>
Container for multiple PEM objects.
The order of PEMs shall be retained, eg. when read from a file.
</summary>
</member>
<member name="F:Sop.CryptoEncoding.PEMBundle._pems">
<summary>
Array of PEM objects.
</summary>

</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.#ctor(Sop.CryptoEncoding.PEM[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.#ctor(Pchp.Core.Context,Sop.CryptoEncoding.PEM[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifier">
<summary>
Implements AlgorithmIdentifier ASN.1 type.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifier._oid">
<summary>
Object identifier.
</summary>

</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierFactory">
<summary>
Factory class to parse AlgorithmIdentifier ASN.1 types to specific
algorithm identifier objects.
Additional providers may be added to the process to support algorithm
identifiers that are implemented in external libraries.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierFactory._additionalProviders">
<summary>
Additional algorithm identifier providers.
</summary>

</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierFactory.#ctor(Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierProvider[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierFactory.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierFactory.#ctor(Pchp.Core.Context,Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierProvider[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierProvider">
<summary>
Interface to provide lookup from OID to class name of specific algorithm
identifier type implementations.
This allows AlgorithmIdentifier types to be implemented in external
libraries and to use AlgorithmIdentifierFactory to resolve them.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier">
<summary>
Algorithm identifier for the elliptic curve public key.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier._namedCurve">
<summary>
OID of the named curve.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_PRIME192V1">
<summary>
prime192v1/secp192r1 curve OID.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_PRIME192V2">
<summary>
prime192v2 curve OID.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_PRIME192V3">
<summary>
prime192v3 curve OID.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_PRIME239V1">
<summary>
prime239v1 curve OID.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_PRIME239V2">
<summary>
prime239v2 curve OID.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_PRIME239V3">
<summary>
prime239v3 curve OID.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_PRIME256V1">
<summary>
prime256v1/secp256r1 curve OID.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP112R1">
<summary>
"SEC 2" recommended elliptic curve domain - secp112r1.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP112R2">
<summary>
"SEC 2" recommended elliptic curve domain - secp112r2.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP128R1">
<summary>
"SEC 2" recommended elliptic curve domain - secp128r1.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP128R2">
<summary>
"SEC 2" recommended elliptic curve domain - secp128r2.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP160K1">
<summary>
"SEC 2" recommended elliptic curve domain - secp160k1.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP160R1">
<summary>
"SEC 2" recommended elliptic curve domain - secp160r1.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP160R2">
<summary>
"SEC 2" recommended elliptic curve domain - secp160r2.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP192K1">
<summary>
"SEC 2" recommended elliptic curve domain - secp192k1.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP224K1">
<summary>
"SEC 2" recommended elliptic curve domain - secp224k1.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP224R1">
<summary>
"SEC 2" recommended elliptic curve domain - secp224r1.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP256K1">
<summary>
"SEC 2" recommended elliptic curve domain - secp256k1.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP384R1">
<summary>
National Institute of Standards and Technology (NIST) 384-bit elliptic
curve.
</summary>

</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.CURVE_SECP521R1">
<summary>
National Institute of Standards and Technology (NIST) 512-bit elliptic
curve.
</summary>

</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="named_curve" type="string">Curve identifier</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="named_curve" type="string">Curve identifier</param>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.RSAEncryptionAlgorithmIdentifier">
<summary>
Algorithm identifier for RSA encryption.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.RSAEncryptionAlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.RSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.RSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES128CBCAlgorithmIdentifier">
<summary>
Algorithm identifier for AES with 128-bit key in CBC mode.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES128CBCAlgorithmIdentifier.#ctor(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES128CBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES128CBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES192CBCAlgorithmIdentifier">
<summary>
Algorithm identifier for AES with 192-bit key in CBC mode.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES192CBCAlgorithmIdentifier.#ctor(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES192CBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES192CBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES256CBCAlgorithmIdentifier">
<summary>
Algorithm identifier for AES with 256-bit key in CBC mode.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES256CBCAlgorithmIdentifier.#ctor(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES256CBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES256CBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AESCBCAlgorithmIdentifier">
<summary>
Base class for AES-CBC algorithm identifiers.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.BlockCipherAlgorithmIdentifier">
<summary>
Base class for block cipher algorithm identifiers.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.CipherAlgorithmIdentifier">
<summary>
Base class for cipher algorithm identifiers.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.CipherAlgorithmIdentifier._initializationVector">
<summary>
Initialization vector.
</summary>

</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier">
<summary>
Algorithm identifier for DES cipher in CBC mode.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier.#ctor(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier">
<summary>
Algorithm identifier for Triple-DES cipher in CBC mode.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier.#ctor(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier">
<summary>
Algorithm identifier for RC2 cipher in CBC mode.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier._effectiveKeyBits">
<summary>
Effective key bits.
</summary>

</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier.#ctor(System.Int64,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="key_bits" type="int">Number of effective key bits</param>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier.#ctor(Pchp.Core.Context,System.Int64,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="key_bits" type="int">Number of effective key bits</param>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType">
<summary>
Base interface for algorithm identifiers.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Feature.AsymmetricCryptoAlgorithmIdentifier">
<summary>
Algorithm identifier for asymmetric cryptography algorithms.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Feature.EncryptionAlgorithmIdentifier">
<summary>
Algorithm identifier for encryption algorithms.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Feature.HashAlgorithmIdentifier">
<summary>
Algorithm identifier for hash functions.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Feature.PRFAlgorithmIdentifier">
<summary>
Algorithm identifier for pseudorandom functions.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Feature.SignatureAlgorithmIdentifier">
<summary>
Algorithm identifier for signature algorithms.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.GenericAlgorithmIdentifier">
<summary>
Generic algorithm identifier to hold parameters as ASN.1 objects.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.GenericAlgorithmIdentifier._params">
<summary>
Parameters.
</summary>

</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.GenericAlgorithmIdentifier.#ctor(Pchp.Core.PhpString,Sop.ASN1.Type.UnspecifiedType)">
<summary>
Constructor.
</summary>
<param name="oid" type="string">Algorithm OID</param>
<param name="params" type="null|UnspecifiedType">Parameters</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.GenericAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.GenericAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Sop.ASN1.Type.UnspecifiedType)">
<summary>
Constructor.
</summary>
<param name="oid" type="string">Algorithm OID</param>
<param name="params" type="null|UnspecifiedType">Parameters</param>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA1AlgorithmIdentifier">
<summary>
HMAC-SHA-1 algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA1AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA1AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA1AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA224AlgorithmIdentifier">
<summary>
HMAC with SHA-224 algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA224AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA224AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA224AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA256AlgorithmIdentifier">
<summary>
HMAC with SHA-256 algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA256AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA256AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA256AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA384AlgorithmIdentifier">
<summary>
HMAC with SHA-384 algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA384AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA384AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA384AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA512AlgorithmIdentifier">
<summary>
HMAC with SHA-512 algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA512AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA512AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA512AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.MD5AlgorithmIdentifier">
<summary>
MD5 algorithm identifier.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Hash.MD5AlgorithmIdentifier._params">
<summary>
Parameters.
</summary>

</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.MD5AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.MD5AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.MD5AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.RFC4231HMACAlgorithmIdentifier">
<summary>
Base class for HMAC algorithm identifiers specified in RFC 4231.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Hash.RFC4231HMACAlgorithmIdentifier._params">
<summary>
Parameters stored for re-encoding.
</summary>

</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA1AlgorithmIdentifier">
<summary>
SHA-1 algorithm identifier.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA1AlgorithmIdentifier._params">
<summary>
Parameters.
</summary>

</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA1AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA1AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA1AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA224AlgorithmIdentifier">
<summary>
SHA-224 algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA224AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA224AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA224AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA256AlgorithmIdentifier">
<summary>
SHA-256 algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA256AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA256AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA256AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA2AlgorithmIdentifier">
<summary>
Base class for SHA2 algorithm identifiers.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA2AlgorithmIdentifier._params">
<summary>
Parameters.
</summary>

</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA384AlgorithmIdentifier">
<summary>
SHA-384 algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA384AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA384AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA384AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA512AlgorithmIdentifier">
<summary>
SHA-512 algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA512AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA512AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA512AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA1AlgorithmIdentifier">
<summary>
ECDSA with SHA-1 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA1AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA1AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA1AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA224AlgorithmIdentifier">
<summary>
ECDSA with SHA-224 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA224AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA224AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA224AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA256AlgorithmIdentifier">
<summary>
ECDSA with SHA-256 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA256AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA256AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA256AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA384AlgorithmIdentifier">
<summary>
ECDSA with SHA-384 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA384AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA384AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA384AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA512AlgorithmIdentifier">
<summary>
ECDSA with SHA-512 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA512AlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA512AlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA512AlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECSignatureAlgorithmIdentifier">
<summary>
Base class for ECDSA signature algorithm identifiers.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD2WithRSAEncryptionAlgorithmIdentifier">
<summary>
RSA with MD2 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD2WithRSAEncryptionAlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD2WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD2WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD4WithRSAEncryptionAlgorithmIdentifier">
<summary>
RSA with MD4 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD4WithRSAEncryptionAlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD4WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD4WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD5WithRSAEncryptionAlgorithmIdentifier">
<summary>
RSA with MD5 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD5WithRSAEncryptionAlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD5WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD5WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.RFC3279RSASignatureAlgorithmIdentifier">
<summary>
Base class for RSA signature algorithms specified in RFC 3279.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.RFC4055RSASignatureAlgorithmIdentifier">
<summary>
Base class for RSA signature algorithms specified in RFC 4055.
</summary>
</member>
<member name="F:Sop.CryptoTypes.AlgorithmIdentifier.Signature.RFC4055RSASignatureAlgorithmIdentifier._params">
<summary>
Parameters.
</summary>

</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.RSASignatureAlgorithmIdentifier">
<summary>
Base class for signature algorithms employing RSASSA.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA1WithRSAEncryptionAlgorithmIdentifier">
<summary>
RSA with SHA-1 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA1WithRSAEncryptionAlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA1WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA1WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA224WithRSAEncryptionAlgorithmIdentifier">
<summary>
RSA with SHA-224 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA224WithRSAEncryptionAlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA224WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA224WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA256WithRSAEncryptionAlgorithmIdentifier">
<summary>
RSA with SHA-256 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA256WithRSAEncryptionAlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA256WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA256WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA384WithRSAEncryptionAlgorithmIdentifier">
<summary>
RSA with SHA-384 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA384WithRSAEncryptionAlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA384WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA384WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA512WithRSAEncryptionAlgorithmIdentifier">
<summary>
RSA with SHA-512 signature algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA512WithRSAEncryptionAlgorithmIdentifier.#ctor">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA512WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA512WithRSAEncryptionAlgorithmIdentifier.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SignatureAlgorithmIdentifierFactory">
<summary>
Factory class for constructing signature algorithm identifiers.
</summary>
</member>
<member name="T:Sop.CryptoTypes.AlgorithmIdentifier.SpecificAlgorithmIdentifier">
<summary>
Base class for algorithm identifiers implementing specific functionality and
parameter handling.
</summary>
</member>
<member name="T:Sop.CryptoTypes.Asymmetric.EC.ECConversion">
<summary>
Implements data type conversions from SEC 1: Elliptic Curve Cryptography.
</summary>
</member>
<member name="T:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey">
<summary>
Implements elliptic curve private key type as specified by RFC 5915.
</summary>
</member>
<member name="F:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey._privateKey">
<summary>
Private key.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey._namedCurve">
<summary>
Named curve OID.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey._publicKey">
<summary>
ECPoint value.
</summary>

</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="private_key" type="string">Private key</param>
<param name="named_curve" type="null|string">OID of the named curve</param>
<param name="public_key" type="null|string">ECPoint value</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="private_key" type="string">Private key</param>
<param name="named_curve" type="null|string">OID of the named curve</param>
<param name="public_key" type="null|string">ECPoint value</param>
</member>
<member name="T:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey">
<summary>
Implements elliptic curve public key type as specified by RFC 5480.
</summary>
</member>
<member name="F:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey._ecPoint">
<summary>
Elliptic curve public key.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey._namedCurve">
<summary>
Named curve OID.
Named curve is not a part of ECPublicKey, but it's stored as a hint
for the purpose of PublicKeyInfo creation.
</summary>

</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="ec_point" type="string">ECPoint</param>
<param name="named_curve" type="null|string">Named curve OID</param>
<exception cref="InvalidArgumentException">If ECPoint is invalid</exception>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="ec_point" type="string">ECPoint</param>
<param name="named_curve" type="null|string">Named curve OID</param>
<exception cref="InvalidArgumentException">If ECPoint is invalid</exception>
</member>
<member name="T:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey">
<summary>
Implements PKCS #8 PrivateKeyInfo / OneAsymmetricKey ASN.1 type.
</summary>
</member>
<member name="F:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey._version">
<summary>
Version number.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey._algo">
<summary>
Algorithm identifier.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey._privateKeyData">
<summary>
Private key data.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.VERSION_1">
<summary>
Version number for PrivateKeyInfo.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.VERSION_2">
<summary>
Version number for OneAsymmetricKey.
</summary>

</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.#ctor(Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="AlgorithmIdentifierType">Algorithm</param>
<param name="key" type="string">Private key data</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.#ctor(Pchp.Core.Context,Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="AlgorithmIdentifierType">Algorithm</param>
<param name="key" type="string">Private key data</param>
</member>
<member name="T:Sop.CryptoTypes.Asymmetric.PrivateKey">
<summary>
Base class for private keys.
</summary>
</member>
<member name="T:Sop.CryptoTypes.Asymmetric.PrivateKeyInfo">
<summary>
PrivateKeyInfo was first introduced in RFC 5208, but later
refined as OneAsymmetricKey in RFC 5958 with backwards compatibility.
Thus `PrivateKeyInfo ::= OneAsymmetricKey`
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PrivateKeyInfo.#ctor(Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="AlgorithmIdentifierType">Algorithm</param>
<param name="key" type="string">Private key data</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PrivateKeyInfo.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PrivateKeyInfo.#ctor(Pchp.Core.Context,Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="AlgorithmIdentifierType">Algorithm</param>
<param name="key" type="string">Private key data</param>
</member>
<member name="T:Sop.CryptoTypes.Asymmetric.PublicKey">
<summary>
Base class for public keys.
</summary>
</member>
<member name="T:Sop.CryptoTypes.Asymmetric.PublicKeyInfo">
<summary>
Implements X.509 SubjectPublicKeyInfo ASN.1 type.
</summary>
</member>
<member name="F:Sop.CryptoTypes.Asymmetric.PublicKeyInfo._algo">
<summary>
Algorithm identifier.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.PublicKeyInfo._publicKeyData">
<summary>
Public key data.
</summary>

</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.#ctor(Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="AlgorithmIdentifierType">Algorithm</param>
<param name="key" type="string">Public key data</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.#ctor(Pchp.Core.Context,Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="AlgorithmIdentifierType">Algorithm</param>
<param name="key" type="string">Public key data</param>
</member>
<member name="T:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey">
<summary>
Implements PKCS #1 RSAPrivateKey ASN.1 type.
</summary>
</member>
<member name="F:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey._modulus">
<summary>
Modulus as a base 10 integer.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey._publicExponent">
<summary>
Public exponent as a base 10 integer.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey._privateExponent">
<summary>
Private exponent as a base 10 integer.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey._prime1">
<summary>
First prime factor as a base 10 integer.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey._prime2">
<summary>
Second prime factor as a base 10 integer.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey._exponent1">
<summary>
First factor exponent as a base 10 integer.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey._exponent2">
<summary>
Second factor exponent as a base 10 integer.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey._coefficient">
<summary>
CRT coefficient of the second factor as a base 10 integer.
</summary>

</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="n" type="int|string">Modulus</param>
<param name="e" type="int|string">Public exponent</param>
<param name="d" type="int|string">Private exponent</param>
<param name="p" type="int|string">First prime factor</param>
<param name="q" type="int|string">Second prime factor</param>
<param name="dp" type="int|string">First factor exponent</param>
<param name="dq" type="int|string">Second factor exponent</param>
<param name="qi" type="int|string">CRT coefficient of the second factor</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="n" type="int|string">Modulus</param>
<param name="e" type="int|string">Public exponent</param>
<param name="d" type="int|string">Private exponent</param>
<param name="p" type="int|string">First prime factor</param>
<param name="q" type="int|string">Second prime factor</param>
<param name="dp" type="int|string">First factor exponent</param>
<param name="dq" type="int|string">Second factor exponent</param>
<param name="qi" type="int|string">CRT coefficient of the second factor</param>
</member>
<member name="T:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey">
<summary>
Implements PKCS #1 RSAPublicKey ASN.1 type.
</summary>
</member>
<member name="F:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey._modulus">
<summary>
Modulus as a base 10 integer.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey._publicExponent">
<summary>
Public exponent as a base 10 integer.
</summary>

</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="n" type="int|string">Modulus</param>
<param name="e" type="int|string">Public exponent</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="n" type="int|string">Modulus</param>
<param name="e" type="int|string">Public exponent</param>
</member>
<member name="T:Sop.CryptoTypes.Signature.ECSignature">
<summary>
Implements ECDSA signature value.
ECDSA signature is represented as a `ECDSA-Sig-Value` ASN.1 type.
</summary>
</member>
<member name="F:Sop.CryptoTypes.Signature.ECSignature._r">
<summary>
r-value as a base 10 integer.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Signature.ECSignature._s">
<summary>
s-value as a base 10 integer.
</summary>

</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.#ctor(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="r" type="int|string">Signature's `r` value</param>
<param name="s" type="int|string">Signature's `s` value</param>
</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="r" type="int|string">Signature's `r` value</param>
<param name="s" type="int|string">Signature's `s` value</param>
</member>
<member name="T:Sop.CryptoTypes.Signature.GenericSignature">
<summary>
Generic signature value container.
</summary>
</member>
<member name="F:Sop.CryptoTypes.Signature.GenericSignature._signature">
<summary>
Signature value.
</summary>

</member>
<member name="F:Sop.CryptoTypes.Signature.GenericSignature._signatureAlgorithm">
<summary>
Signature algorithm.
</summary>

</member>
<member name="M:Sop.CryptoTypes.Signature.GenericSignature.#ctor(Sop.ASN1.Type.Primitive.BitString,Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType)">
<summary>
Constructor.
</summary>
<param name="signature" type="BitString">Signature value</param>
<param name="algo" type="AlgorithmIdentifierType">Algorithm identifier</param>
</member>
<member name="M:Sop.CryptoTypes.Signature.GenericSignature.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.GenericSignature.#ctor(Pchp.Core.Context,Sop.ASN1.Type.Primitive.BitString,Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType)">
<summary>
Constructor.
</summary>
<param name="signature" type="BitString">Signature value</param>
<param name="algo" type="AlgorithmIdentifierType">Algorithm identifier</param>
</member>
<member name="T:Sop.CryptoTypes.Signature.RSASignature">
<summary>
Implements RSA signature value.
</summary>
</member>
<member name="F:Sop.CryptoTypes.Signature.RSASignature._signature">
<summary>
Signature value *S*.
</summary>

</member>
<member name="M:Sop.CryptoTypes.Signature.RSASignature.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.RSASignature.#ctor(Pchp.Core.Context)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.CryptoTypes.Signature.Signature">
<summary>
Base class for signature values.
</summary>
</member>
<member name="T:Sop.GCM.AESGCM">
<summary>
Implements AES-GCM encryption.
</summary>
</member>
<member name="T:Sop.GCM.Cipher.AES.AES128Cipher">
<summary>
Implements AES cipher with 128-bit key size.
</summary>
</member>
<member name="T:Sop.GCM.Cipher.AES.AES192Cipher">
<summary>
Implements AES cipher with 192-bit key size.
</summary>
</member>
<member name="T:Sop.GCM.Cipher.AES.AES256Cipher">
<summary>
Implements AES cipher with 256-bit key size.
</summary>
</member>
<member name="T:Sop.GCM.Cipher.AES.AESCipher">
<summary>
Base class for AES ciphers for the GCM.
</summary>
</member>
<member name="T:Sop.GCM.Cipher.Cipher">
<summary>
Interface for ciphers usable for GCM.
</summary>
</member>
<member name="T:Sop.GCM.Exception.AuthenticationException">
<summary>
Exception thrown when message authentication fails.
</summary>
</member>
<member name="T:Sop.GCM.GCM">
<summary>
Implements encryption and decryption in Galois/Counter Mode.
</summary>
</member>
<member name="F:Sop.GCM.GCM._cipher">
<summary>
Cipher.
</summary>

</member>
<member name="F:Sop.GCM.GCM._tagLength">
<summary>
Authentication tag length in bytes.
</summary>

</member>
<member name="F:Sop.GCM.GCM.ZB_64">
<summary>
Block of 64 zero bits.
</summary>

</member>
<member name="M:Sop.GCM.GCM.#ctor(Sop.GCM.Cipher.Cipher,System.Int64)">
<summary>
Constructor.
</summary>
<param name="cipher" type="Cipher">Cipher implementation</param>
<param name="tag_length" type="int">Authentication tag length in bytes</param>
<exception cref="DomainException">If tag length is not supported</exception>
</member>
<member name="M:Sop.GCM.GCM.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.GCM.GCM.#ctor(Pchp.Core.Context,Sop.GCM.Cipher.Cipher,System.Int64)">
<summary>
Constructor.
</summary>
<param name="cipher" type="Cipher">Cipher implementation</param>
<param name="tag_length" type="int">Authentication tag length in bytes</param>
<exception cref="DomainException">If tag length is not supported</exception>
</member>
<member name="T:Sop.GCM.GHASH">
<summary>
Implements GHASH function.
This algorithm is specified in NIST SP-300-38D section 6.4.
</summary>
</member>
<member name="F:Sop.GCM.GHASH._subkey">
<summary>
Hash subkey.
</summary>

</member>
<member name="M:Sop.GCM.GHASH.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="subkey" type="string">Hash subkey</param>
</member>
<member name="M:Sop.GCM.GHASH.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.GCM.GHASH.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="subkey" type="string">Hash subkey</param>
</member>
<member name="T:Sop.JWX.JWA.JWA">
<summary>
Container for the algorithm name contants.
</summary>
</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_HS256">
<summary>
HMAC using SHA-256.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_HS384">
<summary>
HMAC using SHA-384.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_HS512">
<summary>
HMAC using SHA-512.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_RS256">
<summary>
RSASSA-PKCS1-v1_5 using SHA-256.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_RS384">
<summary>
RSASSA-PKCS1-v1_5 using SHA-384.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_RS512">
<summary>
RSASSA-PKCS1-v1_5 using SHA-512.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_ES256">
<summary>
ECDSA using P-256 and SHA-256.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_ES384">
<summary>
ECDSA using P-384 and SHA-384.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_ES512">
<summary>
ECDSA using P-521 and SHA-512.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_PS256">
<summary>
RSASSA-PSS using SHA-256 and MGF1 with SHA-256.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_PS384">
<summary>
RSASSA-PSS using SHA-384 and MGF1 with SHA-384.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_PS512">
<summary>
RSASSA-PSS using SHA-512 and MGF1 with SHA-512.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_NONE">
<summary>
No digital signature or MAC performed.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_RSA1_5">
<summary>
RSAES-PKCS1-v1_5.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_RSA_OAEP">
<summary>
RSAES OAEP using default parameters.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_RSA_OAEP256">
<summary>
RSAES OAEP using SHA-256 and MGF1 with SHA-256.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A128KW">
<summary>
AES Key Wrap using 128-bit key.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A192KW">
<summary>
AES Key Wrap using 192-bit key.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A256KW">
<summary>
AES Key Wrap using 256-bit key.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_DIR">
<summary>
Direct use of a shared symmetric key.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_ECDH_ES">
<summary>
ECDH-ES using Concat KDF.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_ECDH_ES_A128KW">
<summary>
ECDH-ES using Concat KDF and "A128KW" wrapping.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_ECDH_ES_A192KW">
<summary>
ECDH-ES using Concat KDF and "A192KW" wrapping.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_ECDH_ES_A256KW">
<summary>
ECDH-ES using Concat KDF and "A256KW" wrapping.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A128GCMKW">
<summary>
Key wrapping with AES GCM using 128-bit key.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A192GCMKW">
<summary>
Key wrapping with AES GCM using 192-bit key.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A256GCMKW">
<summary>
Key wrapping with AES GCM using 256-bit key.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_PBES2_HS256_A128KW">
<summary>
PBES2 with HMAC SHA-256 and "A128KW" wrapping.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_PBES2_HS384_A192KW">
<summary>
PBES2 with HMAC SHA-384 and "A192KW" wrapping.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_PBES2_HS512_A256KW">
<summary>
PBES2 with HMAC SHA-512 and "A256KW" wrapping.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A128CBC_HS256">
<summary>
AES_128_CBC_HMAC_SHA_256 authenticated encryption algorithm.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A192CBC_HS384">
<summary>
AES_192_CBC_HMAC_SHA_384 authenticated encryption algorithm.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A256CBC_HS512">
<summary>
AES_256_CBC_HMAC_SHA_512 authenticated encryption algorithm.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A128GCM">
<summary>
AES GCM using 128-bit key.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A192GCM">
<summary>
AES GCM using 192-bit key.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_A256GCM">
<summary>
AES GCM using 256-bit key.
</summary>

</member>
<member name="F:Sop.JWX.JWA.JWA.ALGO_DEFLATE">
<summary>
DEFLATE compression.
</summary>

</member>
<member name="T:Sop.JWX.JWE.CompressionAlgorithm">
<summary>
Interface for algorithms that may be used to compress and decompress data.
</summary>
</member>
<member name="T:Sop.JWX.JWE.CompressionAlgorithm.CompressionFactory">
<summary>
Factory class to construct compression algorithm instances.
</summary>
</member>
<member name="T:Sop.JWX.JWE.CompressionAlgorithm.DeflateAlgorithm">
<summary>
Implements DEFLATE compression algorithm.
</summary>
</member>
<member name="F:Sop.JWX.JWE.CompressionAlgorithm.DeflateAlgorithm._compressionLevel">
<summary>
Compression level.
</summary>

</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.DeflateAlgorithm.#ctor(System.Int64)">
<summary>
Constructor.
</summary>
<param name="level" type="int">Compression level 0..9</param>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.DeflateAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.DeflateAlgorithm.#ctor(Pchp.Core.Context,System.Int64)">
<summary>
Constructor.
</summary>
<param name="level" type="int">Compression level 0..9</param>
</member>
<member name="T:Sop.JWX.JWE.ContentEncryptionAlgorithm">
<summary>
Interface for algorithms that may be used to encrypt and decrypt JWE payload.
</summary>
</member>
<member name="T:Sop.JWX.JWE.EncryptionAlgorithm.A128CBCHS256Algorithm">
<summary>
Implements AES with 128-bit key in CBC mode with HMAC SHA-256 authentication.
</summary>
</member>
<member name="T:Sop.JWX.JWE.EncryptionAlgorithm.A128GCMAlgorithm">
<summary>
Implements AES-GCM with 128-bit key.
</summary>
</member>
<member name="T:Sop.JWX.JWE.EncryptionAlgorithm.A192CBCHS384Algorithm">
<summary>
Implements AES with 192-bit key in CBC mode with HMAC SHA-384 authentication.
</summary>
</member>
<member name="T:Sop.JWX.JWE.EncryptionAlgorithm.A192GCMAlgorithm">
<summary>
Implements AES-GCM with 192-bit key.
</summary>
</member>
<member name="T:Sop.JWX.JWE.EncryptionAlgorithm.A256CBCHS512Algorithm">
<summary>
Implements AES with 256-bit key in CBC mode with HMAC SHA-512 authentication.
</summary>
</member>
<member name="T:Sop.JWX.JWE.EncryptionAlgorithm.A256GCMAlgorithm">
<summary>
Implements AES-GCM with 256-bit key.
</summary>
</member>
<member name="T:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm">
<summary>
Base class for algorithms implementing AES in CBC mode with HMAC-SHA.
</summary>
</member>
<member name="T:Sop.JWX.JWE.EncryptionAlgorithm.AESGCMAlgorithm">
<summary>
Base class for algorithms implementing AES in Galois/Counter mode.
</summary>
</member>
<member name="T:Sop.JWX.JWE.EncryptionAlgorithm.EncryptionAlgorithmFactory">
<summary>
Factory class to construct content encryption algorithm instances.
</summary>
</member>
<member name="T:Sop.JWX.JWE.Exception.AuthenticationException">
<summary>
Exception thrown when encrypted message authentication validation fails.
</summary>
</member>
<member name="T:Sop.JWX.JWE.JWE">
<summary>
Class to represent JWE structure.
</summary>
</member>
<member name="F:Sop.JWX.JWE.JWE._protectedHeader">
<summary>
Protected header.
</summary>

</member>
<member name="F:Sop.JWX.JWE.JWE._encryptedKey">
<summary>
Encrypted key.
</summary>

</member>
<member name="F:Sop.JWX.JWE.JWE._iv">
<summary>
Initialization vector.
</summary>

</member>
<member name="F:Sop.JWX.JWE.JWE._aad">
<summary>
Additional authenticated data.
</summary>

</member>
<member name="F:Sop.JWX.JWE.JWE._ciphertext">
<summary>
Ciphertext.
</summary>

</member>
<member name="F:Sop.JWX.JWE.JWE._authenticationTag">
<summary>
Authentication tag.
</summary>

</member>
<member name="M:Sop.JWX.JWE.JWE.#ctor(Sop.JWX.JWT.Header.Header,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="protected_header" type="Header">JWE Protected Header</param>
<param name="encrypted_key" type="string">Encrypted key</param>
<param name="iv" type="string">Initialization vector</param>
<param name="ciphertext" type="string">Ciphertext</param>
<param name="auth_tag" type="string">Authentication tag</param>
<param name="aad" type="null|string">Additional authenticated data</param>
</member>
<member name="M:Sop.JWX.JWE.JWE.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.#ctor(Pchp.Core.Context,Sop.JWX.JWT.Header.Header,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="protected_header" type="Header">JWE Protected Header</param>
<param name="encrypted_key" type="string">Encrypted key</param>
<param name="iv" type="string">Initialization vector</param>
<param name="ciphertext" type="string">Ciphertext</param>
<param name="auth_tag" type="string">Authentication tag</param>
<param name="aad" type="null|string">Additional authenticated data</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.A128GCMKWAlgorithm">
<summary>
Implements key encryption with AES GCM using 128-bit key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128GCMKWAlgorithm.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
<param name="iv" type="string">Initialization vector</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128GCMKWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128GCMKWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
<param name="iv" type="string">Initialization vector</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.A128KWAlgorithm">
<summary>
Implements AES key wrap with 128-bit key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128KWAlgorithm.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.A192GCMKWAlgorithm">
<summary>
Implements key encryption with AES GCM using 192-bit key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192GCMKWAlgorithm.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
<param name="iv" type="string">Initialization vector</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192GCMKWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192GCMKWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
<param name="iv" type="string">Initialization vector</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.A192KWAlgorithm">
<summary>
Implements AES key wrap with 192-bit key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192KWAlgorithm.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.A256GCMKWAlgorithm">
<summary>
Implements key encryption with AES GCM using 256-bit key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256GCMKWAlgorithm.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
<param name="iv" type="string">Initialization vector</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256GCMKWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256GCMKWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
<param name="iv" type="string">Initialization vector</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.A256KWAlgorithm">
<summary>
Implements AES key wrap with 256-bit key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256KWAlgorithm.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm">
<summary>
Base class for AES GCM key encryption algorithms.
</summary>
</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm._kek">
<summary>
Key encryption key.
</summary>

</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm._iv">
<summary>
Initialization vector.
</summary>

</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm.IV_SIZE">
<summary>
Required IV size in bytes.
</summary>

</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm.AUTH_TAG_SIZE">
<summary>
Authentication tag size in bytes.
</summary>

</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm">
<summary>
Base class for algorithms implementing AES key wrap.
</summary>
</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm._kek">
<summary>
Key encryption key.
</summary>

</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm._kw">
<summary>
Key wrapping algorithm.
Lazily initialized.
</summary>

</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm">
<summary>
Algorithm to carry CEK in plaintext.
</summary>
</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm._cek">
<summary>
Content encryption key.
</summary>

</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="cek" type="string">Content encryption key</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="cek" type="string">Content encryption key</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.Feature.RandomCEK`1`1">
<summary>
Trait for key algorithms employing random CEK generation.
</summary>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.KeyAlgorithmFactory">
<summary>
Factory class to construct key management algorithm instances.
</summary>
</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.KeyAlgorithmFactory._header">
<summary>
Header.
</summary>

</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.KeyAlgorithmFactory.#ctor(Sop.JWX.JWT.Header.Header)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.KeyAlgorithmFactory.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.KeyAlgorithmFactory.#ctor(Pchp.Core.Context,Sop.JWX.JWT.Header.Header)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm">
<summary>
Base class for algorithms implementing PBES2 key encryption.
</summary>
</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm._password">
<summary>
Password.
</summary>

</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm._saltInput">
<summary>
Salt input.
</summary>

</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm._count">
<summary>
Iteration count.
</summary>

</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm._derivedKey">
<summary>
Derived key.
</summary>

</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.PBES2HS256A128KWAlgorithm">
<summary>
Implements PBES2 with HMAC SHA-256 and "A128KW" wrapping.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS256A128KWAlgorithm.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpString,System.Int64)">
<summary>
Constructor.
</summary>
<param name="password" type="string">Password</param>
<param name="salt_input" type="string">Salt input</param>
<param name="count" type="int">Iteration count</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS256A128KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS256A128KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString,System.Int64)">
<summary>
Constructor.
</summary>
<param name="password" type="string">Password</param>
<param name="salt_input" type="string">Salt input</param>
<param name="count" type="int">Iteration count</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.PBES2HS384A192KWAlgorithm">
<summary>
Implements PBES2 with HMAC SHA-384 and "A192KW" wrapping.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS384A192KWAlgorithm.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpString,System.Int64)">
<summary>
Constructor.
</summary>
<param name="password" type="string">Password</param>
<param name="salt_input" type="string">Salt input</param>
<param name="count" type="int">Iteration count</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS384A192KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS384A192KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString,System.Int64)">
<summary>
Constructor.
</summary>
<param name="password" type="string">Password</param>
<param name="salt_input" type="string">Salt input</param>
<param name="count" type="int">Iteration count</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.PBES2HS512A256KWAlgorithm">
<summary>
Implements PBES2 with HMAC SHA-512 and "A256KW" wrapping.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS512A256KWAlgorithm.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpString,System.Int64)">
<summary>
Constructor.
</summary>
<param name="password" type="string">Password</param>
<param name="salt_input" type="string">Salt input</param>
<param name="count" type="int">Iteration count</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS512A256KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS512A256KWAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString,System.Int64)">
<summary>
Constructor.
</summary>
<param name="password" type="string">Password</param>
<param name="salt_input" type="string">Salt input</param>
<param name="count" type="int">Iteration count</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm">
<summary>
Base class for algorithms implementing RSA based key encryption.
</summary>
</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm._publicKey">
<summary>
Public key.
</summary>

</member>
<member name="F:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm._privateKey">
<summary>
Private key.
</summary>

</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.RSAESOAEPAlgorithm">
<summary>
Implements key encryption with RSAES OAEP.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESOAEPAlgorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESOAEPAlgorithm.#ctor(Pchp.Core.Context,Sop.JWX.JWK.RSA.RSAPublicKeyJWK,Sop.JWX.JWK.RSA.RSAPrivateKeyJWK)">
<summary>
Constructor.
Use `fromPublicKey` or `fromPrivateKey` instead!
</summary>
<param name="pub_key" type="RSAPublicKeyJWK">RSA public key</param>
<param name="priv_key" type="RSAPrivateKeyJWK">Optional RSA private key</param>
</member>
<member name="T:Sop.JWX.JWE.KeyAlgorithm.RSAESPKCS1Algorithm">
<summary>
Implements key encryption with RSAES-PKCS1-v1_5.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESPKCS1Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESPKCS1Algorithm.#ctor(Pchp.Core.Context,Sop.JWX.JWK.RSA.RSAPublicKeyJWK,Sop.JWX.JWK.RSA.RSAPrivateKeyJWK)">
<summary>
Constructor.
Use `fromPublicKey` or `fromPrivateKey` instead!
</summary>
<param name="pub_key" type="RSAPublicKeyJWK">RSA public key</param>
<param name="priv_key" type="RSAPrivateKeyJWK">Optional RSA private key</param>
</member>
<member name="T:Sop.JWX.JWE.KeyManagementAlgorithm">
<summary>
Base class for algorithms used for CEK management for the content encryption
algorithms.
</summary>
</member>
<member name="F:Sop.JWX.JWE.KeyManagementAlgorithm._keyID">
<summary>
ID of the key used by the algorithm.
If set, KeyID parameter shall be automatically inserted into JWE's
header.
</summary>

</member>
<member name="T:Sop.JWX.JWK.Asymmetric.PrivateKeyJWK">
<summary>
Base class for JWK private keys of an asymmetric key pairs.
</summary>
</member>
<member name="T:Sop.JWX.JWK.Asymmetric.PublicKeyJWK">
<summary>
Base class for JWK public keys of an asymmetric key pairs.
</summary>
</member>
<member name="T:Sop.JWX.JWK.EC.ECPrivateKeyJWK">
<summary>
Class representing elliptic curve private key as a JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPrivateKeyJWK.#ctor(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPrivateKeyJWK.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPrivateKeyJWK.#ctor(Pchp.Core.Context,Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="T:Sop.JWX.JWK.EC.ECPublicKeyJWK">
<summary>
Class representing elliptic curve public key as a JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPublicKeyJWK.#ctor(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPublicKeyJWK.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPublicKeyJWK.#ctor(Pchp.Core.Context,Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="T:Sop.JWX.JWK.JWK">
<summary>
Class to represent JWK structure.
</summary>
</member>
<member name="F:Sop.JWX.JWK.JWK._parameters">
<summary>
Parameters.
</summary>

</member>
<member name="M:Sop.JWX.JWK.JWK.#ctor(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.#ctor(Pchp.Core.Context,Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWK.JWKSet">
<summary>
Represents a JWK set structure.
</summary>
</member>
<member name="F:Sop.JWX.JWK.JWKSet._jwks">
<summary>
JWK objects.
</summary>

</member>
<member name="F:Sop.JWX.JWK.JWKSet._additional">
<summary>
Additional members.
</summary>

</member>
<member name="F:Sop.JWX.JWK.JWKSet._mappings">
<summary>
JWK mappings.
</summary>

</member>
<member name="M:Sop.JWX.JWK.JWKSet.#ctor(Sop.JWX.JWK.JWK[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.#ctor(Pchp.Core.Context,Sop.JWX.JWK.JWK[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWK.Parameter.AlgorithmParameter">
<summary>
Implements 'Algorithm' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.AlgorithmParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="string">Algorithm name</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.AlgorithmParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.AlgorithmParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="string">Algorithm name</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.CoordinateParameter">
<summary>
Base class for EC coordinate parameters.
</summary>
</member>
<member name="T:Sop.JWX.JWK.Parameter.CurveParameter">
<summary>
Implements 'Curve' parameter.
</summary>
</member>
<member name="F:Sop.JWX.JWK.Parameter.CurveParameter.CURVE_P256">
<summary>
P-256 Curve.
</summary>

</member>
<member name="F:Sop.JWX.JWK.Parameter.CurveParameter.CURVE_P384">
<summary>
P-384 Curve.
</summary>

</member>
<member name="F:Sop.JWX.JWK.Parameter.CurveParameter.CURVE_P521">
<summary>
P-521 Curve.
</summary>

</member>
<member name="M:Sop.JWX.JWK.Parameter.CurveParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="curve" type="string">Curve name</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.CurveParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.CurveParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="curve" type="string">Curve name</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.ECCPrivateKeyParameter">
<summary>
Implements 'ECC Private Key' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ECCPrivateKeyParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Private key in base64url encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ECCPrivateKeyParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ECCPrivateKeyParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Private key in base64url encoding</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.ExponentParameter">
<summary>
Implements 'Exponent' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ExponentParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="e" type="string">Exponent in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ExponentParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ExponentParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="e" type="string">Exponent in base64urlUInt encoding</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.FirstCRTCoefficientParameter">
<summary>
Implements 'First CRT Coefficient' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstCRTCoefficientParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="qi" type="string">First CRT coefficient in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstCRTCoefficientParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstCRTCoefficientParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="qi" type="string">First CRT coefficient in base64urlUInt encoding</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.FirstFactorCRTExponentParameter">
<summary>
Implements 'First Factor CRT Exponent' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstFactorCRTExponentParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="dp" type="string">First factor CRT exponent in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstFactorCRTExponentParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstFactorCRTExponentParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="dp" type="string">First factor CRT exponent in base64urlUInt encoding</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.FirstPrimeFactorParameter">
<summary>
Implements 'First Prime Factor' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstPrimeFactorParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="p" type="string">First prime factor in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstPrimeFactorParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstPrimeFactorParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="p" type="string">First prime factor in base64urlUInt encoding</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.JWKParameter">
<summary>
Represents a single JWK parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.JWKParameter.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="name" type="string">Parameter name</param>
<param name="value" type="mixed">Parameter value</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.JWKParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.JWKParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="name" type="string">Parameter name</param>
<param name="value" type="mixed">Parameter value</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.KeyIDParameter">
<summary>
Implements 'Key ID' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyIDParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="id" type="string">Key ID</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyIDParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyIDParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="id" type="string">Key ID</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.KeyOperationsParameter">
<summary>
Implements 'Key Operations' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyOperationsParameter.#ctor(Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyOperationsParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyOperationsParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWK.Parameter.KeyTypeParameter">
<summary>
Implements 'Key Type' parameter.
</summary>
</member>
<member name="F:Sop.JWX.JWK.Parameter.KeyTypeParameter.TYPE_OCT">
<summary>
Octet sequence key type.
</summary>

</member>
<member name="F:Sop.JWX.JWK.Parameter.KeyTypeParameter.TYPE_RSA">
<summary>
RSA key type.
</summary>

</member>
<member name="F:Sop.JWX.JWK.Parameter.KeyTypeParameter.TYPE_EC">
<summary>
Elliptic curve key type.
</summary>

</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyTypeParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="type" type="string">Key type</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyTypeParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyTypeParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="type" type="string">Key type</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.KeyValueParameter">
<summary>
Implements 'Key Value' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyValueParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Base64url encoded key</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyValueParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyValueParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Base64url encoded key</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.ModulusParameter">
<summary>
Implements 'Modulus' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ModulusParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="n" type="string">Modulus in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ModulusParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ModulusParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="n" type="string">Modulus in base64urlUInt encoding</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.OtherPrimesInfoParameter">
<summary>
Implements 'Other Primes Info' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.OtherPrimesInfoParameter.#ctor(Pchp.Core.PhpValue[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.OtherPrimesInfoParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.OtherPrimesInfoParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWK.Parameter.PrivateExponentParameter">
<summary>
Implements 'Private Exponent' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.PrivateExponentParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="d" type="string">Private exponent in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.PrivateExponentParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.PrivateExponentParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="d" type="string">Private exponent in base64urlUInt encoding</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.PublicKeyUseParameter">
<summary>
Implements 'Public Key Use' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.PublicKeyUseParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="use" type="string">Intended use of the public key</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.PublicKeyUseParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.PublicKeyUseParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="use" type="string">Intended use of the public key</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.SecondFactorCRTExponentParameter">
<summary>
Implements 'Second Factor CRT Exponent' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.SecondFactorCRTExponentParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="dq" type="string">Second factor CRT exponent in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.SecondFactorCRTExponentParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.SecondFactorCRTExponentParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="dq" type="string">Second factor CRT exponent in base64urlUInt encoding</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.SecondPrimeFactorParameter">
<summary>
Implements 'Second Prime Factor' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.SecondPrimeFactorParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="q" type="string">Second prime factor in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.SecondPrimeFactorParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.SecondPrimeFactorParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="q" type="string">Second prime factor in base64urlUInt encoding</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.X509CertificateChainParameter">
<summary>
Implements 'X.509 Certificate Chain' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateChainParameter.#ctor(Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateChainParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateChainParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWK.Parameter.X509CertificateSHA1ThumbprintParameter">
<summary>
Implements 'X.509 Certificate SHA-1 Thumbprint' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateSHA1ThumbprintParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-1 hash</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateSHA1ThumbprintParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateSHA1ThumbprintParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-1 hash</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.X509CertificateSHA256ThumbprintParameter">
<summary>
Implements 'X.509 Certificate SHA-256 Thumbprint' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateSHA256ThumbprintParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-256 hash</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateSHA256ThumbprintParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateSHA256ThumbprintParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-256 hash</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.X509URLParameter">
<summary>
Implements 'X.509 URL' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509URLParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509URLParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509URLParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWK.Parameter.XCoordinateParameter">
<summary>
Implements 'X Coordinate' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.XCoordinateParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="coord" type="string">X coordinate in base64url encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.XCoordinateParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.XCoordinateParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="coord" type="string">X coordinate in base64url encoding</param>
</member>
<member name="T:Sop.JWX.JWK.Parameter.YCoordinateParameter">
<summary>
Implements 'Y Coordinate' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.YCoordinateParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="coord" type="string">Y coordinate in base64url encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.YCoordinateParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.YCoordinateParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="coord" type="string">Y coordinate in base64url encoding</param>
</member>
<member name="T:Sop.JWX.JWK.RSA.RSAPrivateKeyJWK">
<summary>
Class representing RSA private key as a JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPrivateKeyJWK.#ctor(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPrivateKeyJWK.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPrivateKeyJWK.#ctor(Pchp.Core.Context,Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="T:Sop.JWX.JWK.RSA.RSAPublicKeyJWK">
<summary>
Class representing RSA public key as a JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPublicKeyJWK.#ctor(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPublicKeyJWK.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPublicKeyJWK.#ctor(Pchp.Core.Context,Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="T:Sop.JWX.JWK.Symmetric.SymmetricKeyJWK">
<summary>
JWK containing a symmetric key.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Symmetric.SymmetricKeyJWK.#ctor(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="M:Sop.JWX.JWK.Symmetric.SymmetricKeyJWK.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Symmetric.SymmetricKeyJWK.#ctor(Pchp.Core.Context,Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="T:Sop.JWX.JWK.TypedJWK`1`1">
<summary>
Trait for JWK to provide parameter accessor methods for typed return values.
</summary>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.ECDSAAlgorithm">
<summary>
Base class for algorithms implementing elliptic curve signature computation.
</summary>
</member>
<member name="F:Sop.JWX.JWS.Algorithm.ECDSAAlgorithm._signatureSize">
<summary>
Signature size in bytes.
</summary>

</member>
<member name="T:Sop.JWX.JWS.Algorithm.ES256Algorithm">
<summary>
Implements ECDSA using P-256 and SHA-256.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES256Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES256Algorithm.#ctor(Pchp.Core.Context,Sop.JWX.JWK.EC.ECPublicKeyJWK,Sop.JWX.JWK.EC.ECPrivateKeyJWK)">
<summary>
Constructor.
</summary>
<param name="priv_key" type="ECPrivateKeyJWK"></param>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.ES384Algorithm">
<summary>
Implements ECDSA using P-384 and SHA-384.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES384Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES384Algorithm.#ctor(Pchp.Core.Context,Sop.JWX.JWK.EC.ECPublicKeyJWK,Sop.JWX.JWK.EC.ECPrivateKeyJWK)">
<summary>
Constructor.
</summary>
<param name="priv_key" type="ECPrivateKeyJWK"></param>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.ES512Algorithm">
<summary>
Implements ECDSA using P-521 and SHA-512.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES512Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES512Algorithm.#ctor(Pchp.Core.Context,Sop.JWX.JWK.EC.ECPublicKeyJWK,Sop.JWX.JWK.EC.ECPrivateKeyJWK)">
<summary>
Constructor.
</summary>
<param name="priv_key" type="ECPrivateKeyJWK"></param>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.HMACAlgorithm">
<summary>
Base class for algorithms implementing HMAC signature.
</summary>
</member>
<member name="F:Sop.JWX.JWS.Algorithm.HMACAlgorithm._key">
<summary>
Shared secret key.
</summary>

</member>
<member name="T:Sop.JWX.JWS.Algorithm.HS256Algorithm">
<summary>
Implements HMAC using SHA-256.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS256Algorithm.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Shared secret key</param>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS256Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS256Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Shared secret key</param>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.HS384Algorithm">
<summary>
Implements HMAC using SHA-384.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS384Algorithm.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Shared secret key</param>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS384Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS384Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Shared secret key</param>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.HS512Algorithm">
<summary>
Implements HMAC using SHA-512.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS512Algorithm.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Shared secret key</param>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS512Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS512Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Shared secret key</param>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.NoneAlgorithm">
<summary>
Algorithm for unsecured JWS/JWT.
</summary>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.OpenSSLSignatureAlgorithm">
<summary>
Base class for algorithms employing asymmetric signature computation
using OpenSSL extension.
</summary>
</member>
<member name="F:Sop.JWX.JWS.Algorithm.OpenSSLSignatureAlgorithm._publicKey">
<summary>
Public key.
</summary>

</member>
<member name="F:Sop.JWX.JWS.Algorithm.OpenSSLSignatureAlgorithm._privateKey">
<summary>
Private key.
</summary>

</member>
<member name="T:Sop.JWX.JWS.Algorithm.RS256Algorithm">
<summary>
Implements RSASSA-PKCS1-v1_5 using SHA-256.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS256Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS256Algorithm.#ctor(Pchp.Core.Context,Sop.JWX.JWK.RSA.RSAPublicKeyJWK,Sop.JWX.JWK.RSA.RSAPrivateKeyJWK)">
<summary>
Constructor.
</summary>
<param name="priv_key" type="RSAPrivateKeyJWK"></param>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.RS384Algorithm">
<summary>
Implements RSASSA-PKCS1-v1_5 using SHA-384.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS384Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS384Algorithm.#ctor(Pchp.Core.Context,Sop.JWX.JWK.RSA.RSAPublicKeyJWK,Sop.JWX.JWK.RSA.RSAPrivateKeyJWK)">
<summary>
Constructor.
</summary>
<param name="priv_key" type="RSAPrivateKeyJWK"></param>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.RS512Algorithm">
<summary>
Implements RSASSA-PKCS1-v1_5 using SHA-512.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS512Algorithm.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS512Algorithm.#ctor(Pchp.Core.Context,Sop.JWX.JWK.RSA.RSAPublicKeyJWK,Sop.JWX.JWK.RSA.RSAPrivateKeyJWK)">
<summary>
Constructor.
</summary>
<param name="priv_key" type="RSAPrivateKeyJWK"></param>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.RSASSAPKCS1Algorithm">
<summary>
Base class for algorithms implementing signature with PKCS #1.
</summary>
</member>
<member name="T:Sop.JWX.JWS.Algorithm.SignatureAlgorithmFactory">
<summary>
Factory class to construct signature algorithm instances.
</summary>
</member>
<member name="F:Sop.JWX.JWS.Algorithm.SignatureAlgorithmFactory._header">
<summary>
Header.
</summary>

</member>
<member name="M:Sop.JWX.JWS.Algorithm.SignatureAlgorithmFactory.#ctor(Sop.JWX.JWT.Header.Header)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.SignatureAlgorithmFactory.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.SignatureAlgorithmFactory.#ctor(Pchp.Core.Context,Sop.JWX.JWT.Header.Header)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWS.JWS">
<summary>
Class to represent JWS structure.
</summary>
</member>
<member name="F:Sop.JWX.JWS.JWS._protectedHeader">
<summary>
Protected header.
</summary>

</member>
<member name="F:Sop.JWX.JWS.JWS._payload">
<summary>
Payload.
</summary>

</member>
<member name="F:Sop.JWX.JWS.JWS._signatureInput">
<summary>
Input value for the signature computation.
</summary>

</member>
<member name="F:Sop.JWX.JWS.JWS._signature">
<summary>
Signature.
</summary>

</member>
<member name="M:Sop.JWX.JWS.JWS.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS.#ctor(Pchp.Core.Context,Sop.JWX.JWT.Header.Header,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="protected_header" type="Header">JWS Protected Header</param>
<param name="payload" type="string">JWS Payload</param>
<param name="signature_input" type="string">Input value for the signature computation</param>
<param name="signature" type="string">JWS Signature</param>
</member>
<member name="T:Sop.JWX.JWS.SignatureAlgorithm">
<summary>
Base class for algorithms usable for signing and validating JWS's.
</summary>
</member>
<member name="F:Sop.JWX.JWS.SignatureAlgorithm._keyID">
<summary>
ID of the key used by the algorithm.
If set, KeyID parameter shall be automatically inserted into JWS's
header.
</summary>

</member>
<member name="T:Sop.JWX.JWT.Claim.AudienceClaim">
<summary>
Implements 'Audience' claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.AudienceClaim.#ctor(Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.AudienceClaim.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.AudienceClaim.#ctor(Pchp.Core.Context,Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.Claim">
<summary>
Represents a JWT claim.
</summary>
</member>
<member name="F:Sop.JWX.JWT.Claim.Claim._name">
<summary>
Claim name.
</summary>

</member>
<member name="F:Sop.JWX.JWT.Claim.Claim._value">
<summary>
Claim value.
</summary>

</member>
<member name="F:Sop.JWX.JWT.Claim.Claim._validator">
<summary>
Claim validator.
</summary>

</member>
<member name="M:Sop.JWX.JWT.Claim.Claim.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpValue,Sop.JWX.JWT.Claim.Validator.Validator)">
<summary>
Constructor.
</summary>
<param name="name" type="string">Claim name</param>
<param name="value" type="mixed">Claim value</param>
<param name="validator" type="null|Validator">Claim validator or null if claim doesn't
provide validation</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.Claim.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Claim.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue,Sop.JWX.JWT.Claim.Validator.Validator)">
<summary>
Constructor.
</summary>
<param name="name" type="string">Claim name</param>
<param name="value" type="mixed">Claim value</param>
<param name="validator" type="null|Validator">Claim validator or null if claim doesn't
provide validation</param>
</member>
<member name="T:Sop.JWX.JWT.Claim.ExpirationTimeClaim">
<summary>
Implements 'Expiration Time' claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.ExpirationTimeClaim.#ctor(System.Int64)">
<summary>
Constructor.
</summary>
<param name="exp_time" type="int">Expiration time as a unix timestamp</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.ExpirationTimeClaim.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.ExpirationTimeClaim.#ctor(Pchp.Core.Context,System.Int64)">
<summary>
Constructor.
</summary>
<param name="exp_time" type="int">Expiration time as a unix timestamp</param>
</member>
<member name="T:Sop.JWX.JWT.Claim.Feature.NumericDateClaim`1`1">
<summary>
Trait for claims having NumericDate value.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.Feature.ReferenceTimeValidation`1`1">
<summary>
Trait for claims using reference time as a validation constraint.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.IssuedAtClaim">
<summary>
Implements 'Issued At' claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.IssuedAtClaim.#ctor(System.Int64)">
<summary>
Constructor.
</summary>
<param name="issue_time" type="int">Issued at time as a unix timestamp</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.IssuedAtClaim.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.IssuedAtClaim.#ctor(Pchp.Core.Context,System.Int64)">
<summary>
Constructor.
</summary>
<param name="issue_time" type="int">Issued at time as a unix timestamp</param>
</member>
<member name="T:Sop.JWX.JWT.Claim.IssuerClaim">
<summary>
Implements 'Issuer' claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.IssuerClaim.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.IssuerClaim.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.IssuerClaim.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.JWTIDClaim">
<summary>
Implements 'JWT ID' claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.JWTIDClaim.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="id" type="string">JWT unique identifier</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.JWTIDClaim.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.JWTIDClaim.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="id" type="string">JWT unique identifier</param>
</member>
<member name="T:Sop.JWX.JWT.Claim.NotBeforeClaim">
<summary>
Implements 'Not Before' claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.NotBeforeClaim.#ctor(System.Int64)">
<summary>
Constructor.
</summary>
<param name="not_before" type="int">Not before time as a unix timestamp</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.NotBeforeClaim.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.NotBeforeClaim.#ctor(Pchp.Core.Context,System.Int64)">
<summary>
Constructor.
</summary>
<param name="not_before" type="int">Not before time as a unix timestamp</param>
</member>
<member name="T:Sop.JWX.JWT.Claim.RegisteredClaim">
<summary>
Base class for registered claims.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.SubjectClaim">
<summary>
Implements 'Subject' claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.SubjectClaim.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="subject" type="string">Subject</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.SubjectClaim.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.SubjectClaim.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="subject" type="string">Subject</param>
</member>
<member name="T:Sop.JWX.JWT.Claim.TypedClaims`1`1">
<summary>
Trait for Claims to provide claim accessor methods for typed return values.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.Validator.ContainsValidator">
<summary>
Validator to check whether the claim value contains a given constraint.
If the claim value is an array, validator checks whether the array contains
a constraint. Otherwise variable equality is tested.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.Validator.EqualsValidator">
<summary>
Validator to check whether the claim value is equal to the constraint.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.Validator.GreaterOrEqualValidator">
<summary>
Validator to check whether the claim value is greater or equal to the
constraint.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.Validator.GreaterValidator">
<summary>
Validator to check whether the claim value is greater than the constraint.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.Validator.LessOrEqualValidator">
<summary>
Validator to check whether the claim value is less or equal to the
constraint.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.Validator.LessValidator">
<summary>
Validator to check whether the claim value is less than the constraint.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claim.Validator.Validator">
<summary>
Base class for the claim validators.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Claims">
<summary>
Represents a set of Claim objects.
</summary>
</member>
<member name="F:Sop.JWX.JWT.Claims._claims">
<summary>
Claims.
</summary>

</member>
<member name="M:Sop.JWX.JWT.Claims.#ctor(Sop.JWX.JWT.Claim.Claim[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claims.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claims.#ctor(Pchp.Core.Context,Sop.JWX.JWT.Claim.Claim[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Exception.ValidationException">
<summary>
Exception thrown when claim validation fails.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Header.Header">
<summary>
Represents a header used in JWS and JWE.
</summary>
</member>
<member name="F:Sop.JWX.JWT.Header.Header._parameters">
<summary>
Parameters.
</summary>

</member>
<member name="M:Sop.JWX.JWT.Header.Header.#ctor(Sop.JWX.JWT.Parameter.JWTParameter[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.#ctor(Pchp.Core.Context,Sop.JWX.JWT.Parameter.JWTParameter[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Header.HeaderParameters">
<summary>
Interface for classes providing JOSE header parameters.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Header.JOSE">
<summary>
Represents as JOSE header.
JOSE header consists of one or more Header objects, that are merged together.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.JOSE.#ctor(Sop.JWX.JWT.Header.Header[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.JOSE.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.JOSE.#ctor(Pchp.Core.Context,Sop.JWX.JWT.Header.Header[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Header.TypedHeader`1`1">
<summary>
Trait for Header to provide parameter accessor methods for typed return
values.
</summary>
</member>
<member name="T:Sop.JWX.JWT.JWT">
<summary>
Represents a token as a JWS or a JWE compact serialization with claims
as a payload.
</summary>
</member>
<member name="F:Sop.JWX.JWT.JWT._parts">
<summary>
JWT parts.
</summary>

</member>
<member name="F:Sop.JWX.JWT.JWT._type">
<summary>
JWT type.
</summary>

</member>
<member name="F:Sop.JWX.JWT.JWT.TYPE_JWS">
<summary>
Type identifier for the signed JWT.
</summary>

</member>
<member name="F:Sop.JWX.JWT.JWT.TYPE_JWE">
<summary>
Type identifier for the encrypted JWT.
</summary>

</member>
<member name="M:Sop.JWX.JWT.JWT.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="token" type="string">JWT string</param>
</member>
<member name="M:Sop.JWX.JWT.JWT.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.JWT.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="token" type="string">JWT string</param>
</member>
<member name="T:Sop.JWX.JWT.Parameter.AlgorithmParameter">
<summary>
Implements 'Algorithm' parameter for JWS/JWE headers.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AlgorithmParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="string">Algorithm name</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AlgorithmParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AlgorithmParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="string">Algorithm name</param>
</member>
<member name="T:Sop.JWX.JWT.Parameter.AlgorithmParameterValue">
<summary>
Interface for algorithms providing value for 'alg' header parameter.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.AuthenticationTagParameter">
<summary>
Implements 'Authentication Tag' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AuthenticationTagParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="tag" type="string">Base64url encoded authentication tag</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AuthenticationTagParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AuthenticationTagParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="tag" type="string">Base64url encoded authentication tag</param>
</member>
<member name="T:Sop.JWX.JWT.Parameter.B64PayloadParameter">
<summary>
Implements 'base64url-encode payload' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.B64PayloadParameter.#ctor(System.Boolean)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.B64PayloadParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.B64PayloadParameter.#ctor(Pchp.Core.Context,System.Boolean)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.CompressionAlgorithmParameter">
<summary>
Implements 'Compression Algorithm' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CompressionAlgorithmParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CompressionAlgorithmParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CompressionAlgorithmParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.CompressionAlgorithmParameterValue">
<summary>
Interface for algorithms providing value for 'zip' header parameter.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.ContentTypeParameter">
<summary>
Implements 'Content Type' parameter.
</summary>
</member>
<member name="F:Sop.JWX.JWT.Parameter.ContentTypeParameter.TYPE_JWT">
<summary>
Content type for the nested JWT.
</summary>

</member>
<member name="M:Sop.JWX.JWT.Parameter.ContentTypeParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.ContentTypeParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.ContentTypeParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.CriticalParameter">
<summary>
Implements 'Critical' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CriticalParameter.#ctor(Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CriticalParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CriticalParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.EncryptionAlgorithmParameter">
<summary>
Implements 'Encryption Algorithm' parameter for JWE headers.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.EncryptionAlgorithmParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="string">Algorithm name</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.EncryptionAlgorithmParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.EncryptionAlgorithmParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="string">Algorithm name</param>
</member>
<member name="T:Sop.JWX.JWT.Parameter.EncryptionAlgorithmParameterValue">
<summary>
Interface for algorithms providing value for 'enc' header parameter.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.InitializationVectorParameter">
<summary>
Implements 'Initialization Vector' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.InitializationVectorParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="iv" type="string">Base64url encoded initialization vector</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.InitializationVectorParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.InitializationVectorParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="iv" type="string">Base64url encoded initialization vector</param>
</member>
<member name="T:Sop.JWX.JWT.Parameter.JSONWebKeyParameter">
<summary>
Implements 'JSON Web Key' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JSONWebKeyParameter.#ctor(Sop.JWX.JWK.JWK)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JSONWebKeyParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JSONWebKeyParameter.#ctor(Pchp.Core.Context,Sop.JWX.JWK.JWK)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.JWKSetURLParameter">
<summary>
Implements 'JWK Set URL' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JWKSetURLParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JWKSetURLParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JWKSetURLParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.JWTParameter">
<summary>
Represents a header parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JWTParameter.#ctor(Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="name" type="string">Parameter name</param>
<param name="value" type="mixed">Parameter value</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JWTParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JWTParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="name" type="string">Parameter name</param>
<param name="value" type="mixed">Parameter value</param>
</member>
<member name="T:Sop.JWX.JWT.Parameter.KeyIDParameter">
<summary>
Implements 'Key ID' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.KeyIDParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.KeyIDParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.KeyIDParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.PBES2CountParameter">
<summary>
Implements 'PBES2 Count' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2CountParameter.#ctor(System.Int64)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2CountParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2CountParameter.#ctor(Pchp.Core.Context,System.Int64)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.PBES2SaltInputParameter">
<summary>
Implements 'PBES2 Salt Input' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2SaltInputParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="salt" type="string">Base64url encoded salt input value</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2SaltInputParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2SaltInputParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="salt" type="string">Base64url encoded salt input value</param>
</member>
<member name="T:Sop.JWX.JWT.Parameter.ReplicatedClaimParameter">
<summary>
Parameter allowing claims to be inserted into header.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.ReplicatedClaimParameter.#ctor(Sop.JWX.JWT.Claim.Claim)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.ReplicatedClaimParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.ReplicatedClaimParameter.#ctor(Pchp.Core.Context,Sop.JWX.JWT.Claim.Claim)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.TypeParameter">
<summary>
Implements 'Type' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.TypeParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.TypeParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.TypeParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.X509CertificateChainParameter">
<summary>
Implements 'X.509 Certificate Chain' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateChainParameter.#ctor(Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateChainParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateChainParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.Parameter.X509CertificateSHA1ThumbprintParameter">
<summary>
Implements 'X.509 Certificate SHA-1 Thumbprint' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateSHA1ThumbprintParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-1 hash</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateSHA1ThumbprintParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateSHA1ThumbprintParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-1 hash</param>
</member>
<member name="T:Sop.JWX.JWT.Parameter.X509CertificateSHA256ThumbprintParameter">
<summary>
Implements 'X.509 Certificate SHA-256 Thumbprint' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateSHA256ThumbprintParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-256 hash</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateSHA256ThumbprintParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateSHA256ThumbprintParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-256 hash</param>
</member>
<member name="T:Sop.JWX.JWT.Parameter.X509URLParameter">
<summary>
Implements 'X.509 URL' parameter.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509URLParameter.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509URLParameter.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509URLParameter.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="T:Sop.JWX.JWT.ValidationContext">
<summary>
Class to provide context for claims validation.
Validation constraints are variables, that are compared against the claims.
Validation of the expiration, not-before and not-after claims is provided by
default.

Constraints configured for the validation context must be present in the
validated set of claims, or else validation fails.

Context also provides a set of JSON Web Keys, that shall be used for the
JWS signature validation or JWE payload decryption.

Registered claims provide their own validation logic. Claims that are not
supported by this library must be provided with an explicit validator along
with the constraint.
</summary>
</member>
<member name="F:Sop.JWX.JWT.ValidationContext._refTime">
<summary>
Reference time.
</summary>

</member>
<member name="F:Sop.JWX.JWT.ValidationContext._leeway">
<summary>
Leeway in seconds for the reference time constraints.
</summary>

</member>
<member name="F:Sop.JWX.JWT.ValidationContext._constraints">
<summary>
Validation constraints.
</summary>

</member>
<member name="F:Sop.JWX.JWT.ValidationContext._validators">
<summary>
Explicitly defined validators for named claims.
</summary>

</member>
<member name="F:Sop.JWX.JWT.ValidationContext._keys">
<summary>
Set of JSON Web Keys usable for the validation.
</summary>

</member>
<member name="F:Sop.JWX.JWT.ValidationContext._allowUnsecured">
<summary>
Whether to allow unsecured JWT's, that is, claims without integrity
protection nor encryption.
</summary>

</member>
<member name="M:Sop.JWX.JWT.ValidationContext.#ctor(Pchp.Core.PhpValue,Sop.JWX.JWK.JWKSet)">
<summary>
Constructor.
</summary>
<param name="constraints" type="null|array">Optional array of constraints for the
registered claims</param>
<param name="keys" type="null|JWKSet">Optional set of JSON Web Keys used for
signature validation and/or decryption</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.#ctor(Pchp.Core.Context,Pchp.Core.PhpValue,Sop.JWX.JWK.JWKSet)">
<summary>
Constructor.
</summary>
<param name="constraints" type="null|array">Optional array of constraints for the
registered claims</param>
<param name="keys" type="null|JWKSet">Optional set of JSON Web Keys used for
signature validation and/or decryption</param>
</member>
<member name="T:Sop.JWX.Parameter.Feature.ArrayParameterValue`1`1">
<summary>
Trait for parameters having an array value.
</summary>
</member>
<member name="T:Sop.JWX.Parameter.Feature.Base64UIntValue`1`1">
<summary>
Trait for parameters having Base64urlUInt value.
</summary>
</member>
<member name="T:Sop.JWX.Parameter.Feature.Base64URLValue`1`1">
<summary>
Trait for parameters having Base64url value.
</summary>
</member>
<member name="T:Sop.JWX.Parameter.Feature.StringParameterValue`1`1">
<summary>
Trait for parameters having a string value.
</summary>
</member>
<member name="T:Sop.JWX.Parameter.Parameter">
<summary>
Base class for JWT and JWK parameters.
</summary>
</member>
<member name="F:Sop.JWX.Parameter.Parameter._name">
<summary>
Parameter name.
</summary>

</member>
<member name="F:Sop.JWX.Parameter.Parameter._value">
<summary>
Parameter value.
</summary>

</member>
<member name="T:Sop.JWX.Util.Base64">
<summary>
Class offering Base64 encoding and decoding.
</summary>
</member>
<member name="T:Sop.JWX.Util.BigInt">
<summary>
Class for handling big integers.
</summary>
</member>
<member name="F:Sop.JWX.Util.BigInt._num">
<summary>
Number.
</summary>

</member>
<member name="M:Sop.JWX.Util.BigInt.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.Util.BigInt.#ctor(Pchp.Core.Context,System.Object)">
<summary>
Constructor.
</summary>
<param name="num" type="\GMP">GMP number</param>
</member>
<member name="T:Sop.JWX.Util.UUIDv4">
<summary>
UUID version 4.
</summary>
</member>
<member name="F:Sop.JWX.Util.UUIDv4._uuid">
<summary>
UUID.
</summary>

</member>
<member name="M:Sop.JWX.Util.UUIDv4.#ctor(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="uuid" type="string">UUIDv4 in canonical hexadecimal format</param>
</member>
<member name="M:Sop.JWX.Util.UUIDv4.#ctor(Pchp.Core.Context,Pchp.Core.DummyFieldsOnlyCtor)">
<summary>
Initializes the class without calling its '__construct' method.
</summary>
</member>
<member name="M:Sop.JWX.Util.UUIDv4.#ctor(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="uuid" type="string">UUIDv4 in canonical hexadecimal format</param>
</member>
<member name="M:&lt;Root&gt;vendor/composer.autoload_real_php.composerRequire0f004dd85c03cdf085379b6e359f9671(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="fileIdentifier" type="string"></param>
<param name="file" type="string"></param>
</member>
<member name="M:&lt;Root&gt;vendor/composer.ClassLoader_php.Composer#Autoload#includeFile(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Scope isolated include.
Prevents access to $this/self from included files.
</summary>
<param name="file" type="string"></param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/guzzle/src.functions_php.GuzzleHttp#describe_type(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Debug function used to describe the provided value type and class.
</summary>
<param name="input" type="mixed">Any type of variable to describe the type of. This
parameter misses a typehint because of that.</param>
<returns>Returns a string containing the type of the variable and
if a class is provided, the class name.</returns>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/guzzle/src.functions_php.GuzzleHttp#headers_from_lines(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Parses an array of header lines into an associative array of headers.
</summary>
<param name="lines" type="iterable">Header lines array of strings in the following
format: "Name: Value"</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/guzzle/src.functions_php.GuzzleHttp#debug_resource(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Returns a debug stream based on the provided variable.
</summary>
<param name="value" type="mixed">Optional value</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/guzzle/src.functions_php.GuzzleHttp#choose_handler(Pchp.Core.Context)">
<summary>
Chooses and creates a default handler to use based on the environment.
The returned handler is not wrapped by any default middlewares.
</summary>
<exception cref="RuntimeException">if no viable Handler is available.</exception>
<returns>callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface Returns the best handler for the given system.</returns>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/guzzle/src.functions_php.GuzzleHttp#default_user_agent(Pchp.Core.Context)">
<summary>
Get the default User-Agent string to use with Guzzle.
</summary>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/guzzle/src.functions_php.GuzzleHttp#default_ca_bundle(Pchp.Core.Context)">
<summary>
Returns the default cacert bundle for the current system.
First, the openssl.cafile and curl.cainfo php.ini settings are checked.
If those settings are not configured, then the common locations for
bundles found on Red Hat, CentOS, Fedora, Ubuntu, Debian, FreeBSD, OS X
and Windows are checked. If any of these file locations are found on
disk, they will be utilized.

Note: the result of this function is cached for subsequent calls.
</summary>
<exception cref="RuntimeException">if no bundle can be found.</exception>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/guzzle/src.functions_php.GuzzleHttp#normalize_header_keys(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Creates an associative array of lowercase header names to the actual
header casing.
</summary>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/guzzle/src.functions_php.GuzzleHttp#is_host_in_noproxy(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpArray)">
<summary>
Returns true if the provided host matches any of the no proxy areas.
This method will strip a port from the host if it is present. Each pattern
can be matched with an exact match (e.g., "foo.com" == "foo.com") or a
partial match: (e.g., "foo.com" == "baz.foo.com" and ".foo.com" ==
"baz.foo.com", but ".foo.com" != "foo.com").

Areas are matched in the following cases:
1. "*" (without quotes) always matches any hosts.
2. An exact match.
3. The area starts with "." and the area is the last part of the host. e.g.
'.mit.edu' will match any host that ends with '.mit.edu'.
</summary>
<param name="host" type="string">Host to check against the patterns.</param>
<param name="noProxyArray" type="string[]">An array of host patterns.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/guzzle/src.functions_php.GuzzleHttp#json_decode(Pchp.Core.Context,Pchp.Core.PhpString,System.Boolean,System.Int64,System.Int64)">
<summary>
Wrapper for json_decode that throws when an error occurs.
</summary>
<param name="json" type="string">JSON data to parse</param>
<param name="assoc" type="bool">When true, returned objects will be converted
into associative arrays.</param>
<param name="depth" type="int">User specified recursion depth.</param>
<param name="options" type="int">Bitmask of JSON decode options.</param>
<exception cref="Exception.InvalidArgumentException">if the JSON cannot be decoded.</exception>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/guzzle/src.functions_php.GuzzleHttp#json_encode(Pchp.Core.Context,Pchp.Core.PhpValue,System.Int64,System.Int64)">
<summary>
Wrapper for JSON encoding that throws when an error occurs.
</summary>
<param name="value" type="mixed">The value being encoded</param>
<param name="options" type="int">JSON encode option bitmask</param>
<param name="depth" type="int">Set the maximum depth. Must be greater than zero.</param>
<exception cref="Exception.InvalidArgumentException">if the JSON cannot be encoded.</exception>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#queue(Pchp.Core.Context,GuzzleHttp.Promise.TaskQueueInterface)">
<summary>
Get the global task queue used for promise resolution.
This task queue MUST be run in an event loop in order for promises to be
settled asynchronously. It will be automatically run when synchronously
waiting on a promise.

&lt;code&gt;
while ($eventLoop-&gt;isRunning()) {
GuzzleHttp\Promise\queue()-&gt;run();
}
&lt;/code&gt;
</summary>
<param name="assign" type="TaskQueueInterface">Optionally specify a new queue instance.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#task(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Adds a function to run in the task queue when it is next `run()` and returns
a promise that is fulfilled or rejected with the result.
</summary>
<param name="task" type="callable">Task function to run.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#promise_for(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Creates a promise for a value if the value is not a promise.
</summary>
<param name="value" type="mixed">Promise or value.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#rejection_for(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Creates a rejected promise for a reason if the reason is not a promise. If
the provided reason is a promise, then it is returned as-is.
</summary>
<param name="reason" type="mixed">Promise or reason.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#exception_for(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Create an exception for a rejected promise value.
</summary>
<param name="reason" type="mixed"></param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#iter_for(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Returns an iterator for the given value.
</summary>
<param name="value" type="mixed"></param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#inspect(Pchp.Core.Context,GuzzleHttp.Promise.PromiseInterface)">
<summary>
Synchronously waits on a promise to resolve and returns an inspection state
array.
Returns a state associative array containing a "state" key mapping to a
valid promise state. If the state of the promise is "fulfilled", the array
will contain a "value" key mapping to the fulfilled value of the promise. If
the promise is rejected, the array will contain a "reason" key mapping to
the rejection reason of the promise.
</summary>
<param name="promise" type="PromiseInterface">Promise or value.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#inspect_all(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Waits on all of the provided promises, but does not unwrap rejected promises
as thrown exception.
Returns an array of inspection state arrays.
</summary>
<param name="promises" type="PromiseInterface[]">Traversable of promises to wait upon.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#unwrap(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Waits on all of the provided promises and returns the fulfilled values.
Returns an array that contains the value of each promise (in the same order
the promises were provided). An exception is thrown if any of the promises
are rejected.
</summary>
<param name="promises" type="iterable&lt;PromiseInterface&gt;">Iterable of PromiseInterface objects to wait on.</param>
<exception cref="Exception">on error</exception>
<exception cref="Throwable">on error in PHP &gt;=7</exception>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#all(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Given an array of promises, return a promise that is fulfilled when all the
items in the array are fulfilled.
The promise's fulfillment value is an array with fulfillment values at
respective positions to the original array. If any promise in the array
rejects, the returned promise is rejected with the rejection reason.
</summary>
<param name="promises" type="mixed">Promises or values.</param>
<param name="recursive" type="bool">If true, resolves new promises that might have been added to the stack during its own resolution.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#some(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Initiate a competitive race between multiple promises or values (values will
become immediately fulfilled promises).
When count amount of promises have been fulfilled, the returned promise is
fulfilled with an array that contains the fulfillment values of the winners
in order of resolution.

This promise is rejected with a {@see AggregateException} if the number of
fulfilled promises is less than the desired $count.
</summary>
<param name="count" type="int">Total number of promises.</param>
<param name="promises" type="mixed">Promises or values.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#any(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Like some(), with 1 as count. However, if the promise fulfills, the
fulfillment value is not an array of 1 but the value directly.
</summary>
<param name="promises" type="mixed">Promises or values.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#settle(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Returns a promise that is fulfilled when all of the provided promises have
been fulfilled or rejected.
The returned promise is fulfilled with an array of inspection state arrays.
</summary>
<param name="promises" type="mixed">Promises or values.</param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#each(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Given an iterator that yields promises or values, returns a promise that is
fulfilled with a null value when the iterator has been consumed or the
aggregate promise has been fulfilled or rejected.
$onFulfilled is a function that accepts the fulfilled value, iterator index,
and the aggregate promise. The callback can invoke any necessary side
effects and choose to resolve or reject the aggregate if needed.

$onRejected is a function that accepts the rejection reason, iterator index,
and the aggregate promise. The callback can invoke any necessary side
effects and choose to resolve or reject the aggregate if needed.
</summary>
<param name="iterable" type="mixed">Iterator or array to iterate over.</param>
<param name="onFulfilled" type="callable"></param>
<param name="onRejected" type="callable"></param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#each_limit(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Like each, but only allows a certain number of outstanding promises at any
given time.
$concurrency may be an integer or a function that accepts the number of
pending promises and returns a numeric concurrency limit value to allow for
dynamic a concurrency size.
</summary>
<param name="iterable" type="mixed"></param>
<param name="concurrency" type="int|callable"></param>
<param name="onFulfilled" type="callable"></param>
<param name="onRejected" type="callable"></param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#each_limit_all(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Like each_limit, but ensures that no promise in the given $iterable argument
is rejected. If any promise is rejected, then the aggregate promise is
rejected with the encountered rejection.
</summary>
<param name="iterable" type="mixed"></param>
<param name="concurrency" type="int|callable"></param>
<param name="onFulfilled" type="callable"></param>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#is_fulfilled(Pchp.Core.Context,GuzzleHttp.Promise.PromiseInterface)">
<summary>
Returns true if a promise is fulfilled.
</summary>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#is_rejected(Pchp.Core.Context,GuzzleHttp.Promise.PromiseInterface)">
<summary>
Returns true if a promise is rejected.
</summary>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#is_settled(Pchp.Core.Context,GuzzleHttp.Promise.PromiseInterface)">
<summary>
Returns true if a promise is fulfilled or rejected.
</summary>
</member>
<member name="M:&lt;Root&gt;vendor/guzzlehttp/promises/src.functions_php.GuzzleHttp#Promise#coroutine(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Create a new coroutine.
</summary>
</member>
<member name="M:&lt;Root&gt;vendor/ralouphie/getallheaders/src.getallheaders_php.getallheaders?0(Pchp.Core.Context)">
<summary>
Get all HTTP header key/values as an associative array for the current request.
</summary>
<returns>The HTTP header key/value pairs.</returns>
</member>
<member name="M:&lt;Root&gt;vendor/symfony/deprecation-contracts.function_php.trigger_deprecation?0(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,System.Object[])">
<summary>
Triggers a silenced deprecation notice.
</summary>
<param name="package" type="string">The name of the Composer package that is triggering the deprecation</param>
<param name="version" type="string">The version of the package that introduced the deprecation</param>
<param name="message" type="string">The message of the deprecation</param>
</member>
<member name="M:BaconQrCode.Common.BitArray.__construct(System.Int64)">
<summary>
Creates a new bit array with a given size.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.getSize">
<summary>
Gets the size in bits.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.getSizeInBytes">
<summary>
Gets the size in bytes.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.ensureCapacity(System.Int64)">
<summary>
Ensures that the array has a minimum capacity.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.get(System.Int64)">
<summary>
Gets a specific bit.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.set(System.Int64)">
<summary>
Sets a specific bit.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.flip(System.Int64)">
<summary>
Flips a specific bit.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.getNextSet(System.Int64)">
<summary>
Gets the next set bit position from a given position.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.getNextUnset(System.Int64)">
<summary>
Gets the next unset bit position from a given position.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.setBulk(System.Int64,System.Int64)">
<summary>
Sets a bulk of bits.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.setRange(System.Int64,System.Int64)">
<summary>
Sets a range of bits.
</summary>
<exception cref="InvalidArgumentException">if end is smaller than start</exception>
</member>
<member name="M:BaconQrCode.Common.BitArray.clear">
<summary>
Clears the bit array, unsetting every bit.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.isRange(System.Int64,System.Int64,System.Boolean)">
<summary>
Checks if a range of bits is set or not set.
</summary>
<exception cref="InvalidArgumentException">if end is smaller than start</exception>
</member>
<member name="M:BaconQrCode.Common.BitArray.appendBit(System.Boolean)">
<summary>
Appends a bit to the array.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.appendBits(System.Int64,System.Int64)">
<summary>
Appends a number of bits (up to 32) to the array.
</summary>
<exception cref="InvalidArgumentException">if num bits is not between 0 and 32</exception>
</member>
<member name="M:BaconQrCode.Common.BitArray.appendBitArray(BaconQrCode.Common.BitArray)">
<summary>
Appends another bit array to this array.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.xorBits(BaconQrCode.Common.BitArray)">
<summary>
Makes an exclusive-or comparision on the current bit array.
</summary>
<exception cref="InvalidArgumentException">if sizes don't match</exception>
</member>
<member name="M:BaconQrCode.Common.BitArray.toBytes(System.Int64,System.Int64)">
<summary>
Converts the bit array to a byte array.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.getBitArray">
<summary>
Gets the internal bit array.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.reverse">
<summary>
Reverses the array.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitArray.__toString">
<summary>
Returns a string representation of the bit array.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.__construct(System.Int64,Pchp.Core.PhpValue)">
<exception cref="InvalidArgumentException">if a dimension is smaller than zero</exception>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.get(System.Int64,System.Int64)">
<summary>
Gets the requested bit, where true means black.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.set(System.Int64,System.Int64)">
<summary>
Sets the given bit to true.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.flip(System.Int64,System.Int64)">
<summary>
Flips the given bit.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.clear">
<summary>
Clears all bits (set to false).
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.setRegion(System.Int64,System.Int64,System.Int64,System.Int64)">
<summary>
Sets a square region of the bit matrix to true.
</summary>
<exception cref="InvalidArgumentException">if left or top are negative</exception>
<exception cref="InvalidArgumentException">if width or height are smaller than 1</exception>
<exception cref="InvalidArgumentException">if region does not fit into the matix</exception>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.getRow(System.Int64,BaconQrCode.Common.BitArray)">
<summary>
A fast method to retrieve one row of data from the matrix as a BitArray.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.setRow(System.Int64,BaconQrCode.Common.BitArray)">
<summary>
Sets a row of data from a BitArray.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.getEnclosingRectangle">
<summary>
This is useful in detecting the enclosing rectangle of a 'pure' barcode.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.getTopLeftOnBit">
<summary>
Gets the most top left set bit.
This is useful in detecting a corner of a 'pure' barcode.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.getBottomRightOnBit">
<summary>
Gets the most bottom right set bit.
This is useful in detecting a corner of a 'pure' barcode.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.getWidth">
<summary>
Gets the width of the matrix,
</summary>
</member>
<member name="M:BaconQrCode.Common.BitMatrix.getHeight">
<summary>
Gets the height of the matrix.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitUtils.unsignedRightShift(Pchp.Core.Context,System.Int64,System.Int64)">
<summary>
Performs an unsigned right shift.
This is the same as the unsigned right shift operator "&gt;&gt;&gt;" in other
languages.
</summary>
</member>
<member name="M:BaconQrCode.Common.BitUtils.numberOfTrailingZeros(Pchp.Core.Context,System.Int64)">
<summary>
Gets the number of trailing zeros.
</summary>
</member>
<member name="M:BaconQrCode.Common.CharacterSetEci.getValue">
<summary>
Returns the primary value.
</summary>
</member>
<member name="M:BaconQrCode.Common.CharacterSetEci.getCharacterSetEciByValue(Pchp.Core.Context,System.Int64)">
<summary>
Gets character set ECI by value.
Returns the representing ECI of a given value, or null if it is legal but unsupported.
</summary>
<exception cref="InvalidArgumentException">if value is not between 0 and 900</exception>
</member>
<member name="M:BaconQrCode.Common.CharacterSetEci.getCharacterSetEciByName(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Returns character set ECI by name.
Returns the representing ECI of a given name, or null if it is legal but unsupported
</summary>
</member>
<member name="M:BaconQrCode.Common.EcBlock.getCount">
<summary>
Returns how many times the block is used.
</summary>
</member>
<member name="M:BaconQrCode.Common.EcBlock.getDataCodewords">
<summary>
Returns the number of data codewords.
</summary>
</member>
<member name="M:BaconQrCode.Common.EcBlocks.getEcCodewordsPerBlock">
<summary>
Returns the number of EC codewords per block.
</summary>
</member>
<member name="M:BaconQrCode.Common.EcBlocks.getNumBlocks">
<summary>
Returns the total number of EC block appearances.
</summary>
</member>
<member name="M:BaconQrCode.Common.EcBlocks.getTotalEcCodewords">
<summary>
Returns the total count of EC codewords.
</summary>
</member>
<member name="M:BaconQrCode.Common.EcBlocks.getEcBlocks">
<summary>
Returns the EC blocks included in this collection.
</summary>
</member>
<member name="M:BaconQrCode.Common.ErrorCorrectionLevel.forBits(Pchp.Core.Context,System.Int64)">
<exception cref="OutOfBoundsException">if number of bits is invalid</exception>
</member>
<member name="M:BaconQrCode.Common.ErrorCorrectionLevel.getBits">
<summary>
Returns the two bits used to encode this error correction level.
</summary>
</member>
<member name="M:BaconQrCode.Common.FormatInformation.numBitsDiffering(Pchp.Core.Context,System.Int64,System.Int64)">
<summary>
Checks how many bits are different between two integers.
</summary>
</member>
<member name="M:BaconQrCode.Common.FormatInformation.decodeFormatInformation(Pchp.Core.Context,System.Int64,System.Int64)">
<summary>
Decodes format information.
</summary>
</member>
<member name="M:BaconQrCode.Common.FormatInformation.doDecodeFormatInformation(Pchp.Core.Context,System.Int64,System.Int64)">
<summary>
Internal method for decoding format information.
</summary>
</member>
<member name="M:BaconQrCode.Common.FormatInformation.getErrorCorrectionLevel">
<summary>
Returns the error correction level.
</summary>
</member>
<member name="M:BaconQrCode.Common.FormatInformation.getDataMask">
<summary>
Returns the data mask.
</summary>
</member>
<member name="M:BaconQrCode.Common.FormatInformation.hashCode">
<summary>
Hashes the code of the EC level.
</summary>
</member>
<member name="M:BaconQrCode.Common.FormatInformation.equals(BaconQrCode.Common.FormatInformation)">
<summary>
Verifies if this instance equals another one.
</summary>
</member>
<member name="M:BaconQrCode.Common.Mode.getCharacterCountBits(BaconQrCode.Common.Version)">
<summary>
Returns the number of bits used in a specific QR code version.
</summary>
</member>
<member name="M:BaconQrCode.Common.Mode.getBits">
<summary>
Returns the four bits used to encode this mode.
</summary>
</member>
<member name="M:BaconQrCode.Common.ReedSolomonCodec.__construct(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
<exception cref="InvalidArgumentException">if symbol size ist not between 0 and 8</exception>
<exception cref="InvalidArgumentException">if first root is invalid</exception>
<exception cref="InvalidArgumentException">if num roots is invalid</exception>
<exception cref="InvalidArgumentException">if padding is invalid</exception>
<exception cref="RuntimeException">if field generator polynomial is not primitive</exception>
</member>
<member name="M:BaconQrCode.Common.ReedSolomonCodec.encode(Pchp.Library.Spl.SplFixedArray,Pchp.Library.Spl.SplFixedArray)">
<summary>
Encodes data and writes result back into parity array.
</summary>
</member>
<member name="M:BaconQrCode.Common.ReedSolomonCodec.decode(Pchp.Library.Spl.SplFixedArray,Pchp.Library.Spl.SplFixedArray)">
<summary>
Decodes received data.
</summary>
</member>
<member name="M:BaconQrCode.Common.ReedSolomonCodec.modNn(System.Int64)">
<summary>
Computes $x % GF_SIZE, where GF_SIZE is 2**GF_BITS - 1, without a slow divide.
</summary>
</member>
<member name="M:BaconQrCode.Common.Version.__construct(System.Int64,Pchp.Core.PhpArray,BaconQrCode.Common.EcBlocks[])">
<param name="alignmentPatternCenters" type="int[]"></param>
</member>
<member name="M:BaconQrCode.Common.Version.getVersionNumber">
<summary>
Returns the version number.
</summary>
</member>
<member name="M:BaconQrCode.Common.Version.getAlignmentPatternCenters">
<summary>
Returns the alignment pattern centers.
</summary>
</member>
<member name="M:BaconQrCode.Common.Version.getTotalCodewords">
<summary>
Returns the total number of codewords.
</summary>
</member>
<member name="M:BaconQrCode.Common.Version.getDimensionForVersion">
<summary>
Calculates the dimension for the current version.
</summary>
</member>
<member name="M:BaconQrCode.Common.Version.getEcBlocksForLevel(BaconQrCode.Common.ErrorCorrectionLevel)">
<summary>
Returns the number of EC blocks for a specific EC level.
</summary>
</member>
<member name="M:BaconQrCode.Common.Version.getProvisionalVersionForDimension(Pchp.Core.Context,System.Int64)">
<summary>
Gets a provisional version number for a specific dimension.
</summary>
<exception cref="InvalidArgumentException">if dimension is not 1 mod 4</exception>
</member>
<member name="M:BaconQrCode.Common.Version.getVersionForNumber(Pchp.Core.Context,System.Int64)">
<summary>
Gets a version instance for a specific version number.
</summary>
<exception cref="InvalidArgumentException">if version number is out of range</exception>
</member>
<member name="M:BaconQrCode.Common.Version.decodeVersionInformation(Pchp.Core.Context,System.Int64)">
<summary>
Decodes version information from an integer and returns the version.
</summary>
</member>
<member name="M:BaconQrCode.Common.Version.buildFunctionPattern">
<summary>
Builds the function pattern for the current version.
</summary>
</member>
<member name="M:BaconQrCode.Common.Version.__toString">
<summary>
Returns a string representation for the version.
</summary>
</member>
<member name="M:BaconQrCode.Common.Version.versions(Pchp.Core.Context)">
<summary>
Build and cache a specific version.
See ISO 18004:2006 6.5.1 Table 9.
</summary>
<returns>array&lt;int, self&gt;</returns>
</member>
<member name="M:BaconQrCode.Encoder.BlockPair.__construct(Pchp.Library.Spl.SplFixedArray,Pchp.Library.Spl.SplFixedArray)">
<summary>
Creates a new block pair.
</summary>
<param name="data" type="SplFixedArray&lt;int&gt;"></param>
<param name="errorCorrection" type="SplFixedArray&lt;int&gt;"></param>
</member>
<member name="M:BaconQrCode.Encoder.BlockPair.getDataBytes">
<summary>
Gets the data bytes.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.BlockPair.getErrorCorrectionBytes">
<summary>
Gets the error correction bytes.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.ByteMatrix.getWidth">
<summary>
Gets the width of the matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.ByteMatrix.getHeight">
<summary>
Gets the height of the matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.ByteMatrix.getArray">
<summary>
Gets the internal representation of the matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.ByteMatrix.getBytes">
</member>
<member name="M:BaconQrCode.Encoder.ByteMatrix.get(System.Int64,System.Int64)">
<summary>
Gets the byte for a specific position.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.ByteMatrix.set(System.Int64,System.Int64,System.Int64)">
<summary>
Sets the byte for a specific position.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.ByteMatrix.clear(System.Int64)">
<summary>
Clears the matrix with a specific value.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.ByteMatrix.__toString">
<summary>
Returns a string representation of the matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.encode(Pchp.Core.Context,Pchp.Core.PhpString,BaconQrCode.Common.ErrorCorrectionLevel,Pchp.Core.PhpString,BaconQrCode.Common.Version)">
<summary>
Encodes "content" with the error correction level "ecLevel".
</summary>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.getAlphanumericCode(Pchp.Core.Context,System.Int64)">
<summary>
Gets the alphanumeric code for a byte.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.chooseMode(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Chooses the best mode for a given content.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.calculateMaskPenalty(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Calculates the mask penalty for a matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.isOnlyDoubleByteKanji(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Checks if content only consists of double-byte kanji characters.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.chooseMaskPattern(Pchp.Core.Context,BaconQrCode.Common.BitArray,BaconQrCode.Common.ErrorCorrectionLevel,BaconQrCode.Common.Version,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Chooses the best mask pattern for a matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.chooseVersion(Pchp.Core.Context,System.Int64,BaconQrCode.Common.ErrorCorrectionLevel)">
<summary>
Chooses the best version for the input.
</summary>
<exception cref="WriterException">if data is too big</exception>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.terminateBits(Pchp.Core.Context,System.Int64,BaconQrCode.Common.BitArray)">
<summary>
Terminates the bits in a bit array.
</summary>
<exception cref="WriterException">if data bits cannot fit in the QR code</exception>
<exception cref="WriterException">if bits size does not equal the capacity</exception>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.getNumDataBytesAndNumEcBytesForBlockId(Pchp.Core.Context,System.Int64,System.Int64,System.Int64,System.Int64)">
<summary>
Gets number of data- and EC bytes for a block ID.
</summary>
<exception cref="WriterException">if block ID is too large</exception>
<exception cref="WriterException">if EC bytes mismatch</exception>
<exception cref="WriterException">if RS blocks mismatch</exception>
<exception cref="WriterException">if total bytes mismatch</exception>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.interleaveWithEcBytes(Pchp.Core.Context,BaconQrCode.Common.BitArray,System.Int64,System.Int64,System.Int64)">
<summary>
Interleaves data with EC bytes.
</summary>
<exception cref="WriterException">if number of bits and data bytes does not match</exception>
<exception cref="WriterException">if data bytes does not match offset</exception>
<exception cref="WriterException">if an interleaving error occurs</exception>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.generateEcBytes(Pchp.Core.Context,Pchp.Library.Spl.SplFixedArray,System.Int64)">
<summary>
Generates EC bytes for given data.
</summary>
<param name="dataBytes" type="SplFixedArray&lt;int&gt;"></param>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.getCodec(Pchp.Core.Context,System.Int64,System.Int64)">
<summary>
Gets an RS codec and caches it.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.appendModeInfo(Pchp.Core.Context,BaconQrCode.Common.Mode,BaconQrCode.Common.BitArray)">
<summary>
Appends mode information to a bit array.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.appendLengthInfo(Pchp.Core.Context,System.Int64,BaconQrCode.Common.Version,BaconQrCode.Common.Mode,BaconQrCode.Common.BitArray)">
<summary>
Appends length information to a bit array.
</summary>
<exception cref="WriterException">if num letters is bigger than expected</exception>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.appendBytes(Pchp.Core.Context,Pchp.Core.PhpString,BaconQrCode.Common.Mode,BaconQrCode.Common.BitArray,Pchp.Core.PhpString)">
<summary>
Appends bytes to a bit array in a specific mode.
</summary>
<exception cref="WriterException">if an invalid mode was supplied</exception>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.appendNumericBytes(Pchp.Core.Context,Pchp.Core.PhpString,BaconQrCode.Common.BitArray)">
<summary>
Appends numeric bytes to a bit array.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.appendAlphanumericBytes(Pchp.Core.Context,Pchp.Core.PhpString,BaconQrCode.Common.BitArray)">
<summary>
Appends alpha-numeric bytes to a bit array.
</summary>
<exception cref="WriterException">if an invalid alphanumeric code was found</exception>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.append8BitBytes(Pchp.Core.Context,Pchp.Core.PhpString,BaconQrCode.Common.BitArray,Pchp.Core.PhpString)">
<summary>
Appends regular 8-bit bytes to a bit array.
</summary>
<exception cref="WriterException">if content cannot be encoded to target encoding</exception>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.appendKanjiBytes(Pchp.Core.Context,Pchp.Core.PhpString,BaconQrCode.Common.BitArray)">
<summary>
Appends KANJI bytes to a bit array.
</summary>
<exception cref="WriterException">if content does not seem to be encoded in SHIFT-JIS</exception>
<exception cref="WriterException">if an invalid byte sequence occurs</exception>
</member>
<member name="M:BaconQrCode.Encoder.Encoder.appendEci(Pchp.Core.Context,BaconQrCode.Common.CharacterSetEci,BaconQrCode.Common.BitArray)">
<summary>
Appends ECI information to a bit array.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MaskUtil.applyMaskPenaltyRule1(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Applies mask penalty rule 1 and returns the penalty.
Finds repetitive cells with the same color and gives penalty to them.
Example: 00000 or 11111.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MaskUtil.applyMaskPenaltyRule2(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Applies mask penalty rule 2 and returns the penalty.
Finds 2x2 blocks with the same color and gives penalty to them. This is
actually equivalent to the spec's rule, which is to find MxN blocks and
give a penalty proportional to (M-1)x(N-1), because this is the number of
2x2 blocks inside such a block.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MaskUtil.applyMaskPenaltyRule3(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Applies mask penalty rule 3 and returns the penalty.
Finds consecutive cells of 00001011101 or 10111010000, and gives penalty
to them. If we find patterns like 000010111010000, we give penalties
twice (i.e. 40 * 2).
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MaskUtil.applyMaskPenaltyRule4(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Applies mask penalty rule 4 and returns the penalty.
Calculates the ratio of dark cells and gives penalty if the ratio is far
from 50%. It gives 10 penalty for 5% distance.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MaskUtil.getDataMaskBit(Pchp.Core.Context,System.Int64,System.Int64,System.Int64)">
<summary>
Returns the mask bit for "getMaskPattern" at "x" and "y".
See 8.8 of JISX0510:2004 for mask pattern conditions.
</summary>
<exception cref="InvalidArgumentException">if an invalid mask pattern was supplied</exception>
</member>
<member name="M:BaconQrCode.Encoder.MaskUtil.applyMaskPenaltyRule1Internal(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix,System.Boolean)">
<summary>
Helper function for applyMaskPenaltyRule1.
We need this for doing this calculation in both vertical and horizontal
orders respectively.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.clearMatrix(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Clears a given matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.buildMatrix(Pchp.Core.Context,BaconQrCode.Common.BitArray,BaconQrCode.Common.ErrorCorrectionLevel,BaconQrCode.Common.Version,System.Int64,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Builds a complete matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.removePositionDetectionPatterns(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Removes the position detection patterns from a matrix.
This can be useful if you need to render those patterns separately.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.embedTypeInfo(Pchp.Core.Context,BaconQrCode.Common.ErrorCorrectionLevel,System.Int64,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds type information into a matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.makeTypeInfoBits(Pchp.Core.Context,BaconQrCode.Common.ErrorCorrectionLevel,System.Int64,BaconQrCode.Common.BitArray)">
<summary>
Generates type information bits and appends them to a bit array.
</summary>
<exception cref="RuntimeException">if bit array resulted in invalid size</exception>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.maybeEmbedVersionInfo(Pchp.Core.Context,BaconQrCode.Common.Version,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds version information if required.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.makeVersionInfoBits(Pchp.Core.Context,BaconQrCode.Common.Version,BaconQrCode.Common.BitArray)">
<summary>
Generates version information bits and appends them to a bit array.
</summary>
<exception cref="RuntimeException">if bit array resulted in invalid size</exception>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.calculateBchCode(Pchp.Core.Context,System.Int64,System.Int64)">
<summary>
Calculates the BCH code for a value and a polynomial.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.findMsbSet(Pchp.Core.Context,System.Int64)">
<summary>
Finds and MSB set.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.embedBasicPatterns(Pchp.Core.Context,BaconQrCode.Common.Version,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds basic patterns into a matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.embedPositionDetectionPatternsAndSeparators(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds position detection patterns and separators into a byte matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.embedPositionDetectionPattern(Pchp.Core.Context,System.Int64,System.Int64,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds a single position detection pattern into a byte matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.embedHorizontalSeparationPattern(Pchp.Core.Context,System.Int64,System.Int64,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds a single horizontal separation pattern.
</summary>
<exception cref="RuntimeException">if a byte was already set</exception>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.embedVerticalSeparationPattern(Pchp.Core.Context,System.Int64,System.Int64,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds a single vertical separation pattern.
</summary>
<exception cref="RuntimeException">if a byte was already set</exception>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.embedDarkDotAtLeftBottomCorner(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds a dot at the left bottom corner.
</summary>
<exception cref="RuntimeException">if a byte was already set to 0</exception>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.maybeEmbedPositionAdjustmentPatterns(Pchp.Core.Context,BaconQrCode.Common.Version,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds position adjustment patterns if required.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.embedPositionAdjustmentPattern(Pchp.Core.Context,System.Int64,System.Int64,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds a single position adjustment pattern.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.embedTimingPatterns(Pchp.Core.Context,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds timing patterns into a matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.MatrixUtil.embedDataBits(Pchp.Core.Context,BaconQrCode.Common.BitArray,System.Int64,BaconQrCode.Encoder.ByteMatrix)">
<summary>
Embeds "dataBits" using "getMaskPattern".
For debugging purposes, it skips masking process if "getMaskPattern" is -1. See 8.7 of JISX0510:2004 (p.38) for
how to embed data bits.
</summary>
<exception cref="WriterException">if not all bits could be consumed</exception>
</member>
<member name="M:BaconQrCode.Encoder.QrCode.getMode">
<summary>
Gets the mode.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.QrCode.getErrorCorrectionLevel">
<summary>
Gets the EC level.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.QrCode.getVersion">
<summary>
Gets the version.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.QrCode.getMaskPattern">
<summary>
Gets the mask pattern.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.QrCode.getMatrix">
<summary>
Gets the matrix.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.QrCode.isValidMaskPattern(Pchp.Core.Context,System.Int64)">
<summary>
Validates whether a mask pattern is valid.
</summary>
</member>
<member name="M:BaconQrCode.Encoder.QrCode.__toString">
<summary>
Returns a string representation of the QR code.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Color.Alpha.__construct(System.Int64,BaconQrCode.Renderer.Color.ColorInterface)">
<param name="alpha" type="int">the alpha value, 0 to 100</param>
</member>
<member name="M:BaconQrCode.Renderer.Color.Cmyk.__construct(System.Int64,System.Int64,System.Int64,System.Int64)">
<param name="cyan" type="int">the cyan amount, 0 to 100</param>
<param name="magenta" type="int">the magenta amount, 0 to 100</param>
<param name="yellow" type="int">the yellow amount, 0 to 100</param>
<param name="black" type="int">the black amount, 0 to 100</param>
</member>
<member name="M:BaconQrCode.Renderer.Color.ColorInterface.toRgb">
<summary>
Converts the color to RGB.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Color.ColorInterface.toCmyk">
<summary>
Converts the color to CMYK.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Color.ColorInterface.toGray">
<summary>
Converts the color to gray.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Color.Gray.__construct(System.Int64)">
<param name="gray" type="int">the gray value between 0 (black) and 100 (white)</param>
</member>
<member name="M:BaconQrCode.Renderer.Color.Rgb.__construct(System.Int64,System.Int64,System.Int64)">
<param name="red" type="int">the red amount of the color, 0 to 255</param>
<param name="green" type="int">the green amount of the color, 0 to 255</param>
<param name="blue" type="int">the blue amount of the color, 0 to 255</param>
</member>
<member name="M:BaconQrCode.Renderer.Eye.EyeInterface.getExternalPath">
<summary>
Returns the path of the external eye element.
The path origin point (0, 0) must be anchored at the middle of the path.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Eye.EyeInterface.getInternalPath">
<summary>
Returns the path of the internal eye element.
The path origin point (0, 0) must be anchored at the middle of the path.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Image.ImageBackEndInterface.new(System.Int64,BaconQrCode.Renderer.Color.ColorInterface)">
<summary>
Starts a new image.
If a previous image was already started, previous data get erased.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Image.ImageBackEndInterface.scale(System.Double)">
<summary>
Transforms all following drawing operation coordinates by scaling them by a given factor.
</summary>
<exception cref="RuntimeException">if no image was started yet.</exception>
</member>
<member name="M:BaconQrCode.Renderer.Image.ImageBackEndInterface.translate(System.Double,System.Double)">
<summary>
Transforms all following drawing operation coordinates by translating them by a given amount.
</summary>
<exception cref="RuntimeException">if no image was started yet.</exception>
</member>
<member name="M:BaconQrCode.Renderer.Image.ImageBackEndInterface.rotate(System.Int64)">
<summary>
Transforms all following drawing operation coordinates by rotating them by a given amount.
</summary>
<exception cref="RuntimeException">if no image was started yet.</exception>
</member>
<member name="M:BaconQrCode.Renderer.Image.ImageBackEndInterface.push">
<summary>
Pushes the current coordinate transformation onto a stack.
</summary>
<exception cref="RuntimeException">if no image was started yet.</exception>
</member>
<member name="M:BaconQrCode.Renderer.Image.ImageBackEndInterface.pop">
<summary>
Pops the last coordinate transformation from a stack.
</summary>
<exception cref="RuntimeException">if no image was started yet.</exception>
</member>
<member name="M:BaconQrCode.Renderer.Image.ImageBackEndInterface.drawPathWithColor(BaconQrCode.Renderer.Path.Path,BaconQrCode.Renderer.Color.ColorInterface)">
<summary>
Draws a path with a given color.
</summary>
<exception cref="RuntimeException">if no image was started yet.</exception>
</member>
<member name="M:BaconQrCode.Renderer.Image.ImageBackEndInterface.drawPathWithGradient(BaconQrCode.Renderer.Path.Path,BaconQrCode.Renderer.RendererStyle.Gradient,System.Double,System.Double,System.Double,System.Double)">
<summary>
Draws a path with a given gradient which spans the box described by the position and size.
</summary>
<exception cref="RuntimeException">if no image was started yet.</exception>
</member>
<member name="M:BaconQrCode.Renderer.Image.ImageBackEndInterface.done">
<summary>
Ends the image drawing operation and returns the resulting blob.
This should reset the state of the back end and thus this method should only be callable once per image.
</summary>
<exception cref="RuntimeException">if no image was started yet.</exception>
</member>
<member name="M:BaconQrCode.Renderer.Image.TransformationMatrix.apply(System.Double,System.Double)">
<summary>
Applies this matrix onto a point and returns the resulting viewport point.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.ImageRenderer.render(BaconQrCode.Encoder.QrCode)">
<exception cref="InvalidArgumentException">if matrix width doesn't match height</exception>
</member>
<member name="M:BaconQrCode.Renderer.Module.EdgeIterator.Edge.getPoints">
</member>
<member name="M:BaconQrCode.Renderer.Module.EdgeIterator.EdgeIterator.getIterator">
</member>
<member name="M:BaconQrCode.Renderer.Module.EdgeIterator.EdgeIterator.findNext(System.Int64,System.Int64)">
</member>
<member name="M:BaconQrCode.Renderer.Module.EdgeIterator.EdgeIterator.pointOf(System.Int64)">
</member>
<member name="M:BaconQrCode.Renderer.Path.Close.translate(System.Double,System.Double)">
</member>
<member name="M:BaconQrCode.Renderer.Path.Curve.translate(System.Double,System.Double)">
</member>
<member name="M:BaconQrCode.Renderer.Path.EllipticArc.translate(System.Double,System.Double)">
</member>
<member name="M:BaconQrCode.Renderer.Path.EllipticArc.toCurves(System.Double,System.Double)">
<summary>
Converts the elliptic arc to multiple curves.
Since not all image back ends support elliptic arcs, this method allows to convert the arc into multiple curves
resembling the same result.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Path.EllipticArc.createCurves(System.Double,Pchp.Core.PhpValue)">
</member>
<member name="M:BaconQrCode.Renderer.Path.EllipticArc.calculateCenterPointParameters(System.Double,System.Double,System.Double)">
</member>
<member name="M:BaconQrCode.Renderer.Path.EllipticArc.point(Pchp.Core.Context,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
</member>
<member name="M:BaconQrCode.Renderer.Path.EllipticArc.derivative(Pchp.Core.Context,System.Double,System.Double,System.Double,System.Double)">
</member>
<member name="M:BaconQrCode.Renderer.Path.Line.translate(System.Double,System.Double)">
</member>
<member name="M:BaconQrCode.Renderer.Path.Move.translate(System.Double,System.Double)">
</member>
<member name="M:BaconQrCode.Renderer.Path.OperationInterface.translate(System.Double,System.Double)">
<summary>
Translates the operation's coordinates.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Path.Path.move(System.Double,System.Double)">
<summary>
Moves the drawing operation to a certain position.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Path.Path.line(System.Double,System.Double)">
<summary>
Draws a line from the current position to another position.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Path.Path.ellipticArc(System.Double,System.Double,System.Double,System.Boolean,System.Boolean,System.Double,System.Double)">
<summary>
Draws an elliptic arc from the current position to another position.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Path.Path.curve(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
<summary>
Draws a curve from the current position to another position.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Path.Path.close">
<summary>
Closes a sub-path.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Path.Path.append(BaconQrCode.Renderer.Path.Path)">
<summary>
Appends another path to this one.
</summary>
</member>
<member name="M:BaconQrCode.Renderer.Path.Path.getIterator">
</member>
<member name="M:BaconQrCode.Renderer.PlainTextRenderer.render(BaconQrCode.Encoder.QrCode)">
<exception cref="InvalidArgumentException">if matrix width doesn't match height</exception>
</member>
<member name="M:BaconQrCode.Writer.__construct(BaconQrCode.Renderer.RendererInterface)">
<summary>
Creates a new writer with a specific renderer.
</summary>
</member>
<member name="M:BaconQrCode.Writer.writeString(Pchp.Core.PhpString,Pchp.Core.PhpString,BaconQrCode.Common.ErrorCorrectionLevel,BaconQrCode.Common.Version)">
<summary>
Writes QR code and returns it as string.
Content is a string which *should* be encoded in UTF-8, in case there are
non ASCII-characters present.
</summary>
<exception cref="InvalidArgumentException">if the content is empty</exception>
</member>
<member name="M:BaconQrCode.Writer.writeFile(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,BaconQrCode.Common.ErrorCorrectionLevel,BaconQrCode.Common.Version)">
<summary>
Writes QR code to a file.
</summary>
</member>
<member name="M:ComposerAutoloaderInit0f004dd85c03cdf085379b6e359f9671.getLoader(Pchp.Core.Context)">
</member>
<member name="M:Composer.Autoload.ClassLoader.__construct(Pchp.Core.PhpValue)">
<param name="vendorDir" type="?string"></param>
</member>
<member name="M:Composer.Autoload.ClassLoader.getPrefixes">
</member>
<member name="M:Composer.Autoload.ClassLoader.getPrefixesPsr4">
</member>
<member name="M:Composer.Autoload.ClassLoader.getFallbackDirs">
</member>
<member name="M:Composer.Autoload.ClassLoader.getFallbackDirsPsr4">
</member>
<member name="M:Composer.Autoload.ClassLoader.getClassMap">
<returns>Array of classname =&gt; path</returns>
</member>
<member name="M:Composer.Autoload.ClassLoader.addClassMap(Pchp.Core.PhpArray)">
<param name="classMap" type="string[]">Class to filename map</param>
</member>
<member name="M:Composer.Autoload.ClassLoader.add(Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Registers a set of PSR-0 directories for a given prefix, either
appending or prepending to the ones previously set for this prefix.
</summary>
<param name="prefix" type="string">The prefix</param>
<param name="paths" type="string[]|string">The PSR-0 root directories</param>
<param name="prepend" type="bool">Whether to prepend the directories</param>
</member>
<member name="M:Composer.Autoload.ClassLoader.addPsr4(Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Registers a set of PSR-4 directories for a given namespace, either
appending or prepending to the ones previously set for this namespace.
</summary>
<param name="prefix" type="string">The prefix/namespace, with trailing '\\'</param>
<param name="paths" type="string[]|string">The PSR-4 base directories</param>
<param name="prepend" type="bool">Whether to prepend the directories</param>
</member>
<member name="M:Composer.Autoload.ClassLoader.set(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Registers a set of PSR-0 directories for a given prefix,
replacing any others previously set for this prefix.
</summary>
<param name="prefix" type="string">The prefix</param>
<param name="paths" type="string[]|string">The PSR-0 base directories</param>
</member>
<member name="M:Composer.Autoload.ClassLoader.setPsr4(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Registers a set of PSR-4 directories for a given namespace,
replacing any others previously set for this namespace.
</summary>
<param name="prefix" type="string">The prefix/namespace, with trailing '\\'</param>
<param name="paths" type="string[]|string">The PSR-4 base directories</param>
</member>
<member name="M:Composer.Autoload.ClassLoader.setUseIncludePath(Pchp.Core.PhpValue)">
<summary>
Turns on searching the include path for class files.
</summary>
<param name="useIncludePath" type="bool"></param>
</member>
<member name="M:Composer.Autoload.ClassLoader.getUseIncludePath">
<summary>
Can be used to check if the autoloader uses the include path to check
for classes.
</summary>
</member>
<member name="M:Composer.Autoload.ClassLoader.setClassMapAuthoritative(Pchp.Core.PhpValue)">
<summary>
Turns off searching the prefix and fallback directories for classes
that have not been registered with the class map.
</summary>
<param name="classMapAuthoritative" type="bool"></param>
</member>
<member name="M:Composer.Autoload.ClassLoader.isClassMapAuthoritative">
<summary>
Should class lookup fail if not found in the current class map?
</summary>
</member>
<member name="M:Composer.Autoload.ClassLoader.setApcuPrefix(Pchp.Core.PhpValue)">
<summary>
APCu prefix to use to cache found/not-found classes, if the extension is enabled.
</summary>
<param name="apcuPrefix" type="string|null"></param>
</member>
<member name="M:Composer.Autoload.ClassLoader.getApcuPrefix">
<summary>
The APCu prefix in use, or null if APCu caching is not enabled.
</summary>
</member>
<member name="M:Composer.Autoload.ClassLoader.register(Pchp.Core.PhpValue)">
<summary>
Registers this instance as an autoloader.
</summary>
<param name="prepend" type="bool">Whether to prepend the autoloader or not</param>
</member>
<member name="M:Composer.Autoload.ClassLoader.unregister">
<summary>
Unregisters this instance as an autoloader.
</summary>
</member>
<member name="M:Composer.Autoload.ClassLoader.loadClass(Pchp.Core.PhpValue)">
<summary>
Loads the given class or interface.
</summary>
<param name="class" type="string">The name of the class</param>
<returns>True if loaded, null otherwise</returns>
</member>
<member name="M:Composer.Autoload.ClassLoader.findFile(Pchp.Core.PhpValue)">
<summary>
Finds the path to the file where the class is defined.
</summary>
<param name="class" type="string">The name of the class</param>
<returns>The path if found, false otherwise</returns>
</member>
<member name="M:Composer.Autoload.ClassLoader.getRegisteredLoaders(Pchp.Core.Context)">
<summary>
Returns the currently registered loaders indexed by their corresponding vendor directories.
</summary>
</member>
<member name="M:Composer.Autoload.ClassLoader.findFileWithExtension(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="class" type="string"></param>
<param name="ext" type="string"></param>
</member>
<member name="M:Composer.InstalledVersions.getInstalledPackages(Pchp.Core.Context)">
<summary>
Returns a list of all package names which are present, either by being installed, replaced or provided
</summary>
</member>
<member name="M:Composer.InstalledVersions.getInstalledPackagesByType(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Returns a list of all package names with a specific type e.g. 'library'
</summary>
<param name="type" type="string"></param>
</member>
<member name="M:Composer.InstalledVersions.isInstalled(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Checks whether the given package is installed
This also returns true if the package name is provided or replaced by another package
</summary>
<param name="packageName" type="string"></param>
<param name="includeDevRequirements" type="bool"></param>
</member>
<member name="M:Composer.InstalledVersions.satisfies(Pchp.Core.Context,System.Object,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Checks whether the given package satisfies a version constraint
e.g. If you want to know whether version 2.3+ of package foo/bar is installed, you would call:

Composer\InstalledVersions::satisfies(new VersionParser, 'foo/bar', '^2.3')
</summary>
<param name="parser" type="VersionParser">Install composer/semver to have access to this class and functionality</param>
<param name="packageName" type="string"></param>
<param name="constraint" type="string|null">A version constraint to check for, if you pass one you have to make sure composer/semver is required by your package</param>
</member>
<member name="M:Composer.InstalledVersions.getVersionRanges(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Returns a version constraint representing all the range(s) which are installed for a given package
It is easier to use this via isInstalled() with the $constraint argument if you need to check
whether a given version of a package is installed, and not just whether it exists
</summary>
<param name="packageName" type="string"></param>
<returns>Version constraint usable with composer/semver</returns>
</member>
<member name="M:Composer.InstalledVersions.getVersion(Pchp.Core.Context,Pchp.Core.PhpValue)">
<param name="packageName" type="string"></param>
<returns>If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present</returns>
</member>
<member name="M:Composer.InstalledVersions.getPrettyVersion(Pchp.Core.Context,Pchp.Core.PhpValue)">
<param name="packageName" type="string"></param>
<returns>If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present</returns>
</member>
<member name="M:Composer.InstalledVersions.getReference(Pchp.Core.Context,Pchp.Core.PhpValue)">
<param name="packageName" type="string"></param>
<returns>If the package is being replaced or provided but is not really installed, null will be returned as reference</returns>
</member>
<member name="M:Composer.InstalledVersions.getInstallPath(Pchp.Core.Context,Pchp.Core.PhpValue)">
<param name="packageName" type="string"></param>
<returns>If the package is being replaced or provided but is not really installed, null will be returned as install path. Packages of type metapackages also have a null install path.</returns>
</member>
<member name="M:Composer.InstalledVersions.getRootPackage(Pchp.Core.Context)">
</member>
<member name="M:Composer.InstalledVersions.getRawData(Pchp.Core.Context)">
<summary>
Returns the raw installed.php data for custom implementations
</summary>
</member>
<member name="M:Composer.InstalledVersions.getAllRawData(Pchp.Core.Context)">
<summary>
Returns the raw data of all installed.php which are currently loaded for custom implementations
</summary>
</member>
<member name="M:Composer.InstalledVersions.reload(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Lets you reload the static array from another file
This is only useful for complex integrations in which a project needs to use
this class but then also needs to execute another project's autoloader in process,
and wants to ensure both projects have access to their version of installed.php.

A typical case would be PHPUnit, where it would need to make sure it reads all
the data it needs from this class, then call reload() with
`require $CWD/vendor/composer/installed.php` (or similar) as input to make sure
the project in which it runs can then also use this class safely, without
interference between PHPUnit's dependencies and the project's dependencies.
</summary>
<param name="data" type="array[]">A vendor/composer/installed.php data set</param>
</member>
<member name="M:Composer.InstalledVersions.getInstalled(Pchp.Core.Context)">
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.__construct">
<summary>
The constructor is private by default to avoid arbitrary enum creation.
When creating your own constructor for a parameterized enum, make sure to declare it as protected, so that
the static methods are able to construct it. Avoid making it public, as that would allow creation of
non-singleton enum instances.
</summary>
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.__callStatic(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString,Pchp.Core.PhpArray)">
<summary>
Magic getter which forwards all calls to {@see self::valueOf()}.
</summary>
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.valueOf(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString)">
<summary>
Returns an enum with the specified name.
The name must match exactly an identifier used to declare an enum in this type (extraneous whitespace characters
are not permitted).
</summary>
<exception cref="IllegalArgumentException">if the enum has no constant with the specified name</exception>
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.createValue(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString,System.Int64,Pchp.Core.PhpArray)">
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.values(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo)">
<summary>
Obtains all possible types defined by this enum.
</summary>
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.name">
<summary>
Returns the name of this enum constant, exactly as declared in its enum declaration.
Most programmers should use the {@see self::__toString()} method in preference to this one, as the toString
method may return a more user-friendly name. This method is designed primarily for use in specialized situations
where correctness depends on getting the exact name, which will not vary from release to release.
</summary>
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.ordinal">
<summary>
Returns the ordinal of this enumeration constant (its position in its enum declaration, where the initial
constant is assigned an ordinal of zero).
Most programmers will have no use for this method. It is designed for use by sophisticated enum-based data
structures.
</summary>
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.compareTo(DASPRiD.Enum.AbstractEnum)">
<summary>
Compares this enum with the specified object for order.
Returns negative integer, zero or positive integer as this object is less than, equal to or greater than the
specified object.

Enums are only comparable to other enums of the same type. The natural order implemented by this method is the
order in which the constants are declared.
</summary>
<exception cref="MismatchException">if the passed enum is not of the same type</exception>
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.__clone">
<summary>
Forbid cloning enums.
</summary>
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.__sleep">
<summary>
Forbid serializing enums.
</summary>
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.__wakeup">
<summary>
Forbid unserializing enums.
</summary>
</member>
<member name="M:DASPRiD.Enum.AbstractEnum.__toString">
<summary>
Turns the enum into a string representation.
You may override this method to give a more user-friendly version.
</summary>
</member>
<member name="M:DASPRiD.Enum.EnumMap.__construct(Pchp.Core.PhpString,Pchp.Core.PhpString,System.Boolean)">
<summary>
Creates a new enum map.
</summary>
<param name="keyType" type="string">the type of the keys, must extend AbstractEnum</param>
<param name="valueType" type="string">the type of the values</param>
<param name="allowNullValues" type="bool">whether to allow null values</param>
<exception cref="IllegalArgumentException">when key type does not extend AbstractEnum</exception>
</member>
<member name="M:DASPRiD.Enum.EnumMap.expect(Pchp.Core.PhpString,Pchp.Core.PhpString,System.Boolean)">
<summary>
Checks whether the map types match the supplied ones.
You should call this method when an EnumMap is passed to you and you want to ensure that it's made up of the
correct types.
</summary>
<exception cref="ExpectationException">when supplied key type mismatches local key type</exception>
<exception cref="ExpectationException">when supplied value type mismatches local value type</exception>
<exception cref="ExpectationException">when the supplied map allows null values, abut should not</exception>
</member>
<member name="M:DASPRiD.Enum.EnumMap.size">
<summary>
Returns the number of key-value mappings in this map.
</summary>
</member>
<member name="M:DASPRiD.Enum.EnumMap.containsValue(Pchp.Core.PhpValue)">
<summary>
Returns true if this map maps one or more keys to the specified value.
</summary>
</member>
<member name="M:DASPRiD.Enum.EnumMap.containsKey(DASPRiD.Enum.AbstractEnum)">
<summary>
Returns true if this map contains a mapping for the specified key.
</summary>
</member>
<member name="M:DASPRiD.Enum.EnumMap.get(DASPRiD.Enum.AbstractEnum)">
<summary>
Returns the value to which the specified key is mapped, or null if this map contains no mapping for the key.
More formally, if this map contains a mapping from a key to a value, then this method returns the value;
otherwise it returns null (there can be at most one such mapping).

A return value of null does not necessarily indicate that the map contains no mapping for the key; it's also
possible that hte map explicitly maps the key to null. The {@see self::containsKey()} operation may be used to
distinguish these two cases.
</summary>
</member>
<member name="M:DASPRiD.Enum.EnumMap.put(DASPRiD.Enum.AbstractEnum,Pchp.Core.PhpValue)">
<summary>
Associates the specified value with the specified key in this map.
If the map previously contained a mapping for this key, the old value is replaced.
</summary>
<returns>the previous value associated with the specified key, or null if there was no mapping for the key.
(a null return can also indicate that the map previously associated null with the specified key.)</returns>
<exception cref="IllegalArgumentException">when the passed values does not match the internal value type</exception>
</member>
<member name="M:DASPRiD.Enum.EnumMap.remove(DASPRiD.Enum.AbstractEnum)">
<summary>
Removes the mapping for this key frm this map if present.
</summary>
<returns>the previous value associated with the specified key, or null if there was no mapping for the key.
(a null return can also indicate that the map previously associated null with the specified key.)</returns>
</member>
<member name="M:DASPRiD.Enum.EnumMap.clear">
<summary>
Removes all mappings from this map.
</summary>
</member>
<member name="M:DASPRiD.Enum.EnumMap.equals(DASPRiD.Enum.EnumMap)">
<summary>
Compares the specified map with this map for quality.
Returns true if the two maps represent the same mappings.
</summary>
</member>
<member name="M:DASPRiD.Enum.EnumMap.values">
<summary>
Returns the values contained in this map.
The array will contain the values in the order their corresponding keys appear in the map, which is their natural
order (the order in which the num constants are declared).
</summary>
</member>
<member name="M:DASPRiD.Enum.EnumMap.checkKeyType(DASPRiD.Enum.AbstractEnum)">
<exception cref="IllegalArgumentException">when the passed key does not match the internal key type</exception>
</member>
<member name="M:DASPRiD.Enum.NullValue.__clone">
<summary>
Forbid cloning enums.
</summary>
</member>
<member name="M:DASPRiD.Enum.NullValue.__sleep">
<summary>
Forbid serializing enums.
</summary>
</member>
<member name="M:DASPRiD.Enum.NullValue.__wakeup">
<summary>
Forbid unserializing enums.
</summary>
</member>
<member name="M:Endroid.QrCode.Builder.Builder.writerOptions(Pchp.Core.PhpArray)">
<param name="writerOptions" type="array&lt;mixed&gt;"></param>
</member>
<member name="M:Endroid.QrCode.Builder.Builder.buildObject(Pchp.Core.PhpString,Pchp.Core.PhpValue)">
</member>
<member name="M:Endroid.QrCode.Builder.BuilderInterface.writerOptions(Pchp.Core.PhpArray)">
<param name="writerOptions" type="array&lt;mixed&gt;"></param>
</member>
<member name="M:Endroid.QrCode.Color.ColorInterface.toArray">
<returns>array&lt;string, int&gt;</returns>
</member>
<member name="M:Endroid.QrCode.ImageData.LogoImageData.__construct(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpString,System.Int64,System.Int64,System.Boolean)">
<param name="image" type="mixed"></param>
</member>
<member name="M:Endroid.QrCode.ImageData.LogoImageData.getImage">
</member>
<member name="M:Endroid.QrCode.Label.Margin.Margin.toArray">
<returns>array&lt;string, int&gt;</returns>
</member>
<member name="M:Endroid.QrCode.Label.Margin.MarginInterface.toArray">
<returns>array&lt;string, int&gt;</returns>
</member>
<member name="M:Endroid.QrCode.Matrix.Matrix.__construct(Pchp.Core.PhpArray,System.Int64,System.Int64,Endroid.QrCode.RoundBlockSizeMode.RoundBlockSizeModeInterface)">
<param name="blockValues" type="array&lt;array&lt;int&gt;&gt;"></param>
</member>
<member name="M:Endroid.QrCode.Writer.ConsoleWriter.write(Endroid.QrCode.QrCodeInterface,Endroid.QrCode.Logo.LogoInterface,Endroid.QrCode.Label.LabelInterface,Pchp.Core.PhpValue)">
<summary>
{@inheritDoc}
</summary>
</member>
<member name="M:Endroid.QrCode.Writer.Result.DebugResult.__construct(Endroid.QrCode.Matrix.MatrixInterface,Endroid.QrCode.QrCodeInterface,Endroid.QrCode.Logo.LogoInterface,Endroid.QrCode.Label.LabelInterface,Pchp.Core.PhpArray)">
<param name="options" type="array&lt;mixed&gt;"></param>
</member>
<member name="M:Endroid.QrCode.Writer.Result.EpsResult.__construct(Endroid.QrCode.Matrix.MatrixInterface,Pchp.Core.PhpArray)">
<param name="lines" type="array&lt;string&gt;"></param>
</member>
<member name="M:Endroid.QrCode.Writer.Result.PngResult.__construct(Endroid.QrCode.Matrix.MatrixInterface,Pchp.Core.PhpValue)">
<param name="image" type="mixed"></param>
</member>
<member name="M:Endroid.QrCode.Writer.Result.PngResult.getImage">
</member>
<member name="M:Endroid.QrCode.Writer.SvgWriter.addLogo(Endroid.QrCode.Logo.LogoInterface,Endroid.QrCode.Writer.Result.SvgResult,Pchp.Core.PhpArray)">
<param name="options" type="array&lt;mixed&gt;"></param>
</member>
<member name="M:Endroid.QrCode.Writer.WriterInterface.write(Endroid.QrCode.QrCodeInterface,Endroid.QrCode.Logo.LogoInterface,Endroid.QrCode.Label.LabelInterface,Pchp.Core.PhpArray)">
<param name="options" type="array&lt;mixed&gt;"></param>
</member>
<member name="M:GuzzleHttp.BodySummarizer.summarize(Psr.Http.Message.MessageInterface)">
<summary>
Returns a summarized message body.
</summary>
</member>
<member name="M:GuzzleHttp.BodySummarizerInterface.summarize(Psr.Http.Message.MessageInterface)">
<summary>
Returns a summarized message body.
</summary>
</member>
<member name="M:GuzzleHttp.Client.__construct(Pchp.Core.PhpArray)">
<summary>
Clients accept an array of constructor parameters.
Here's an example of creating a client using a base_uri and an array of
default request options to apply to each request:

$client = new Client([
'base_uri'        =&gt; 'http://www.foo.com/1.0/',
'timeout'         =&gt; 0,
'allow_redirects' =&gt; false,
'proxy'           =&gt; '192.168.16.1:10'
]);

Client configuration settings include the following options:

- handler: (callable) Function that transfers HTTP requests over the
wire. The function is called with a Psr7\Http\Message\RequestInterface
and array of transfer options, and must return a
GuzzleHttp\Promise\PromiseInterface that is fulfilled with a
Psr7\Http\Message\ResponseInterface on success.
If no handler is provided, a default handler will be created
that enables all of the request options below by attaching all of the
default middleware to the handler.
- base_uri: (string|UriInterface) Base URI of the client that is merged
into relative URIs. Can be a string or instance of UriInterface.
- **: any request option
</summary>
<param name="config" type="array">Client configuration settings.</param>
</member>
<member name="M:GuzzleHttp.Client.__call(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="method" type="string"></param>
<param name="args" type="array"></param>
</member>
<member name="M:GuzzleHttp.Client.sendAsync(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Asynchronously send an HTTP request.
</summary>
<param name="options" type="array">Request options to apply to the given
request and to the transfer. See \GuzzleHttp\RequestOptions.</param>
</member>
<member name="M:GuzzleHttp.Client.send(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Send an HTTP request.
</summary>
<param name="options" type="array">Request options to apply to the given
request and to the transfer. See \GuzzleHttp\RequestOptions.</param>
</member>
<member name="M:GuzzleHttp.Client.sendRequest(Psr.Http.Message.RequestInterface)">
<summary>
The HttpClient PSR (PSR-18) specify this method.
</summary>
</member>
<member name="M:GuzzleHttp.Client.requestAsync(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an asynchronous HTTP request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well. Use an array to provide a URL
template and additional variables to use in the URL template expansion.
</summary>
<param name="method" type="string">HTTP method</param>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply. See \GuzzleHttp\RequestOptions.</param>
</member>
<member name="M:GuzzleHttp.Client.request(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an HTTP request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well.
</summary>
<param name="method" type="string">HTTP method.</param>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply. See \GuzzleHttp\RequestOptions.</param>
</member>
<member name="M:GuzzleHttp.Client.getConfig(Pchp.Core.PhpValue)">
<summary>
Get a client configuration option.
These options include default request options of the client, a "handler"
(if utilized by the concrete client), and a "base_uri" if utilized by
the concrete client.
</summary>
<param name="option" type="string|null">The config option to retrieve.</param>
</member>
<member name="M:GuzzleHttp.Client.configureDefaults(Pchp.Core.PhpArray)">
<summary>
Configures the default options for a client.
</summary>
</member>
<member name="M:GuzzleHttp.Client.prepareDefaults(Pchp.Core.PhpArray)">
<summary>
Merges default options into the array.
</summary>
<param name="options" type="array">Options to modify by reference</param>
</member>
<member name="M:GuzzleHttp.Client.transfer(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Transfers the given request and applies request options.
The URI of the request is not modified and the request options are used
as-is without merging in default options.
</summary>
<param name="options" type="array">See \GuzzleHttp\RequestOptions.</param>
</member>
<member name="M:GuzzleHttp.Client.applyOptions(Psr.Http.Message.RequestInterface,Pchp.Core.PhpAlias)">
<summary>
Applies the array of request options to a request.
</summary>
</member>
<member name="M:GuzzleHttp.Client.invalidBody">
<summary>
Return an InvalidArgumentException with pre-set message.
</summary>
</member>
<member name="M:GuzzleHttp.ClientInterface.send(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Send an HTTP request.
</summary>
<param name="request" type="RequestInterface">Request to send</param>
<param name="options" type="array">Request options to apply to the given
request and to the transfer.</param>
</member>
<member name="M:GuzzleHttp.ClientInterface.sendAsync(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Asynchronously send an HTTP request.
</summary>
<param name="request" type="RequestInterface">Request to send</param>
<param name="options" type="array">Request options to apply to the given
request and to the transfer.</param>
</member>
<member name="M:GuzzleHttp.ClientInterface.request(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an HTTP request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well.
</summary>
<param name="method" type="string">HTTP method.</param>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientInterface.requestAsync(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an asynchronous HTTP request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well. Use an array to provide a URL
template and additional variables to use in the URL template expansion.
</summary>
<param name="method" type="string">HTTP method</param>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientInterface.getConfig(Pchp.Core.PhpValue)">
<summary>
Get a client configuration option.
These options include default request options of the client, a "handler"
(if utilized by the concrete client), and a "base_uri" if utilized by
the concrete client.
</summary>
<param name="option" type="string|null">The config option to retrieve.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.request(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an HTTP request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well.
</summary>
<param name="method" type="string">HTTP method.</param>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.get(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an HTTP GET request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.head(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an HTTP HEAD request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.put(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an HTTP PUT request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.post(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an HTTP POST request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.patch(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an HTTP PATCH request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.delete(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an HTTP DELETE request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.requestAsync(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an asynchronous HTTP request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well. Use an array to provide a URL
template and additional variables to use in the URL template expansion.
</summary>
<param name="method" type="string">HTTP method</param>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.getAsync(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an asynchronous HTTP GET request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well. Use an array to provide a URL
template and additional variables to use in the URL template expansion.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.headAsync(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an asynchronous HTTP HEAD request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well. Use an array to provide a URL
template and additional variables to use in the URL template expansion.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.putAsync(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an asynchronous HTTP PUT request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well. Use an array to provide a URL
template and additional variables to use in the URL template expansion.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.postAsync(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an asynchronous HTTP POST request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well. Use an array to provide a URL
template and additional variables to use in the URL template expansion.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.patchAsync(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an asynchronous HTTP PATCH request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well. Use an array to provide a URL
template and additional variables to use in the URL template expansion.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.ClientTrait`1`1.deleteAsync(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create and send an asynchronous HTTP DELETE request.
Use an absolute path to override the base path of the client, or a
relative path to append to the base path of the client. The URL can
contain the query string as well. Use an array to provide a URL
template and additional variables to use in the URL template expansion.
</summary>
<param name="uri" type="string|UriInterface">URI object or string.</param>
<param name="options" type="array">Request options to apply.</param>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.__construct(System.Boolean,Pchp.Core.PhpArray)">
<param name="strictMode" type="bool">Set to true to throw exceptions when invalid
cookies are added to the cookie jar.</param>
<param name="cookieArray" type="array">Array of SetCookie objects or a hash of
arrays that can be used with the SetCookie
constructor</param>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.fromArray(Pchp.Core.Context,Pchp.Core.PhpArray,Pchp.Core.PhpString)">
<summary>
Create a new Cookie jar from an associative array and domain.
</summary>
<param name="cookies" type="array">Cookies to create the jar from</param>
<param name="domain" type="string">Domain to set the cookies to</param>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.shouldPersist(Pchp.Core.Context,GuzzleHttp.Cookie.SetCookie,System.Boolean)">
<summary>
Evaluate if this cookie should be persisted to storage
that survives between requests.
</summary>
<param name="cookie" type="SetCookie">Being evaluated.</param>
<param name="allowSessionCookies" type="bool">If we should persist session cookies</param>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.getCookieByName(Pchp.Core.PhpString)">
<summary>
Finds and returns the cookie based on the name
</summary>
<param name="name" type="string">cookie name to search for</param>
<returns>cookie that was found or null if not found</returns>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.toArray">
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.clear(Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.clearSessionCookies">
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.setCookie(GuzzleHttp.Cookie.SetCookie)">
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.getIterator">
<returns>\ArrayIterator&lt;int, SetCookie&gt;</returns>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.getCookiePathFromRequest(Psr.Http.Message.RequestInterface)">
<summary>
Computes cookie path following RFC 6265 section 5.1.4
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJar.removeCookieIfEmpty(GuzzleHttp.Cookie.SetCookie)">
<summary>
If a cookie already exists and the server asks to set it again with a
null value, the cookie must be deleted.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJarInterface.withCookieHeader(Psr.Http.Message.RequestInterface)">
<summary>
Create a request with added cookie headers.
If no matching cookies are found in the cookie jar, then no Cookie
header is added to the request and the same request is returned.
</summary>
<param name="request" type="RequestInterface">Request object to modify.</param>
<returns>returns the modified request.</returns>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJarInterface.extractCookies(Psr.Http.Message.RequestInterface,Psr.Http.Message.ResponseInterface)">
<summary>
Extract cookies from an HTTP response and store them in the CookieJar.
</summary>
<param name="request" type="RequestInterface">Request that was sent</param>
<param name="response" type="ResponseInterface">Response that was received</param>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJarInterface.setCookie(GuzzleHttp.Cookie.SetCookie)">
<summary>
Sets a cookie in the cookie jar.
</summary>
<param name="cookie" type="SetCookie">Cookie to set.</param>
<returns>Returns true on success or false on failure</returns>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJarInterface.clear(Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Remove cookies currently held in the cookie jar.
Invoking this method without arguments will empty the whole cookie jar.
If given a $domain argument only cookies belonging to that domain will
be removed. If given a $domain and $path argument, cookies belonging to
the specified path within that domain are removed. If given all three
arguments, then the cookie with the specified name, path and domain is
removed.
</summary>
<param name="domain" type="string|null">Clears cookies matching a domain</param>
<param name="path" type="string|null">Clears cookies matching a domain and path</param>
<param name="name" type="string|null">Clears cookies matching a domain, path, and name</param>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJarInterface.clearSessionCookies">
<summary>
Discard all sessions cookies.
Removes cookies that don't have an expire field or a have a discard
field set to true. To be called when the user agent shuts down according
to RFC 2965.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.CookieJarInterface.toArray">
<summary>
Converts the cookie jar to an array.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.FileCookieJar.__construct(Pchp.Core.PhpString,System.Boolean)">
<summary>
Create a new FileCookieJar object
</summary>
<param name="cookieFile" type="string">File to store the cookie data</param>
<param name="storeSessionCookies" type="bool">Set to true to store session cookies
in the cookie jar.</param>
<exception cref="RuntimeException">if the file cannot be found or created</exception>
</member>
<member name="M:GuzzleHttp.Cookie.FileCookieJar.__destruct">
<summary>
Saves the file when shutting down
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.FileCookieJar.save(Pchp.Core.PhpString)">
<summary>
Saves the cookies to a file.
</summary>
<param name="filename" type="string">File to save</param>
<exception cref="RuntimeException">if the file cannot be found or created</exception>
</member>
<member name="M:GuzzleHttp.Cookie.FileCookieJar.load(Pchp.Core.PhpString)">
<summary>
Load cookies from a JSON formatted file.
Old cookies are kept unless overwritten by newly loaded ones.
</summary>
<param name="filename" type="string">Cookie file to load.</param>
<exception cref="RuntimeException">if the file cannot be loaded.</exception>
</member>
<member name="M:GuzzleHttp.Cookie.SessionCookieJar.__construct(Pchp.Core.PhpString,System.Boolean)">
<summary>
Create a new SessionCookieJar object
</summary>
<param name="sessionKey" type="string">Session key name to store the cookie
data in session</param>
<param name="storeSessionCookies" type="bool">Set to true to store session cookies
in the cookie jar.</param>
</member>
<member name="M:GuzzleHttp.Cookie.SessionCookieJar.__destruct">
<summary>
Saves cookies to session when shutting down
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SessionCookieJar.save">
<summary>
Save cookies to the client session
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SessionCookieJar.load">
<summary>
Load the contents of the client session into the data array
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.fromString(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Create a new SetCookie object from a string.
</summary>
<param name="cookie" type="string">Set-Cookie header string</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.__construct(Pchp.Core.PhpArray)">
<param name="data" type="array">Array of cookie data provided by a Cookie parser</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.getName">
<summary>
Get the cookie name.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.setName(Pchp.Core.PhpValue)">
<summary>
Set the cookie name.
</summary>
<param name="name" type="string">Cookie name</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.getValue">
<summary>
Get the cookie value.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.setValue(Pchp.Core.PhpValue)">
<summary>
Set the cookie value.
</summary>
<param name="value" type="string">Cookie value</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.getDomain">
<summary>
Get the domain.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.setDomain(Pchp.Core.PhpValue)">
<summary>
Set the domain of the cookie.
</summary>
<param name="domain" type="string|null"></param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.getPath">
<summary>
Get the path.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.setPath(Pchp.Core.PhpValue)">
<summary>
Set the path of the cookie.
</summary>
<param name="path" type="string">Path of the cookie</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.getMaxAge">
<summary>
Maximum lifetime of the cookie in seconds.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.setMaxAge(Pchp.Core.PhpValue)">
<summary>
Set the max-age of the cookie.
</summary>
<param name="maxAge" type="int|null">Max age of the cookie in seconds</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.getExpires">
<summary>
The UNIX timestamp when the cookie Expires.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.setExpires(Pchp.Core.PhpValue)">
<summary>
Set the unix timestamp for which the cookie will expire.
</summary>
<param name="timestamp" type="int|string|null">Unix timestamp or any English textual datetime description.</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.getSecure">
<summary>
Get whether or not this is a secure cookie.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.setSecure(Pchp.Core.PhpValue)">
<summary>
Set whether or not the cookie is secure.
</summary>
<param name="secure" type="bool">Set to true or false if secure</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.getDiscard">
<summary>
Get whether or not this is a session cookie.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.setDiscard(Pchp.Core.PhpValue)">
<summary>
Set whether or not this is a session cookie.
</summary>
<param name="discard" type="bool">Set to true or false if this is a session cookie</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.getHttpOnly">
<summary>
Get whether or not this is an HTTP only cookie.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.setHttpOnly(Pchp.Core.PhpValue)">
<summary>
Set whether or not this is an HTTP only cookie.
</summary>
<param name="httpOnly" type="bool">Set to true or false if this is HTTP only</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.matchesPath(Pchp.Core.PhpString)">
<summary>
Check if the cookie matches a path value.
A request-path path-matches a given cookie-path if at least one of
the following conditions holds:

- The cookie-path and the request-path are identical.
- The cookie-path is a prefix of the request-path, and the last
character of the cookie-path is %x2F ("/").
- The cookie-path is a prefix of the request-path, and the first
character of the request-path that is not included in the cookie-
path is a %x2F ("/") character.
</summary>
<param name="requestPath" type="string">Path to check against</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.matchesDomain(Pchp.Core.PhpString)">
<summary>
Check if the cookie matches a domain value.
</summary>
<param name="domain" type="string">Domain to check against</param>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.isExpired">
<summary>
Check if the cookie is expired.
</summary>
</member>
<member name="M:GuzzleHttp.Cookie.SetCookie.validate">
<summary>
Check if the cookie is valid according to RFC 6265.
</summary>
<returns>Returns true if valid or an error message if invalid</returns>
</member>
<member name="M:GuzzleHttp.Exception.BadResponseException.hasResponse">
<summary>
Current exception and the ones that extend it will always have a response.
</summary>
</member>
<member name="M:GuzzleHttp.Exception.BadResponseException.getResponse">
<summary>
This function narrows the return type from the parent class and does not allow it to be nullable.
</summary>
</member>
<member name="M:GuzzleHttp.Exception.ConnectException.getRequest">
<summary>
Get the request that caused the exception
</summary>
</member>
<member name="M:GuzzleHttp.Exception.ConnectException.getHandlerContext">
<summary>
Get contextual information about the error from the underlying handler.
The contents of this array will vary depending on which handler you are
using. It may also be just an empty array. Relying on this data will
couple you to a specific handler, but can give more debug information
when needed.
</summary>
</member>
<member name="M:GuzzleHttp.Exception.RequestException.wrapException(Pchp.Core.Context,Psr.Http.Message.RequestInterface,Pchp.Library.Spl.Throwable)">
<summary>
Wrap non-RequestExceptions with a RequestException
</summary>
</member>
<member name="M:GuzzleHttp.Exception.RequestException.create(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Psr.Http.Message.RequestInterface,Psr.Http.Message.ResponseInterface,Pchp.Library.Spl.Throwable,Pchp.Core.PhpArray,GuzzleHttp.BodySummarizerInterface)">
<summary>
Factory method to create a new exception with a normalized error message
</summary>
<param name="request" type="RequestInterface">Request sent</param>
<param name="response" type="ResponseInterface">Response received</param>
<param name="previous" type="\Throwable|null">Previous exception</param>
<param name="handlerContext" type="array">Optional handler context</param>
<param name="bodySummarizer" type="BodySummarizerInterface|null">Optional body summarizer</param>
</member>
<member name="M:GuzzleHttp.Exception.RequestException.obfuscateUri(Pchp.Core.Context,Psr.Http.Message.UriInterface)">
<summary>
Obfuscates URI if there is a username and a password present
</summary>
</member>
<member name="M:GuzzleHttp.Exception.RequestException.getRequest">
<summary>
Get the request that caused the exception
</summary>
</member>
<member name="M:GuzzleHttp.Exception.RequestException.getResponse">
<summary>
Get the associated response
</summary>
</member>
<member name="M:GuzzleHttp.Exception.RequestException.hasResponse">
<summary>
Check if a response was received
</summary>
</member>
<member name="M:GuzzleHttp.Exception.RequestException.getHandlerContext">
<summary>
Get contextual information about the error from the underlying handler.
The contents of this array will vary depending on which handler you are
using. It may also be just an empty array. Relying on this data will
couple you to a specific handler, but can give more debug information
when needed.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlFactory.__construct(System.Int64)">
<param name="maxHandles" type="int">Maximum number of idle handles.</param>
</member>
<member name="M:GuzzleHttp.Handler.CurlFactory.finish(Pchp.Core.Context,Pchp.Core.PhpValue,GuzzleHttp.Handler.EasyHandle,GuzzleHttp.Handler.CurlFactoryInterface)">
<summary>
Completes a cURL transaction, either returning a response promise or a
rejected promise.
</summary>
<param name="factory" type="CurlFactoryInterface">Dictates how the handle is released</param>
</member>
<member name="M:GuzzleHttp.Handler.CurlFactory.finishError(Pchp.Core.Context,Pchp.Core.PhpValue,GuzzleHttp.Handler.EasyHandle,GuzzleHttp.Handler.CurlFactoryInterface)">
</member>
<member name="M:GuzzleHttp.Handler.CurlFactory.getDefaultConf(GuzzleHttp.Handler.EasyHandle)">
<returns>array&lt;int|string, mixed&gt;</returns>
</member>
<member name="M:GuzzleHttp.Handler.CurlFactory.removeHeader(Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Remove a header from the options array.
</summary>
<param name="name" type="string">Case-insensitive header to remove</param>
<param name="options" type="array">Array of options to modify</param>
</member>
<member name="M:GuzzleHttp.Handler.CurlFactory.retryFailedRewind(Pchp.Core.Context,Pchp.Core.PhpValue,GuzzleHttp.Handler.EasyHandle,Pchp.Core.PhpArray)">
<summary>
This function ensures that a response was set on a transaction. If one
was not set, then the request is retried if possible. This error
typically means you are sending a payload, curl encountered a
"Connection died, retrying a fresh connect" error, tried to rewind the
stream, and then encountered a "necessary data rewind wasn't possible"
error, causing the request to be sent through curl_multi_info_read()
without an error status.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlFactoryInterface.create(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Creates a cURL handle resource.
</summary>
<param name="request" type="RequestInterface">Request</param>
<param name="options" type="array">Transfer options</param>
<exception cref="RuntimeException">when an option cannot be applied</exception>
</member>
<member name="M:GuzzleHttp.Handler.CurlFactoryInterface.release(GuzzleHttp.Handler.EasyHandle)">
<summary>
Release an easy handle, allowing it to be reused or closed.
This function must call unset on the easy handle's "handle" property.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlHandler.__construct(Pchp.Core.PhpArray)">
<summary>
Accepts an associative array of options:
- handle_factory: Optional curl factory used to create cURL handles.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlMultiHandler.__construct(Pchp.Core.PhpArray)">
<summary>
This handler accepts the following options:
- handle_factory: An optional factory  used to create curl handles
- select_timeout: Optional timeout (in seconds) to block before timing
out while selecting curl handles. Defaults to 1 second.
- options: An associative array of CURLMOPT_* options and
corresponding values for curl_multi_setopt()
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlMultiHandler.__get(Pchp.Core.PhpValue)">
<param name="name" type="string"></param>
<exception cref="BadMethodCallException">when another field as `_mh` will be gotten</exception>
<exception cref="RuntimeException">when curl can not initialize a multi handle</exception>
</member>
<member name="M:GuzzleHttp.Handler.CurlMultiHandler.tick">
<summary>
Ticks the curl event loop.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlMultiHandler.execute">
<summary>
Runs until all outstanding connections have completed.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.CurlMultiHandler.cancel(Pchp.Core.PhpValue)">
<summary>
Cancels a handle from sending and removes references to it.
</summary>
<param name="id" type="int">Handle ID to cancel and remove.</param>
<returns>True on success, false on failure.</returns>
</member>
<member name="M:GuzzleHttp.Handler.EasyHandle.createResponse">
<summary>
Attach a response to the easy handle based on the received headers.
</summary>
<exception cref="RuntimeException">if no headers have been received or the first
header line is invalid.</exception>
</member>
<member name="M:GuzzleHttp.Handler.EasyHandle.__get(Pchp.Core.PhpValue)">
<param name="name" type="string"></param>
</member>
<member name="M:GuzzleHttp.Handler.HeaderProcessor.parseHeaders(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Returns the HTTP version, status code, reason phrase, and headers.
</summary>
<param name="headers" type="string[]"></param>
<returns>array{0:string, 1:int, 2:?string, 3:array}</returns>
</member>
<member name="M:GuzzleHttp.Handler.MockHandler.createWithMiddleware(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Creates a new MockHandler that uses the default handler stack list of
middlewares.
</summary>
<param name="queue" type="array|null">Array of responses, callables, or exceptions.</param>
<param name="onFulfilled" type="callable|null">Callback to invoke when the return value is fulfilled.</param>
<param name="onRejected" type="callable|null">Callback to invoke when the return value is rejected.</param>
</member>
<member name="M:GuzzleHttp.Handler.MockHandler.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
The passed in value must be an array of
{@see \Psr\Http\Message\ResponseInterface} objects, Exceptions,
callables, or Promises.
</summary>
<param name="onFulfilled" type="callable|null">Callback to invoke when the return value is fulfilled.</param>
<param name="onRejected" type="callable|null">Callback to invoke when the return value is rejected.</param>
</member>
<member name="M:GuzzleHttp.Handler.MockHandler.append(Pchp.Core.PhpValue[])">
<summary>
Adds one or more variadic requests, exceptions, callables, or promises
to the queue.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.MockHandler.getLastRequest">
<summary>
Get the last received request.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.MockHandler.getLastOptions">
<summary>
Get the last received request options.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.MockHandler.count">
<summary>
Returns the number of remaining items in the queue.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.MockHandler.invokeStats(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray,Psr.Http.Message.ResponseInterface,Pchp.Core.PhpValue)">
<param name="reason" type="mixed">Promise or reason.</param>
</member>
<member name="M:GuzzleHttp.Handler.Proxy.wrapSync(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Sends synchronous requests to a specific handler while sending all other
requests to another handler.
</summary>
<returns>callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface Returns the composed handler.</returns>
</member>
<member name="M:GuzzleHttp.Handler.Proxy.wrapStreaming(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Sends streaming requests to a streaming compatible handler while sending
all other requests to a default handler.
This, for example, could be useful for taking advantage of the
performance benefits of curl while still supporting true streaming
through the StreamHandler.
</summary>
<returns>callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface Returns the composed handler.</returns>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.__invoke(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Sends an HTTP request.
</summary>
<param name="request" type="RequestInterface">Request to send.</param>
<param name="options" type="array">Request transfer options.</param>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.createResponse(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="stream" type="resource"></param>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.checkDecode(Pchp.Core.PhpArray,Pchp.Core.PhpArray,Pchp.Core.PhpValue)">
<param name="stream" type="resource"></param>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.drain(Psr.Http.Message.StreamInterface,Psr.Http.Message.StreamInterface,Pchp.Core.PhpString)">
<summary>
Drains the source stream into the "sink" client option.
</summary>
<param name="contentLength" type="string">Header specifying the amount of
data to read.</param>
<exception cref="RuntimeException">when the sink option is invalid.</exception>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.createResource(Pchp.Core.PhpValue)">
<summary>
Create a resource and check to ensure it was created successfully
</summary>
<param name="callback" type="callable">Callable that returns stream resource</param>
<exception cref="RuntimeException">on error</exception>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.createStream(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.add_proxy(Psr.Http.Message.RequestInterface,Pchp.Core.PhpAlias,Pchp.Core.PhpValue,Pchp.Core.PhpAlias)">
<param name="value" type="mixed">as passed via Request transfer options.</param>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.parse_proxy(Pchp.Core.PhpString)">
<summary>
Parses the given proxy URL to make it compatible with the format PHP's stream context expects.
</summary>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.add_timeout(Psr.Http.Message.RequestInterface,Pchp.Core.PhpAlias,Pchp.Core.PhpValue,Pchp.Core.PhpAlias)">
<param name="value" type="mixed">as passed via Request transfer options.</param>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.add_verify(Psr.Http.Message.RequestInterface,Pchp.Core.PhpAlias,Pchp.Core.PhpValue,Pchp.Core.PhpAlias)">
<param name="value" type="mixed">as passed via Request transfer options.</param>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.add_cert(Psr.Http.Message.RequestInterface,Pchp.Core.PhpAlias,Pchp.Core.PhpValue,Pchp.Core.PhpAlias)">
<param name="value" type="mixed">as passed via Request transfer options.</param>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.add_progress(Psr.Http.Message.RequestInterface,Pchp.Core.PhpAlias,Pchp.Core.PhpValue,Pchp.Core.PhpAlias)">
<param name="value" type="mixed">as passed via Request transfer options.</param>
</member>
<member name="M:GuzzleHttp.Handler.StreamHandler.add_debug(Psr.Http.Message.RequestInterface,Pchp.Core.PhpAlias,Pchp.Core.PhpValue,Pchp.Core.PhpAlias)">
<param name="value" type="mixed">as passed via Request transfer options.</param>
</member>
<member name="M:GuzzleHttp.HandlerStack.create(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Creates a default handler stack that can be used by clients.
The returned handler will wrap the provided handler or use the most
appropriate default handler for your system. The returned HandlerStack has
support for cookies, redirects, HTTP error exceptions, and preparing a body
before sending.

The returned handler stack can be passed to a client in the "handler"
option.
</summary>
</member>
<member name="M:GuzzleHttp.HandlerStack.__construct(Pchp.Core.PhpValue)">
</member>
<member name="M:GuzzleHttp.HandlerStack.__invoke(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Invokes the handler stack as a composed handler
</summary>
</member>
<member name="M:GuzzleHttp.HandlerStack.__toString">
<summary>
Dumps a string representation of the stack.
</summary>
</member>
<member name="M:GuzzleHttp.HandlerStack.setHandler(Pchp.Core.PhpValue)">
<summary>
Set the HTTP handler that actually returns a promise.
</summary>
</member>
<member name="M:GuzzleHttp.HandlerStack.hasHandler">
<summary>
Returns true if the builder has a handler.
</summary>
</member>
<member name="M:GuzzleHttp.HandlerStack.unshift(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Unshift a middleware to the bottom of the stack.
</summary>
<param name="name" type="string">Name to register for this middleware.</param>
</member>
<member name="M:GuzzleHttp.HandlerStack.push(Pchp.Core.PhpValue,Pchp.Core.PhpString)">
<summary>
Push a middleware to the top of the stack.
</summary>
<param name="name" type="string">Name to register for this middleware.</param>
</member>
<member name="M:GuzzleHttp.HandlerStack.before(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpString)">
<summary>
Add a middleware before another middleware by name.
</summary>
<param name="findName" type="string">Middleware to find</param>
<param name="withName" type="string">Name to register for this middleware.</param>
</member>
<member name="M:GuzzleHttp.HandlerStack.after(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpString)">
<summary>
Add a middleware after another middleware by name.
</summary>
<param name="findName" type="string">Middleware to find</param>
<param name="withName" type="string">Name to register for this middleware.</param>
</member>
<member name="M:GuzzleHttp.HandlerStack.remove(Pchp.Core.PhpValue)">
<summary>
Remove a middleware by instance or name from the stack.
</summary>
<param name="remove" type="callable|string">Middleware to remove by instance or name.</param>
</member>
<member name="M:GuzzleHttp.HandlerStack.resolve">
<summary>
Compose the middleware and handler into a single callable function.
</summary>
<returns>callable(RequestInterface, array): PromiseInterface</returns>
</member>
<member name="M:GuzzleHttp.HandlerStack.splice(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpValue,System.Boolean)">
<summary>
Splices a function into the middleware list at a specific position.
</summary>
</member>
<member name="M:GuzzleHttp.HandlerStack.debugCallable(Pchp.Core.PhpValue)">
<summary>
Provides a debug string for a given callable.
</summary>
<param name="fn" type="callable|string">Function to write as a string.</param>
</member>
<member name="M:GuzzleHttp.MessageFormatter.__construct(Pchp.Core.PhpValue)">
<param name="template" type="string">Log message template</param>
</member>
<member name="M:GuzzleHttp.MessageFormatter.format(Psr.Http.Message.RequestInterface,Psr.Http.Message.ResponseInterface,Pchp.Library.Spl.Throwable)">
<summary>
Returns a formatted message string.
</summary>
<param name="request" type="RequestInterface">Request that was sent</param>
<param name="response" type="ResponseInterface|null">Response that was received</param>
<param name="error" type="\Throwable|null">Exception that was received</param>
</member>
<member name="M:GuzzleHttp.MessageFormatter.headers(Psr.Http.Message.MessageInterface)">
<summary>
Get headers from message as string
</summary>
</member>
<member name="M:GuzzleHttp.MessageFormatterInterface.format(Psr.Http.Message.RequestInterface,Psr.Http.Message.ResponseInterface,Pchp.Library.Spl.Throwable)">
<summary>
Returns a formatted message string.
</summary>
<param name="request" type="RequestInterface">Request that was sent</param>
<param name="response" type="ResponseInterface|null">Response that was received</param>
<param name="error" type="\Throwable|null">Exception that was received</param>
</member>
<member name="M:GuzzleHttp.Middleware.cookies(Pchp.Core.Context)">
<summary>
Middleware that adds cookies to requests.
The options array must be set to a CookieJarInterface in order to use
cookies. This is typically handled for you by a client.
</summary>
<returns>Returns a function that accepts the next handler.</returns>
</member>
<member name="M:GuzzleHttp.Middleware.httpErrors(Pchp.Core.Context,GuzzleHttp.BodySummarizerInterface)">
<summary>
Middleware that throws exceptions for 4xx or 5xx responses when the
"http_errors" request option is set to true.
</summary>
<param name="bodySummarizer" type="BodySummarizerInterface|null">The body summarizer to use in exception messages.</param>
<returns>callable(callable): callable Returns a function that accepts the next handler.</returns>
</member>
<member name="M:GuzzleHttp.Middleware.history(Pchp.Core.Context,Pchp.Core.PhpAlias)">
<summary>
Middleware that pushes history data to an ArrayAccess container.
</summary>
<returns>callable(callable): callable Returns a function that accepts the next handler.</returns>
<exception cref="InvalidArgumentException">if container is not an array or ArrayAccess.</exception>
</member>
<member name="M:GuzzleHttp.Middleware.tap(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Middleware that invokes a callback before and after sending a request.
The provided listener cannot modify or alter the response. It simply
"taps" into the chain to be notified before returning the promise. The
before listener accepts a request and options array, and the after
listener accepts a request, options array, and response promise.
</summary>
<param name="before" type="callable">Function to invoke before forwarding the request.</param>
<param name="after" type="callable">Function invoked after forwarding.</param>
<returns>Returns a function that accepts the next handler.</returns>
</member>
<member name="M:GuzzleHttp.Middleware.redirect(Pchp.Core.Context)">
<summary>
Middleware that handles request redirects.
</summary>
<returns>Returns a function that accepts the next handler.</returns>
</member>
<member name="M:GuzzleHttp.Middleware.retry(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Middleware that retries requests based on the boolean result of
invoking the provided "decider" function.
If no delay function is provided, a simple implementation of exponential
backoff will be utilized.
</summary>
<param name="decider" type="callable">Function that accepts the number of retries,
a request, [response], and [exception] and
returns true if the request is to be retried.</param>
<param name="delay" type="callable">Function that accepts the number of retries and
returns the number of milliseconds to delay.</param>
<returns>Returns a function that accepts the next handler.</returns>
</member>
<member name="M:GuzzleHttp.Middleware.log(Pchp.Core.Context,System.Object,Pchp.Core.PhpValue,Pchp.Core.PhpString)">
<summary>
Middleware that logs requests, responses, and errors using a message
formatter.
</summary>
<param name="logger" type="LoggerInterface">Logs messages.</param>
<param name="formatter" type="MessageFormatterInterface|MessageFormatter">Formatter used to create message strings.</param>
<param name="logLevel" type="string">Level at which to log requests.</param>
<returns>Returns a function that accepts the next handler.</returns>
</member>
<member name="M:GuzzleHttp.Middleware.prepareBody(Pchp.Core.Context)">
<summary>
This middleware adds a default content-type if possible, a default
content-length or transfer-encoding header, and the expect header.
</summary>
</member>
<member name="M:GuzzleHttp.Middleware.mapRequest(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Middleware that applies a map function to the request before passing to
the next handler.
</summary>
<param name="fn" type="callable">Function that accepts a RequestInterface and returns
a RequestInterface.</param>
</member>
<member name="M:GuzzleHttp.Middleware.mapResponse(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Middleware that applies a map function to the resolved promise's
response.
</summary>
<param name="fn" type="callable">Function that accepts a ResponseInterface and
returns a ResponseInterface.</param>
</member>
<member name="M:GuzzleHttp.Pool.__construct(GuzzleHttp.ClientInterface,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<param name="client" type="ClientInterface">Client used to send the requests.</param>
<param name="requests" type="array|\Iterator">Requests or functions that return
requests to send concurrently.</param>
<param name="config" type="array">Associative array of options
- concurrency: (int) Maximum number of requests to send concurrently
- options: Array of request options to apply to each request.
- fulfilled: (callable) Function to invoke when a request completes.
- rejected: (callable) Function to invoke when a request is rejected.</param>
</member>
<member name="M:GuzzleHttp.Pool.promise">
<summary>
Get promise
</summary>
</member>
<member name="M:GuzzleHttp.Pool.batch(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,GuzzleHttp.ClientInterface,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Sends multiple requests concurrently and returns an array of responses
and exceptions that uses the same ordering as the provided requests.
IMPORTANT: This method keeps every request and response in memory, and
as such, is NOT recommended when sending a large number or an
indeterminate number of requests concurrently.
</summary>
<param name="client" type="ClientInterface">Client used to send the requests</param>
<param name="requests" type="array|\Iterator">Requests to send concurrently.</param>
<param name="options" type="array">Passes through the options available in
{@see \GuzzleHttp\Pool::__construct}</param>
<returns>Returns an array containing the response or an exception
in the same order that the requests were sent.</returns>
<exception cref="InvalidArgumentException">if the event format is incorrect.</exception>
</member>
<member name="M:GuzzleHttp.Pool.cmpCallback(Pchp.Core.Context,Pchp.Core.PhpAlias,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Execute callback(s)
</summary>
</member>
<member name="M:GuzzleHttp.PrepareBodyMiddleware.__construct(Pchp.Core.PhpValue)">
</member>
<member name="M:GuzzleHttp.PrepareBodyMiddleware.addExpectHeader(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray,Pchp.Core.PhpAlias)">
<summary>
Add expect header
</summary>
</member>
<member name="M:GuzzleHttp.RedirectMiddleware.__construct(Pchp.Core.PhpValue)">
</member>
<member name="M:GuzzleHttp.RedirectMiddleware.checkRedirect(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray,Psr.Http.Message.ResponseInterface)">
</member>
<member name="M:GuzzleHttp.RedirectMiddleware.withTracking(GuzzleHttp.Promise.PromiseInterface,Pchp.Core.PhpString,System.Int64)">
<summary>
Enable tracking on promise.
</summary>
</member>
<member name="M:GuzzleHttp.RedirectMiddleware.guardMax(Psr.Http.Message.RequestInterface,Psr.Http.Message.ResponseInterface,Pchp.Core.PhpAlias)">
<summary>
Check for too many redirects.
</summary>
<exception cref="TooManyRedirectsException">Too many redirects.</exception>
</member>
<member name="M:GuzzleHttp.RedirectMiddleware.redirectUri(Pchp.Core.Context,Psr.Http.Message.RequestInterface,Psr.Http.Message.ResponseInterface,Pchp.Core.PhpArray)">
<summary>
Set the appropriate URL on the request based on the location header.
</summary>
</member>
<member name="M:GuzzleHttp.RetryMiddleware.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="decider" type="callable">Function that accepts the number of retries,
a request, [response], and [exception] and
returns true if the request is to be
retried.</param>
</member>
<member name="M:GuzzleHttp.RetryMiddleware.exponentialDelay(Pchp.Core.Context,System.Int64)">
<summary>
Default exponential backoff delay function.
</summary>
<returns>milliseconds.</returns>
</member>
<member name="M:GuzzleHttp.RetryMiddleware.onFulfilled(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Execute fulfilled closure
</summary>
</member>
<member name="M:GuzzleHttp.RetryMiddleware.onRejected(Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Execute rejected closure
</summary>
</member>
<member name="M:GuzzleHttp.TransferStats.__construct(Psr.Http.Message.RequestInterface,Psr.Http.Message.ResponseInterface,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<param name="request" type="RequestInterface">Request that was sent.</param>
<param name="response" type="ResponseInterface|null">Response received (if any)</param>
<param name="transferTime" type="float|null">Total handler transfer time.</param>
<param name="handlerErrorData" type="mixed">Handler error data.</param>
<param name="handlerStats" type="array">Handler specific stats.</param>
</member>
<member name="M:GuzzleHttp.TransferStats.getResponse">
<summary>
Returns the response that was received (if any).
</summary>
</member>
<member name="M:GuzzleHttp.TransferStats.hasResponse">
<summary>
Returns true if a response was received.
</summary>
</member>
<member name="M:GuzzleHttp.TransferStats.getHandlerErrorData">
<summary>
Gets handler specific error data.
This might be an exception, a integer representing an error code, or
anything else. Relying on this value assumes that you know what handler
you are using.
</summary>
</member>
<member name="M:GuzzleHttp.TransferStats.getEffectiveUri">
<summary>
Get the effective URI the request was sent to.
</summary>
</member>
<member name="M:GuzzleHttp.TransferStats.getTransferTime">
<summary>
Get the estimated time the request was being transferred by the handler.
</summary>
<returns>Time in seconds.</returns>
</member>
<member name="M:GuzzleHttp.TransferStats.getHandlerStats">
<summary>
Gets an array of all of the handler specific transfer data.
</summary>
</member>
<member name="M:GuzzleHttp.TransferStats.getHandlerStat(Pchp.Core.PhpString)">
<summary>
Get a specific handler statistic from the handler by name.
</summary>
<param name="stat" type="string">Handler specific transfer stat to retrieve.</param>
</member>
<member name="M:GuzzleHttp.Utils.describeType(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Debug function used to describe the provided value type and class.
</summary>
<param name="input" type="mixed"></param>
<returns>Returns a string containing the type of the variable and
if a class is provided, the class name.</returns>
</member>
<member name="M:GuzzleHttp.Utils.headersFromLines(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Parses an array of header lines into an associative array of headers.
</summary>
<param name="lines" type="iterable">Header lines array of strings in the following
format: "Name: Value"</param>
</member>
<member name="M:GuzzleHttp.Utils.debugResource(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Returns a debug stream based on the provided variable.
</summary>
<param name="value" type="mixed">Optional value</param>
</member>
<member name="M:GuzzleHttp.Utils.chooseHandler(Pchp.Core.Context)">
<summary>
Chooses and creates a default handler to use based on the environment.
The returned handler is not wrapped by any default middlewares.
</summary>
<exception cref="RuntimeException">if no viable Handler is available.</exception>
<returns>callable(\Psr\Http\Message\RequestInterface, array): \GuzzleHttp\Promise\PromiseInterface Returns the best handler for the given system.</returns>
</member>
<member name="M:GuzzleHttp.Utils.defaultUserAgent(Pchp.Core.Context)">
<summary>
Get the default User-Agent string to use with Guzzle.
</summary>
</member>
<member name="M:GuzzleHttp.Utils.defaultCaBundle(Pchp.Core.Context)">
<summary>
Returns the default cacert bundle for the current system.
First, the openssl.cafile and curl.cainfo php.ini settings are checked.
If those settings are not configured, then the common locations for
bundles found on Red Hat, CentOS, Fedora, Ubuntu, Debian, FreeBSD, OS X
and Windows are checked. If any of these file locations are found on
disk, they will be utilized.

Note: the result of this function is cached for subsequent calls.
</summary>
<exception cref="RuntimeException">if no bundle can be found.</exception>
</member>
<member name="M:GuzzleHttp.Utils.normalizeHeaderKeys(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Creates an associative array of lowercase header names to the actual
header casing.
</summary>
</member>
<member name="M:GuzzleHttp.Utils.isHostInNoProxy(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpArray)">
<summary>
Returns true if the provided host matches any of the no proxy areas.
This method will strip a port from the host if it is present. Each pattern
can be matched with an exact match (e.g., "foo.com" == "foo.com") or a
partial match: (e.g., "foo.com" == "baz.foo.com" and ".foo.com" ==
"baz.foo.com", but ".foo.com" != "foo.com").

Areas are matched in the following cases:
1. "*" (without quotes) always matches any hosts.
2. An exact match.
3. The area starts with "." and the area is the last part of the host. e.g.
'.mit.edu' will match any host that ends with '.mit.edu'.
</summary>
<param name="host" type="string">Host to check against the patterns.</param>
<param name="noProxyArray" type="string[]">An array of host patterns.</param>
</member>
<member name="M:GuzzleHttp.Utils.jsonDecode(Pchp.Core.Context,Pchp.Core.PhpString,System.Boolean,System.Int64,System.Int64)">
<summary>
Wrapper for json_decode that throws when an error occurs.
</summary>
<param name="json" type="string">JSON data to parse</param>
<param name="assoc" type="bool">When true, returned objects will be converted
into associative arrays.</param>
<param name="depth" type="int">User specified recursion depth.</param>
<param name="options" type="int">Bitmask of JSON decode options.</param>
<exception cref="InvalidArgumentException">if the JSON cannot be decoded.</exception>
</member>
<member name="M:GuzzleHttp.Utils.jsonEncode(Pchp.Core.Context,Pchp.Core.PhpValue,System.Int64,System.Int64)">
<summary>
Wrapper for JSON encoding that throws when an error occurs.
</summary>
<param name="value" type="mixed">The value being encoded</param>
<param name="options" type="int">JSON encode option bitmask</param>
<param name="depth" type="int">Set the maximum depth. Must be greater than zero.</param>
<exception cref="InvalidArgumentException">if the JSON cannot be encoded.</exception>
</member>
<member name="M:GuzzleHttp.Utils.currentTime(Pchp.Core.Context)">
<summary>
Wrapper for the hrtime() or microtime() functions
(depending on the PHP version, one of the two is used)
</summary>
<returns>UNIX timestamp</returns>
</member>
<member name="M:GuzzleHttp.Utils.idnUriConvert(Pchp.Core.Context,Psr.Http.Message.UriInterface,System.Int64)">
</member>
<member name="M:GuzzleHttp.Utils.getenv(Pchp.Core.Context,Pchp.Core.PhpString)">
</member>
<member name="M:GuzzleHttp.Utils.idnToAsci(Pchp.Core.Context,Pchp.Core.PhpString,System.Int64,Pchp.Core.PhpAlias)">
</member>
<member name="M:GuzzleHttp.Promise.Coroutine.of(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Create a new coroutine.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.Coroutine._handleSuccess(Pchp.Core.PhpValue)">
</member>
<member name="M:GuzzleHttp.Promise.Coroutine._handleFailure(Pchp.Core.PhpValue)">
</member>
<member name="M:GuzzleHttp.Promise.Create.promiseFor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Creates a promise for a value if the value is not a promise.
</summary>
<param name="value" type="mixed">Promise or value.</param>
</member>
<member name="M:GuzzleHttp.Promise.Create.rejectionFor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Creates a rejected promise for a reason if the reason is not a promise.
If the provided reason is a promise, then it is returned as-is.
</summary>
<param name="reason" type="mixed">Promise or reason.</param>
</member>
<member name="M:GuzzleHttp.Promise.Create.exceptionFor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Create an exception for a rejected promise value.
</summary>
<param name="reason" type="mixed"></param>
</member>
<member name="M:GuzzleHttp.Promise.Create.iterFor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Returns an iterator for the given value.
</summary>
<param name="value" type="mixed"></param>
</member>
<member name="M:GuzzleHttp.Promise.Each.of(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Given an iterator that yields promises or values, returns a promise that
is fulfilled with a null value when the iterator has been consumed or
the aggregate promise has been fulfilled or rejected.
$onFulfilled is a function that accepts the fulfilled value, iterator
index, and the aggregate promise. The callback can invoke any necessary
side effects and choose to resolve or reject the aggregate if needed.

$onRejected is a function that accepts the rejection reason, iterator
index, and the aggregate promise. The callback can invoke any necessary
side effects and choose to resolve or reject the aggregate if needed.
</summary>
<param name="iterable" type="mixed">Iterator or array to iterate over.</param>
<param name="onFulfilled" type="callable"></param>
<param name="onRejected" type="callable"></param>
</member>
<member name="M:GuzzleHttp.Promise.Each.ofLimit(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Like of, but only allows a certain number of outstanding promises at any
given time.
$concurrency may be an integer or a function that accepts the number of
pending promises and returns a numeric concurrency limit value to allow
for dynamic a concurrency size.
</summary>
<param name="iterable" type="mixed"></param>
<param name="concurrency" type="int|callable"></param>
<param name="onFulfilled" type="callable"></param>
<param name="onRejected" type="callable"></param>
</member>
<member name="M:GuzzleHttp.Promise.Each.ofLimitAll(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Like limit, but ensures that no promise in the given $iterable argument
is rejected. If any promise is rejected, then the aggregate promise is
rejected with the encountered rejection.
</summary>
<param name="iterable" type="mixed"></param>
<param name="concurrency" type="int|callable"></param>
<param name="onFulfilled" type="callable"></param>
</member>
<member name="M:GuzzleHttp.Promise.EachPromise.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Configuration hash can include the following key value pairs:
- fulfilled: (callable) Invoked when a promise fulfills. The function
is invoked with three arguments: the fulfillment value, the index
position from the iterable list of the promise, and the aggregate
promise that manages all of the promises. The aggregate promise may
be resolved from within the callback to short-circuit the promise.
- rejected: (callable) Invoked when a promise is rejected. The
function is invoked with three arguments: the rejection reason, the
index position from the iterable list of the promise, and the
aggregate promise that manages all of the promises. The aggregate
promise may be resolved from within the callback to short-circuit
the promise.
- concurrency: (integer) Pass this configuration option to limit the
allowed number of outstanding concurrently executing promises,
creating a capped pool of promises. There is no limit by default.
</summary>
<param name="iterable" type="mixed">Promises or values to iterate.</param>
<param name="config" type="array">Configuration options</param>
</member>
<member name="M:GuzzleHttp.Promise.EachPromise.promise">
</member>
<member name="M:GuzzleHttp.Promise.Is.pending(Pchp.Core.Context,GuzzleHttp.Promise.PromiseInterface)">
<summary>
Returns true if a promise is pending.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.Is.settled(Pchp.Core.Context,GuzzleHttp.Promise.PromiseInterface)">
<summary>
Returns true if a promise is fulfilled or rejected.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.Is.fulfilled(Pchp.Core.Context,GuzzleHttp.Promise.PromiseInterface)">
<summary>
Returns true if a promise is fulfilled.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.Is.rejected(Pchp.Core.Context,GuzzleHttp.Promise.PromiseInterface)">
<summary>
Returns true if a promise is rejected.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.Promise.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="waitFn" type="callable">Fn that when invoked resolves the promise.</param>
<param name="cancelFn" type="callable">Fn that when invoked cancels the promise.</param>
</member>
<member name="M:GuzzleHttp.Promise.Promise.callHandler(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Call a stack of handlers using a specific callback index and value.
</summary>
<param name="index" type="int">1 (resolve) or 2 (reject).</param>
<param name="value" type="mixed">Value to pass to the callback.</param>
<param name="handler" type="array">Array of handler data (promise and callbacks).</param>
</member>
<member name="M:GuzzleHttp.Promise.PromiseInterface.then(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Appends fulfillment and rejection handlers to the promise, and returns
a new promise resolving to the return value of the called handler.
</summary>
<param name="onFulfilled" type="callable">Invoked when the promise fulfills.</param>
<param name="onRejected" type="callable">Invoked when the promise is rejected.</param>
</member>
<member name="M:GuzzleHttp.Promise.PromiseInterface.otherwise(Pchp.Core.PhpValue)">
<summary>
Appends a rejection handler callback to the promise, and returns a new
promise resolving to the return value of the callback if it is called,
or to its original fulfillment value if the promise is instead
fulfilled.
</summary>
<param name="onRejected" type="callable">Invoked when the promise is rejected.</param>
</member>
<member name="M:GuzzleHttp.Promise.PromiseInterface.getState">
<summary>
Get the state of the promise ("pending", "rejected", or "fulfilled").
The three states can be checked against the constants defined on
PromiseInterface: PENDING, FULFILLED, and REJECTED.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.PromiseInterface.resolve(Pchp.Core.PhpValue)">
<summary>
Resolve the promise with the given value.
</summary>
<param name="value" type="mixed"></param>
<exception cref="RuntimeException">if the promise is already resolved.</exception>
</member>
<member name="M:GuzzleHttp.Promise.PromiseInterface.reject(Pchp.Core.PhpValue)">
<summary>
Reject the promise with the given reason.
</summary>
<param name="reason" type="mixed"></param>
<exception cref="RuntimeException">if the promise is already resolved.</exception>
</member>
<member name="M:GuzzleHttp.Promise.PromiseInterface.cancel">
<summary>
Cancels the promise if possible.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.PromiseInterface.wait(Pchp.Core.PhpValue)">
<summary>
Waits until the promise completes if possible.
Pass $unwrap as true to unwrap the result of the promise, either
returning the resolved value or throwing the rejected exception.

If the promise cannot be waited on, then the promise will be rejected.
</summary>
<param name="unwrap" type="bool"></param>
<exception cref="LogicException">if the promise has no wait function or if the
promise does not settle after waiting.</exception>
</member>
<member name="M:GuzzleHttp.Promise.PromisorInterface.promise">
<summary>
Returns a promise.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.RejectionException.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="reason" type="mixed">Rejection reason.</param>
<param name="description" type="string">Optional description</param>
</member>
<member name="M:GuzzleHttp.Promise.RejectionException.getReason">
<summary>
Returns the rejection reason.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.TaskQueue.disableShutdown">
<summary>
The task queue will be run and exhausted by default when the process
exits IFF the exit is not the result of a PHP E_ERROR error.
You can disable running the automatic shutdown of the queue by calling
this function. If you disable the task queue shutdown process, then you
MUST either run the task queue (as a result of running your event loop
or manually using the run() method) or wait on each outstanding promise.

Note: This shutdown will occur before any destructors are triggered.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.TaskQueueInterface.isEmpty">
<summary>
Returns true if the queue is empty.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.TaskQueueInterface.add(Pchp.Core.PhpValue)">
<summary>
Adds a task to the queue that will be executed the next time run is
called.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.TaskQueueInterface.run">
<summary>
Execute all of the pending task in the queue.
</summary>
</member>
<member name="M:GuzzleHttp.Promise.Utils.queue(Pchp.Core.Context,GuzzleHttp.Promise.TaskQueueInterface)">
<summary>
Get the global task queue used for promise resolution.
This task queue MUST be run in an event loop in order for promises to be
settled asynchronously. It will be automatically run when synchronously
waiting on a promise.

&lt;code&gt;
while ($eventLoop-&gt;isRunning()) {
GuzzleHttp\Promise\Utils::queue()-&gt;run();
}
&lt;/code&gt;
</summary>
<param name="assign" type="TaskQueueInterface">Optionally specify a new queue instance.</param>
</member>
<member name="M:GuzzleHttp.Promise.Utils.task(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Adds a function to run in the task queue when it is next `run()` and
returns a promise that is fulfilled or rejected with the result.
</summary>
<param name="task" type="callable">Task function to run.</param>
</member>
<member name="M:GuzzleHttp.Promise.Utils.inspect(Pchp.Core.Context,GuzzleHttp.Promise.PromiseInterface)">
<summary>
Synchronously waits on a promise to resolve and returns an inspection
state array.
Returns a state associative array containing a "state" key mapping to a
valid promise state. If the state of the promise is "fulfilled", the
array will contain a "value" key mapping to the fulfilled value of the
promise. If the promise is rejected, the array will contain a "reason"
key mapping to the rejection reason of the promise.
</summary>
<param name="promise" type="PromiseInterface">Promise or value.</param>
</member>
<member name="M:GuzzleHttp.Promise.Utils.inspectAll(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Waits on all of the provided promises, but does not unwrap rejected
promises as thrown exception.
Returns an array of inspection state arrays.
</summary>
<param name="promises" type="PromiseInterface[]">Traversable of promises to wait upon.</param>
</member>
<member name="M:GuzzleHttp.Promise.Utils.unwrap(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Waits on all of the provided promises and returns the fulfilled values.
Returns an array that contains the value of each promise (in the same
order the promises were provided). An exception is thrown if any of the
promises are rejected.
</summary>
<param name="promises" type="iterable&lt;PromiseInterface&gt;">Iterable of PromiseInterface objects to wait on.</param>
<exception cref="Exception">on error</exception>
<exception cref="Throwable">on error in PHP &gt;=7</exception>
</member>
<member name="M:GuzzleHttp.Promise.Utils.all(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Given an array of promises, return a promise that is fulfilled when all
the items in the array are fulfilled.
The promise's fulfillment value is an array with fulfillment values at
respective positions to the original array. If any promise in the array
rejects, the returned promise is rejected with the rejection reason.
</summary>
<param name="promises" type="mixed">Promises or values.</param>
<param name="recursive" type="bool">If true, resolves new promises that might have been added to the stack during its own resolution.</param>
</member>
<member name="M:GuzzleHttp.Promise.Utils.some(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Initiate a competitive race between multiple promises or values (values
will become immediately fulfilled promises).
When count amount of promises have been fulfilled, the returned promise
is fulfilled with an array that contains the fulfillment values of the
winners in order of resolution.

This promise is rejected with a {@see AggregateException} if the number
of fulfilled promises is less than the desired $count.
</summary>
<param name="count" type="int">Total number of promises.</param>
<param name="promises" type="mixed">Promises or values.</param>
</member>
<member name="M:GuzzleHttp.Promise.Utils.any(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Like some(), with 1 as count. However, if the promise fulfills, the
fulfillment value is not an array of 1 but the value directly.
</summary>
<param name="promises" type="mixed">Promises or values.</param>
</member>
<member name="M:GuzzleHttp.Promise.Utils.settle(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Returns a promise that is fulfilled when all of the provided promises have
been fulfilled or rejected.
The returned promise is fulfilled with an array of inspection state arrays.
</summary>
<param name="promises" type="mixed">Promises or values.</param>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.__construct(Pchp.Core.PhpArray)">
<param name="streams" type="StreamInterface[]">Streams to decorate. Each stream must
be readable.</param>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.addStream(Psr.Http.Message.StreamInterface)">
<summary>
Add a stream to the AppendStream
</summary>
<param name="stream" type="StreamInterface">Stream to append. Must be readable.</param>
<exception cref="InvalidArgumentException">if the stream is not readable</exception>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.close">
<summary>
Closes each attached stream.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.detach">
<summary>
Detaches each attached stream.
Returns null as it's not clear which underlying stream resource to return.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.getSize">
<summary>
Tries to calculate the size by adding the size of each stream.
If any of the streams do not return a valid number, then the size of the
append stream cannot be determined and null is returned.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.seek(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Attempts to seek to the given position. Only supports SEEK_SET.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.read(Pchp.Core.PhpValue)">
<summary>
Reads from all of the appended streams until the length is met or EOF.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.AppendStream.getMetadata(Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.BufferStream.__construct(System.Int64)">
<param name="hwm" type="int">High water mark, representing the preferred maximum
buffer size. If the size of the buffer exceeds the high
water mark, then calls to write will continue to succeed
but will return 0 to inform writers to slow down
until the buffer has been drained by reading from it.</param>
</member>
<member name="M:GuzzleHttp.Psr7.BufferStream.read(Pchp.Core.PhpValue)">
<summary>
Reads data from the buffer.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.BufferStream.write(Pchp.Core.PhpValue)">
<summary>
Writes data to the buffer.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.BufferStream.getMetadata(Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.CachingStream.__construct(Psr.Http.Message.StreamInterface,Psr.Http.Message.StreamInterface)">
<summary>
We will treat the buffer object as the body of the stream
</summary>
<param name="stream" type="StreamInterface">Stream to cache. The cursor is assumed to be at the beginning of the stream.</param>
<param name="target" type="StreamInterface">Optionally specify where data is cached</param>
</member>
<member name="M:GuzzleHttp.Psr7.CachingStream.close">
<summary>
Close both the remote stream and buffer stream
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.DroppingStream.__construct(Psr.Http.Message.StreamInterface,System.Int64)">
<param name="stream" type="StreamInterface">Underlying stream to decorate.</param>
<param name="maxLength" type="int">Maximum size before dropping data.</param>
</member>
<member name="M:GuzzleHttp.Psr7.FnStream.__construct(Pchp.Core.PhpArray)">
</member>
<member name="M:GuzzleHttp.Psr7.FnStream.__get(Pchp.Core.PhpString)">
<summary>
Lazily determine which methods are not implemented.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.FnStream.__destruct">
<summary>
The close method is called on the underlying stream only if possible.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.FnStream.__wakeup">
<summary>
An unserialize would allow the __destruct to run when the unserialized value goes out of scope.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.FnStream.decorate(Pchp.Core.Context,Psr.Http.Message.StreamInterface,Pchp.Core.PhpArray)">
<summary>
Adds custom functionality to an underlying stream by intercepting
specific method calls.
</summary>
<param name="stream" type="StreamInterface">Stream to decorate</param>
</member>
<member name="M:GuzzleHttp.Psr7.FnStream.getMetadata(Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Header.parse(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Parse an array of header values containing ";" separated data into an
array of associative arrays representing the header key value pair data
of the header. When a parameter does not contain a value, but just
contains a key, this function will inject a key with a '' string value.
</summary>
<param name="header" type="string|array">Header to parse into components.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Header.normalize(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Converts an array of header values that may contain comma separated
headers into an array of headers with no comma separated values.
</summary>
<param name="header" type="string|array">Header to normalize.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Header.splitList(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Splits a HTTP header defined to contain a comma-separated list into
each individual value. Empty values will be removed.
Example headers include 'accept', 'cache-control' and 'if-none-match'.

This method must not be used to parse headers that are not defined as
a list, such as 'user-agent' or 'set-cookie'.
</summary>
<param name="values" type="string|string[]">Header value as returned by MessageInterface::getHeader()</param>
</member>
<member name="M:GuzzleHttp.Psr7.LazyOpenStream.__construct(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<param name="filename" type="string">File to lazily open</param>
<param name="mode" type="string">fopen mode to use when opening the stream</param>
</member>
<member name="M:GuzzleHttp.Psr7.LazyOpenStream.createStream">
<summary>
Creates the underlying stream lazily when required.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.LimitStream.__construct(Psr.Http.Message.StreamInterface,System.Int64,System.Int64)">
<param name="stream" type="StreamInterface">Stream to wrap</param>
<param name="limit" type="int">Total number of bytes to allow to be read
from the stream. Pass -1 for no limit.</param>
<param name="offset" type="int">Position to seek to before reading (only
works on seekable streams).</param>
</member>
<member name="M:GuzzleHttp.Psr7.LimitStream.getSize">
<summary>
Returns the size of the limited subset of data
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.LimitStream.seek(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Allow for a bounded seek on the read limited stream
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.LimitStream.tell">
<summary>
Give a relative tell()
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.LimitStream.setOffset(System.Int64)">
<summary>
Set the offset to start limiting from
</summary>
<param name="offset" type="int">Offset to seek to and begin byte limiting from</param>
<exception cref="RuntimeException">if the stream cannot be seeked.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.LimitStream.setLimit(System.Int64)">
<summary>
Set the limit of bytes that the decorator allows to be read from the
stream.
</summary>
<param name="limit" type="int">Number of bytes to allow to be read from the stream.
Use -1 for no limit.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Message.toString(Pchp.Core.Context,Psr.Http.Message.MessageInterface)">
<summary>
Returns the string representation of an HTTP message.
</summary>
<param name="message" type="MessageInterface">Message to convert to a string.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Message.bodySummary(Pchp.Core.Context,Psr.Http.Message.MessageInterface,System.Int64)">
<summary>
Get a short summary of the message body.
Will return `null` if the response is not printable.
</summary>
<param name="message" type="MessageInterface">The message to get the body summary</param>
<param name="truncateAt" type="int">The maximum allowed size of the summary</param>
</member>
<member name="M:GuzzleHttp.Psr7.Message.rewindBody(Pchp.Core.Context,Psr.Http.Message.MessageInterface)">
<summary>
Attempts to rewind a message body and throws an exception on failure.
The body of the message will only be rewound if a call to `tell()`
returns a value other than `0`.
</summary>
<param name="message" type="MessageInterface">Message to rewind</param>
</member>
<member name="M:GuzzleHttp.Psr7.Message.parseMessage(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Parses an HTTP message into an associative array.
The array contains the "start-line" key containing the start line of
the message, "headers" key containing an associative array of header
array values, and a "body" key containing the body of the message.
</summary>
<param name="message" type="string">HTTP request or response to parse.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Message.parseRequestUri(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpArray)">
<summary>
Constructs a URI for an HTTP request message.
</summary>
<param name="path" type="string">Path from the start-line</param>
<param name="headers" type="array">Array of headers (each value an array).</param>
</member>
<member name="M:GuzzleHttp.Psr7.Message.parseRequest(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Parses a request message string into a request object.
</summary>
<param name="message" type="string">Request message string.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Message.parseResponse(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Parses a response message string into a response object.
</summary>
<param name="message" type="string">Response message string.</param>
</member>
<member name="M:GuzzleHttp.Psr7.MessageTrait`1`1.setHeaders(Pchp.Core.PhpArray)">
</member>
<member name="M:GuzzleHttp.Psr7.MessageTrait`1`1.normalizeHeaderValue(Pchp.Core.PhpValue)">
<param name="value" type="mixed"></param>
</member>
<member name="M:GuzzleHttp.Psr7.MessageTrait`1`1.trimAndValidateHeaderValues(Pchp.Core.PhpArray)">
<summary>
Trims whitespace from the header values.
Spaces and tabs ought to be excluded by parsers when extracting the field value from a header field.

header-field = field-name ":" OWS field-value OWS
OWS          = *( SP / HTAB )
</summary>
<param name="values" type="mixed[]">Header values</param>
<returns>Trimmed header values</returns>
</member>
<member name="M:GuzzleHttp.Psr7.MessageTrait`1`1.assertHeader(Pchp.Core.PhpValue)">
<param name="header" type="mixed"></param>
</member>
<member name="M:GuzzleHttp.Psr7.MessageTrait`1`1.assertValue(Pchp.Core.PhpString)">
</member>
<member name="M:GuzzleHttp.Psr7.MimeType.fromFilename(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Determines the mimetype of a file by looking at its extension.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.MimeType.fromExtension(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Maps a file extensions to a mimetype.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.MultipartStream.__construct(Pchp.Core.PhpArray,Pchp.Core.PhpValue)">
<param name="elements" type="array">Array of associative arrays, each containing a
required "name" key mapping to the form field,
name, a required "contents" key mapping to a
StreamInterface/resource/string, an optional
"headers" associative array of custom headers,
and an optional "filename" key mapping to a
string to send as the filename in the part.</param>
<param name="boundary" type="string">You can optionally provide a specific boundary</param>
</member>
<member name="M:GuzzleHttp.Psr7.MultipartStream.getHeaders(Pchp.Core.PhpArray)">
<summary>
Get the headers needed before transferring the content of a POST file
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.MultipartStream.createStream(Pchp.Core.PhpArray)">
<summary>
Create the aggregate stream that will be used to upload the POST data
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.PumpStream.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
</member>
<member name="M:GuzzleHttp.Psr7.PumpStream.getMetadata(Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Query.parse(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Parse a query string into an associative array.
If multiple values are found for the same key, the value of that key
value pair will become an array. This function does not parse nested
PHP style arrays into an associative array (e.g., `foo[a]=1&amp;foo[b]=2`
will be parsed into `['foo[a]' =&gt; '1', 'foo[b]' =&gt; '2'])`.
</summary>
<param name="str" type="string">Query string to parse</param>
<param name="urlEncoding" type="int|bool">How the query string is encoded</param>
</member>
<member name="M:GuzzleHttp.Psr7.Query.build(Pchp.Core.Context,Pchp.Core.PhpArray,Pchp.Core.PhpValue)">
<summary>
Build a query string from an array of key value pairs.
This function can use the return value of `parse()` to build a query
string. This function does not modify the provided keys when an array is
encountered (like `http_build_query()` would).
</summary>
<param name="params" type="array">Query string parameters.</param>
<param name="encoding" type="int|false">Set to false to not encode, PHP_QUERY_RFC3986
to encode using RFC3986, or PHP_QUERY_RFC1738
to encode using RFC1738.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Request.__construct(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray,Pchp.Core.PhpValue,Pchp.Core.PhpString)">
<param name="method" type="string">HTTP method</param>
<param name="uri" type="string|UriInterface">URI</param>
<param name="body" type="string|resource|StreamInterface|null">Request body</param>
<param name="version" type="string">Protocol version</param>
</member>
<member name="M:GuzzleHttp.Psr7.Request.assertMethod(Pchp.Core.PhpValue)">
<param name="method" type="mixed"></param>
</member>
<member name="M:GuzzleHttp.Psr7.Response.__construct(System.Int64,Pchp.Core.PhpArray,Pchp.Core.PhpValue,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<param name="status" type="int">Status code</param>
<param name="body" type="string|resource|StreamInterface|null">Response body</param>
<param name="version" type="string">Protocol version</param>
<param name="reason" type="string|null">Reason phrase (when empty a default will be used based on the status code)</param>
</member>
<member name="M:GuzzleHttp.Psr7.Response.assertStatusCodeIsInteger(Pchp.Core.PhpValue)">
<param name="statusCode" type="mixed"></param>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.__construct(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray,Pchp.Core.PhpValue,Pchp.Core.PhpString,Pchp.Core.PhpArray)">
<param name="method" type="string">HTTP method</param>
<param name="uri" type="string|UriInterface">URI</param>
<param name="body" type="string|resource|StreamInterface|null">Request body</param>
<param name="version" type="string">Protocol version</param>
<param name="serverParams" type="array">Typically the $_SERVER superglobal</param>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.normalizeFiles(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Return an UploadedFile instance array.
</summary>
<param name="files" type="array">An array which respect $_FILES structure</param>
<exception cref="InvalidArgumentException">for unrecognized values</exception>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.createUploadedFileFromSpec(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Create and return an UploadedFile instance from a $_FILES specification.
If the specification represents an array of values, this method will
delegate to normalizeNestedFileSpec() and return that return value.
</summary>
<param name="value" type="array">$_FILES struct</param>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.normalizeNestedFileSpec(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Normalize an array of file specifications.
Loops through all nested files and returns a normalized array of
UploadedFileInterface instances.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.fromGlobals(Pchp.Core.Context)">
<summary>
Return a ServerRequest populated with superglobals:
$_GET
$_POST
$_COOKIE
$_FILES
$_SERVER
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.getUriFromGlobals(Pchp.Core.Context)">
<summary>
Get a Uri populated with values from $_SERVER.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.getParsedBody">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.ServerRequest.getAttribute(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Stream.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
This constructor accepts an associative array of options.
- size: (int) If a read stream would otherwise have an indeterminate
size, but the size is known due to foreknowledge, then you can
provide that size, in bytes.
- metadata: (array) Any additional metadata to return when the metadata
of the stream is accessed.
</summary>
<param name="stream" type="resource">Stream resource to wrap.</param>
<exception cref="InvalidArgumentException">if the stream is not a stream resource</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Stream.__destruct">
<summary>
Closes the stream when the destructed
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Stream.getMetadata(Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.StreamDecoratorTrait`1`1.__construct(Psr.Http.Message.StreamInterface)">
<param name="stream" type="StreamInterface">Stream to decorate</param>
</member>
<member name="M:GuzzleHttp.Psr7.StreamDecoratorTrait`1`1.__get(Pchp.Core.PhpString)">
<summary>
Magic method used to create a new stream if streams are not added in
the constructor of a decorator (e.g., LazyOpenStream).
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.StreamDecoratorTrait`1`1.__call(Pchp.Core.PhpString,Pchp.Core.PhpArray)">
<summary>
Allow decorators to implement custom methods
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.StreamDecoratorTrait`1`1.getMetadata(Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.StreamDecoratorTrait`1`1.createStream">
<summary>
Implement in subclasses to dynamically create streams when requested.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.StreamWrapper.getResource(Pchp.Core.Context,Psr.Http.Message.StreamInterface)">
<summary>
Returns a resource representing the stream.
</summary>
<param name="stream" type="StreamInterface">The stream to get a resource for</param>
<exception cref="InvalidArgumentException">if stream is not readable or writable</exception>
</member>
<member name="M:GuzzleHttp.Psr7.StreamWrapper.createStreamContext(Pchp.Core.Context,Psr.Http.Message.StreamInterface)">
<summary>
Creates a stream context that can be used to open a stream as a php stream resource.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.StreamWrapper.register(Pchp.Core.Context)">
<summary>
Registers the stream wrapper if needed
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.StreamWrapper.stream_cast(System.Int64)">
</member>
<member name="M:GuzzleHttp.Psr7.StreamWrapper.stream_stat">
<returns>array&lt;int|string, int&gt;</returns>
</member>
<member name="M:GuzzleHttp.Psr7.StreamWrapper.url_stat(Pchp.Core.PhpString,System.Int64)">
<returns>array&lt;int|string, int&gt;</returns>
</member>
<member name="M:GuzzleHttp.Psr7.UploadedFile.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpValue,System.Int64,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<param name="streamOrFile" type="StreamInterface|string|resource"></param>
</member>
<member name="M:GuzzleHttp.Psr7.UploadedFile.setStreamOrFile(Pchp.Core.PhpValue)">
<summary>
Depending on the value set file or stream variable
</summary>
<param name="streamOrFile" type="StreamInterface|string|resource"></param>
</member>
<member name="M:GuzzleHttp.Psr7.UploadedFile.setError(System.Int64)">
</member>
<member name="M:GuzzleHttp.Psr7.UploadedFile.isOk">
<summary>
Return true if there is no upload error
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.UploadedFile.validateActive">
<exception cref="RuntimeException">if is moved or not ok</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.parse(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
UTF-8 aware \parse_url() replacement.
The internal function produces broken output for non ASCII domain names
(IDN) when used with locales other than "C".

On the other hand, cURL understands IDN correctly only when UTF-8 locale
is configured ("C.UTF-8", "en_US.UTF-8", etc.).
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.composeComponents(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Composes a URI reference string from its various components.
Usually this method does not need to be called manually but instead is used indirectly via
`Psr\Http\Message\UriInterface::__toString`.

PSR-7 UriInterface treats an empty component the same as a missing component as
getQuery(), getFragment() etc. always return a string. This explains the slight
difference to RFC 3986 Section 5.3.

Another adjustment is that the authority separator is added even when the authority is missing/empty
for the "file" scheme. This is because PHP stream functions like `file_get_contents` only work with
`file:///myfile` but not with `file:/myfile` although they are equivalent according to RFC 3986. But
`file:///` is the more common syntax for the file scheme anyway (Chrome for example redirects to
that format).
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.isDefaultPort(Pchp.Core.Context,Psr.Http.Message.UriInterface)">
<summary>
Whether the URI has the default port of the current scheme.
`Psr\Http\Message\UriInterface::getPort` may return null or the standard port. This method can be used
independently of the implementation.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.isAbsolute(Pchp.Core.Context,Psr.Http.Message.UriInterface)">
<summary>
Whether the URI is absolute, i.e. it has a scheme.
An instance of UriInterface can either be an absolute URI or a relative reference. This method returns true
if it is the former. An absolute URI has a scheme. A relative reference is used to express a URI relative
to another URI, the base URI. Relative references can be divided into several forms:
- network-path references, e.g. '//example.com/path'
- absolute-path references, e.g. '/path'
- relative-path references, e.g. 'subpath'
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.isNetworkPathReference(Pchp.Core.Context,Psr.Http.Message.UriInterface)">
<summary>
Whether the URI is a network-path reference.
A relative reference that begins with two slash characters is termed an network-path reference.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.isAbsolutePathReference(Pchp.Core.Context,Psr.Http.Message.UriInterface)">
<summary>
Whether the URI is a absolute-path reference.
A relative reference that begins with a single slash character is termed an absolute-path reference.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.isRelativePathReference(Pchp.Core.Context,Psr.Http.Message.UriInterface)">
<summary>
Whether the URI is a relative-path reference.
A relative reference that does not begin with a slash character is termed a relative-path reference.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.isSameDocumentReference(Pchp.Core.Context,Psr.Http.Message.UriInterface,Psr.Http.Message.UriInterface)">
<summary>
Whether the URI is a same-document reference.
A same-document reference refers to a URI that is, aside from its fragment
component, identical to the base URI. When no base URI is given, only an empty
URI reference (apart from its fragment) is considered a same-document reference.
</summary>
<param name="uri" type="UriInterface">The URI to check</param>
<param name="base" type="UriInterface|null">An optional base URI to compare against</param>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.withoutQueryValue(Pchp.Core.Context,Psr.Http.Message.UriInterface,Pchp.Core.PhpString)">
<summary>
Creates a new URI with a specific query string value removed.
Any existing query string values that exactly match the provided key are
removed.
</summary>
<param name="uri" type="UriInterface">URI to use as a base.</param>
<param name="key" type="string">Query string key to remove.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.withQueryValue(Pchp.Core.Context,Psr.Http.Message.UriInterface,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Creates a new URI with a specific query string value.
Any existing query string values that exactly match the provided key are
removed and replaced with the given key value pair.

A value of null will set the query string key without a value, e.g. "key"
instead of "key=value".
</summary>
<param name="uri" type="UriInterface">URI to use as a base.</param>
<param name="key" type="string">Key to set.</param>
<param name="value" type="string|null">Value to set</param>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.withQueryValues(Pchp.Core.Context,Psr.Http.Message.UriInterface,Pchp.Core.PhpArray)">
<summary>
Creates a new URI with multiple specific query string values.
It has the same behavior as withQueryValue() but for an associative array of key =&gt; value.
</summary>
<param name="uri" type="UriInterface">URI to use as a base.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.fromParts(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Creates a URI from a hash of `parse_url` components.
</summary>
<exception cref="MalformedUriException">If the components do not form a valid URI.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.applyParts(Pchp.Core.PhpArray)">
<summary>
Apply parse_url parts to a URI.
</summary>
<param name="parts" type="array">Array of parse_url parts to apply.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.filterScheme(Pchp.Core.PhpValue)">
<param name="scheme" type="mixed"></param>
<exception cref="InvalidArgumentException">If the scheme is invalid.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.filterUserInfoComponent(Pchp.Core.PhpValue)">
<param name="component" type="mixed"></param>
<exception cref="InvalidArgumentException">If the user info is invalid.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.filterHost(Pchp.Core.PhpValue)">
<param name="host" type="mixed"></param>
<exception cref="InvalidArgumentException">If the host is invalid.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.filterPort(Pchp.Core.PhpValue)">
<param name="port" type="mixed"></param>
<exception cref="InvalidArgumentException">If the port is invalid.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.getFilteredQueryString(Pchp.Core.Context,Psr.Http.Message.UriInterface,Pchp.Core.PhpArray)">
<param name="keys" type="string[]"></param>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.filterPath(Pchp.Core.PhpValue)">
<summary>
Filters the path of a URI
</summary>
<param name="path" type="mixed"></param>
<exception cref="InvalidArgumentException">If the path is invalid.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Uri.filterQueryAndFragment(Pchp.Core.PhpValue)">
<summary>
Filters the query string or fragment of a URI.
</summary>
<param name="str" type="mixed"></param>
<exception cref="InvalidArgumentException">If the query or fragment is invalid.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.UriComparator.isCrossOrigin(Pchp.Core.Context,Psr.Http.Message.UriInterface,Psr.Http.Message.UriInterface)">
<summary>
Determines if a modified URL should be considered cross-origin with
respect to an original URL.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.UriNormalizer.normalize(Pchp.Core.Context,Psr.Http.Message.UriInterface,System.Int64)">
<summary>
Returns a normalized URI.
The scheme and host component are already normalized to lowercase per PSR-7 UriInterface.
This methods adds additional normalizations that can be configured with the $flags parameter.

PSR-7 UriInterface cannot distinguish between an empty component and a missing component as
getQuery(), getFragment() etc. always return a string. This means the URIs "/?#" and "/" are
treated equivalent which is not necessarily true according to RFC 3986. But that difference
is highly uncommon in reality. So this potential normalization is implied in PSR-7 as well.
</summary>
<param name="uri" type="UriInterface">The URI to normalize</param>
<param name="flags" type="int">A bitmask of normalizations to apply, see constants</param>
</member>
<member name="M:GuzzleHttp.Psr7.UriNormalizer.isEquivalent(Pchp.Core.Context,Psr.Http.Message.UriInterface,Psr.Http.Message.UriInterface,System.Int64)">
<summary>
Whether two URIs can be considered equivalent.
Both URIs are normalized automatically before comparison with the given $normalizations bitmask. The method also
accepts relative URI references and returns true when they are equivalent. This of course assumes they will be
resolved against the same base URI. If this is not the case, determination of equivalence or difference of
relative references does not mean anything.
</summary>
<param name="uri1" type="UriInterface">An URI to compare</param>
<param name="uri2" type="UriInterface">An URI to compare</param>
<param name="normalizations" type="int">A bitmask of normalizations to apply, see constants</param>
</member>
<member name="M:GuzzleHttp.Psr7.UriResolver.removeDotSegments(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Removes dot segments from a path and returns the new path.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.UriResolver.resolve(Pchp.Core.Context,Psr.Http.Message.UriInterface,Psr.Http.Message.UriInterface)">
<summary>
Converts the relative URI into a new URI that is resolved against the base URI.
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.UriResolver.relativize(Pchp.Core.Context,Psr.Http.Message.UriInterface,Psr.Http.Message.UriInterface)">
<summary>
Returns the target URI as a relative reference from the base URI.
This method is the counterpart to resolve():

(string) $target === (string) UriResolver::resolve($base, UriResolver::relativize($base, $target))

One use-case is to use the current request URI as base URI and then generate relative links in your documents
to reduce the document size or offer self-contained downloadable document archives.

$base = new Uri('http://example.com/a/b/');
echo UriResolver::relativize($base, new Uri('http://example.com/a/b/c'));  // prints 'c'.
echo UriResolver::relativize($base, new Uri('http://example.com/a/x/y'));  // prints '../x/y'.
echo UriResolver::relativize($base, new Uri('http://example.com/a/b/?q')); // prints '?q'.
echo UriResolver::relativize($base, new Uri('http://example.org/a/b/'));   // prints '//example.org/a/b/'.

This method also accepts a target that is already relative and will try to relativize it further. Only a
relative-path reference will be returned as-is.

echo UriResolver::relativize($base, new Uri('/a/b/c'));  // prints 'c' as well
</summary>
</member>
<member name="M:GuzzleHttp.Psr7.Utils.caselessRemove(Pchp.Core.Context,Pchp.Core.PhpArray,Pchp.Core.PhpArray)">
<summary>
Remove the items given by the keys, case insensitively from the data.
</summary>
<param name="keys" type="string[]"></param>
</member>
<member name="M:GuzzleHttp.Psr7.Utils.copyToStream(Pchp.Core.Context,Psr.Http.Message.StreamInterface,Psr.Http.Message.StreamInterface,System.Int64)">
<summary>
Copy the contents of a stream into another stream until the given number
of bytes have been read.
</summary>
<param name="source" type="StreamInterface">Stream to read from</param>
<param name="dest" type="StreamInterface">Stream to write to</param>
<param name="maxLen" type="int">Maximum number of bytes to read. Pass -1
to read the entire stream.</param>
<exception cref="RuntimeException">on error.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Utils.copyToString(Pchp.Core.Context,Psr.Http.Message.StreamInterface,System.Int64)">
<summary>
Copy the contents of a stream into a string until the given number of
bytes have been read.
</summary>
<param name="stream" type="StreamInterface">Stream to read</param>
<param name="maxLen" type="int">Maximum number of bytes to read. Pass -1
to read the entire stream.</param>
<exception cref="RuntimeException">on error.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Utils.hash(Pchp.Core.Context,Psr.Http.Message.StreamInterface,Pchp.Core.PhpString,System.Boolean)">
<summary>
Calculate a hash of a stream.
This method reads the entire stream to calculate a rolling hash, based
on PHP's `hash_init` functions.
</summary>
<param name="stream" type="StreamInterface">Stream to calculate the hash for</param>
<param name="algo" type="string">Hash algorithm (e.g. md5, crc32, etc)</param>
<param name="rawOutput" type="bool">Whether or not to use raw output</param>
<exception cref="RuntimeException">on error.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Utils.modifyRequest(Pchp.Core.Context,Psr.Http.Message.RequestInterface,Pchp.Core.PhpArray)">
<summary>
Clone and modify a request with the given changes.
This method is useful for reducing the number of clones needed to mutate
a message.

The changes can be one of:
- method: (string) Changes the HTTP method.
- set_headers: (array) Sets the given headers.
- remove_headers: (array) Remove the given headers.
- body: (mixed) Sets the given body.
- uri: (UriInterface) Set the URI.
- query: (string) Set the query string value of the URI.
- version: (string) Set the protocol version.
</summary>
<param name="request" type="RequestInterface">Request to clone and modify.</param>
<param name="changes" type="array">Changes to apply.</param>
</member>
<member name="M:GuzzleHttp.Psr7.Utils.readLine(Pchp.Core.Context,Psr.Http.Message.StreamInterface,Pchp.Core.PhpValue)">
<summary>
Read a line from the stream up to the maximum allowed buffer length.
</summary>
<param name="stream" type="StreamInterface">Stream to read from</param>
<param name="maxLength" type="int|null">Maximum buffer length</param>
</member>
<member name="M:GuzzleHttp.Psr7.Utils.streamFor(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create a new stream based on the input type.
Options is an associative array that can contain the following keys:
- metadata: Array of custom metadata.
- size: Size of the stream.

This method accepts the following `$resource` types:
- `Psr\Http\Message\StreamInterface`: Returns the value as-is.
- `string`: Creates a stream object that uses the given string as the contents.
- `resource`: Creates a stream object that wraps the given PHP stream resource.
- `Iterator`: If the provided value implements `Iterator`, then a read-only
stream object will be created that wraps the given iterable. Each time the
stream is read from, data from the iterator will fill a buffer and will be
continuously called until the buffer is equal to the requested read size.
Subsequent read calls will first read from the buffer and then call `next`
on the underlying iterator until it is exhausted.
- `object` with `__toString()`: If the object has the `__toString()` method,
the object will be cast to a string and then a stream will be returned that
uses the string value.
- `NULL`: When `null` is passed, an empty stream object is returned.
- `callable` When a callable is passed, a read-only stream object will be
created that invokes the given callable. The callable is invoked with the
number of suggested bytes to read. The callable can return any number of
bytes, but MUST return `false` when there is no more data to return. The
stream object that wraps the callable will invoke the callable until the
number of requested bytes are available. Any additional bytes will be
buffered and used in subsequent reads.
</summary>
<param name="resource" type="resource|string|int|float|bool|StreamInterface|callable|\Iterator|null">Entity body data</param>
<exception cref="InvalidArgumentException">if the $resource arg is not valid.</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Utils.tryFopen(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Safely opens a PHP stream resource using a filename.
When fopen fails, PHP normally raises a warning. This function adds an
error handler that checks for errors and throws an exception instead.
</summary>
<param name="filename" type="string">File to open</param>
<param name="mode" type="string">Mode used to open the file</param>
<exception cref="RuntimeException">if the file cannot be opened</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Utils.tryGetContents(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Safely gets the contents of a given stream.
When stream_get_contents fails, PHP normally raises a warning. This
function adds an error handler that checks for errors and throws an
exception instead.
</summary>
<param name="stream" type="resource"></param>
<exception cref="RuntimeException">if the stream cannot be read</exception>
</member>
<member name="M:GuzzleHttp.Psr7.Utils.uriFor(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Returns a UriInterface for the given value.
This function accepts a string or UriInterface and returns a
UriInterface for the given value. If the value is already a
UriInterface, it is returned as-is.
</summary>
<param name="uri" type="string|UriInterface"></param>
</member>
<member name="M:Psr.Http.Client.ClientInterface.sendRequest(Psr.Http.Message.RequestInterface)">
<summary>
Sends a PSR-7 request and returns a PSR-7 response.
</summary>
<param name="request" type="RequestInterface"></param>
<exception cref="Psr.Http.Client.ClientExceptionInterface">If an error happens while processing the request.</exception>
</member>
<member name="M:Psr.Http.Client.NetworkExceptionInterface.getRequest">
<summary>
Returns the request.
The request object MAY be a different object from the one passed to ClientInterface::sendRequest()
</summary>
</member>
<member name="M:Psr.Http.Client.RequestExceptionInterface.getRequest">
<summary>
Returns the request.
The request object MAY be a different object from the one passed to ClientInterface::sendRequest()
</summary>
</member>
<member name="M:Psr.Http.Message.RequestFactoryInterface.createRequest(Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Create a new request.
</summary>
<param name="method" type="string">The HTTP method associated with the request.</param>
<param name="uri" type="UriInterface|string">The URI associated with the request. If
the value is a string, the factory MUST create a UriInterface
instance based on it.</param>
</member>
<member name="M:Psr.Http.Message.ResponseFactoryInterface.createResponse(System.Int64,Pchp.Core.PhpString)">
<summary>
Create a new response.
</summary>
<param name="code" type="int">HTTP status code; defaults to 200</param>
<param name="reasonPhrase" type="string">Reason phrase to associate with status code
in generated response; if none is provided implementations MAY use
the defaults as suggested in the HTTP specification.</param>
</member>
<member name="M:Psr.Http.Message.ServerRequestFactoryInterface.createServerRequest(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpArray)">
<summary>
Create a new server request.
Note that server-params are taken precisely as given - no parsing/processing
of the given values is performed, and, in particular, no attempt is made to
determine the HTTP method or URI, which must be provided explicitly.
</summary>
<param name="method" type="string">The HTTP method associated with the request.</param>
<param name="uri" type="UriInterface|string">The URI associated with the request. If
the value is a string, the factory MUST create a UriInterface
instance based on it.</param>
<param name="serverParams" type="array">Array of SAPI parameters with which to seed
the generated request instance.</param>
</member>
<member name="M:Psr.Http.Message.StreamFactoryInterface.createStream(Pchp.Core.PhpString)">
<summary>
Create a new stream from a string.
The stream SHOULD be created with a temporary resource.
</summary>
<param name="content" type="string">String content with which to populate the stream.</param>
</member>
<member name="M:Psr.Http.Message.StreamFactoryInterface.createStreamFromFile(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Create a stream from an existing file.
The file MUST be opened using the given mode, which may be any mode
supported by the `fopen` function.

The `$filename` MAY be any string supported by `fopen()`.
</summary>
<param name="filename" type="string">Filename or stream URI to use as basis of stream.</param>
<param name="mode" type="string">Mode with which to open the underlying filename/stream.</param>
<exception cref="RuntimeException">If the file cannot be opened.</exception>
<exception cref="InvalidArgumentException">If the mode is invalid.</exception>
</member>
<member name="M:Psr.Http.Message.StreamFactoryInterface.createStreamFromResource(Pchp.Core.PhpValue)">
<summary>
Create a new stream from an existing resource.
The stream MUST be readable and may be writable.
</summary>
<param name="resource" type="resource">PHP resource to use as basis of stream.</param>
</member>
<member name="M:Psr.Http.Message.UploadedFileFactoryInterface.createUploadedFile(Psr.Http.Message.StreamInterface,Pchp.Core.PhpValue,System.Int64,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Create a new uploaded file.
If a size is not provided it will be determined by checking the size of
the file.
</summary>
<param name="stream" type="StreamInterface">Underlying stream representing the
uploaded file content.</param>
<param name="size" type="int">in bytes</param>
<param name="error" type="int">PHP file upload error</param>
<param name="clientFilename" type="string">Filename as provided by the client, if any.</param>
<param name="clientMediaType" type="string">Media type as provided by the client, if any.</param>
<exception cref="InvalidArgumentException">If the file resource is not readable.</exception>
</member>
<member name="M:Psr.Http.Message.UriFactoryInterface.createUri(Pchp.Core.PhpString)">
<summary>
Create a new URI.
</summary>
<param name="uri" type="string"></param>
<exception cref="InvalidArgumentException">If the given URI cannot be parsed.</exception>
</member>
<member name="M:Psr.Http.Message.MessageInterface.getProtocolVersion">
<summary>
Retrieves the HTTP protocol version as a string.
The string MUST contain only the HTTP version number (e.g., "1.1", "1.0").
</summary>
<returns>HTTP protocol version.</returns>
</member>
<member name="M:Psr.Http.Message.MessageInterface.withProtocolVersion(Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified HTTP protocol version.
The version string MUST contain only the HTTP version number (e.g.,
"1.1", "1.0").

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
new protocol version.
</summary>
<param name="version" type="string">HTTP protocol version</param>
</member>
<member name="M:Psr.Http.Message.MessageInterface.getHeaders">
<summary>
Retrieves all message header values.
The keys represent the header name as it will be sent over the wire, and
each value is an array of strings associated with the header.

// Represent the headers as a string
foreach ($message-&gt;getHeaders() as $name =&gt; $values) {
echo $name . ": " . implode(", ", $values);
}

// Emit headers iteratively:
foreach ($message-&gt;getHeaders() as $name =&gt; $values) {
foreach ($values as $value) {
header(sprintf('%s: %s', $name, $value), false);
}
}

While header names are not case-sensitive, getHeaders() will preserve the
exact case in which headers were originally specified.
</summary>
<returns>Returns an associative array of the message's headers. Each
key MUST be a header name, and each value MUST be an array of strings
for that header.</returns>
</member>
<member name="M:Psr.Http.Message.MessageInterface.hasHeader(Pchp.Core.PhpValue)">
<summary>
Checks if a header exists by the given case-insensitive name.
</summary>
<param name="name" type="string">Case-insensitive header field name.</param>
<returns>Returns true if any header names match the given header
name using a case-insensitive string comparison. Returns false if
no matching header name is found in the message.</returns>
</member>
<member name="M:Psr.Http.Message.MessageInterface.getHeader(Pchp.Core.PhpValue)">
<summary>
Retrieves a message header value by the given case-insensitive name.
This method returns an array of all the header values of the given
case-insensitive header name.

If the header does not appear in the message, this method MUST return an
empty array.
</summary>
<param name="name" type="string">Case-insensitive header field name.</param>
<returns>An array of string values as provided for the given
header. If the header does not appear in the message, this method MUST
return an empty array.</returns>
</member>
<member name="M:Psr.Http.Message.MessageInterface.getHeaderLine(Pchp.Core.PhpValue)">
<summary>
Retrieves a comma-separated string of the values for a single header.
This method returns all of the header values of the given
case-insensitive header name as a string concatenated together using
a comma.

NOTE: Not all header values may be appropriately represented using
comma concatenation. For such headers, use getHeader() instead
and supply your own delimiter when concatenating.

If the header does not appear in the message, this method MUST return
an empty string.
</summary>
<param name="name" type="string">Case-insensitive header field name.</param>
<returns>A string of values as provided for the given header
concatenated together using a comma. If the header does not appear in
the message, this method MUST return an empty string.</returns>
</member>
<member name="M:Psr.Http.Message.MessageInterface.withHeader(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Return an instance with the provided value replacing the specified header.
While header names are case-insensitive, the casing of the header will
be preserved by this function, and returned from getHeaders().

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
new and/or updated header and value.
</summary>
<param name="name" type="string">Case-insensitive header field name.</param>
<param name="value" type="string|string[]">Header value(s).</param>
<exception cref="InvalidArgumentException">for invalid header names or values.</exception>
</member>
<member name="M:Psr.Http.Message.MessageInterface.withAddedHeader(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified header appended with the given value.
Existing values for the specified header will be maintained. The new
value(s) will be appended to the existing list. If the header did not
exist previously, it will be added.

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
new header and/or value.
</summary>
<param name="name" type="string">Case-insensitive header field name to add.</param>
<param name="value" type="string|string[]">Header value(s).</param>
<exception cref="InvalidArgumentException">for invalid header names or values.</exception>
</member>
<member name="M:Psr.Http.Message.MessageInterface.withoutHeader(Pchp.Core.PhpValue)">
<summary>
Return an instance without the specified header.
Header resolution MUST be done without case-sensitivity.

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that removes
the named header.
</summary>
<param name="name" type="string">Case-insensitive header field name to remove.</param>
</member>
<member name="M:Psr.Http.Message.MessageInterface.getBody">
<summary>
Gets the body of the message.
</summary>
<returns>Returns the body as a stream.</returns>
</member>
<member name="M:Psr.Http.Message.MessageInterface.withBody(Psr.Http.Message.StreamInterface)">
<summary>
Return an instance with the specified message body.
The body MUST be a StreamInterface object.

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return a new instance that has the
new body stream.
</summary>
<param name="body" type="StreamInterface">Body.</param>
<exception cref="InvalidArgumentException">When the body is not valid.</exception>
</member>
<member name="M:Psr.Http.Message.RequestInterface.getRequestTarget">
<summary>
Retrieves the message's request target.
Retrieves the message's request-target either as it will appear (for
clients), as it appeared at request (for servers), or as it was
specified for the instance (see withRequestTarget()).

In most cases, this will be the origin-form of the composed URI,
unless a value was provided to the concrete implementation (see
withRequestTarget() below).

If no URI is available, and no request-target has been specifically
provided, this method MUST return the string "/".
</summary>
</member>
<member name="M:Psr.Http.Message.RequestInterface.withRequestTarget(Pchp.Core.PhpValue)">
<summary>
Return an instance with the specific request-target.
If the request needs a non-origin-form request-target — e.g., for
specifying an absolute-form, authority-form, or asterisk-form —
this method may be used to create an instance with the specified
request-target, verbatim.

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
changed request target.
</summary>
<param name="requestTarget" type="mixed"></param>
</member>
<member name="M:Psr.Http.Message.RequestInterface.getMethod">
<summary>
Retrieves the HTTP method of the request.
</summary>
<returns>Returns the request method.</returns>
</member>
<member name="M:Psr.Http.Message.RequestInterface.withMethod(Pchp.Core.PhpValue)">
<summary>
Return an instance with the provided HTTP method.
While HTTP method names are typically all uppercase characters, HTTP
method names are case-sensitive and thus implementations SHOULD NOT
modify the given string.

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
changed request method.
</summary>
<param name="method" type="string">Case-sensitive method.</param>
<exception cref="InvalidArgumentException">for invalid HTTP methods.</exception>
</member>
<member name="M:Psr.Http.Message.RequestInterface.getUri">
<summary>
Retrieves the URI instance.
This method MUST return a UriInterface instance.
</summary>
<returns>Returns a UriInterface instance
representing the URI of the request.</returns>
</member>
<member name="M:Psr.Http.Message.RequestInterface.withUri(Psr.Http.Message.UriInterface,Pchp.Core.PhpValue)">
<summary>
Returns an instance with the provided URI.
This method MUST update the Host header of the returned request by
default if the URI contains a host component. If the URI does not
contain a host component, any pre-existing Host header MUST be carried
over to the returned request.

You can opt-in to preserving the original state of the Host header by
setting `$preserveHost` to `true`. When `$preserveHost` is set to
`true`, this method interacts with the Host header in the following ways:

- If the Host header is missing or empty, and the new URI contains
a host component, this method MUST update the Host header in the returned
request.
- If the Host header is missing or empty, and the new URI does not contain a
host component, this method MUST NOT update the Host header in the returned
request.
- If a Host header is present and non-empty, this method MUST NOT update
the Host header in the returned request.

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
new UriInterface instance.
</summary>
<param name="uri" type="UriInterface">New request URI to use.</param>
<param name="preserveHost" type="bool">Preserve the original state of the Host header.</param>
</member>
<member name="M:Psr.Http.Message.ResponseInterface.getStatusCode">
<summary>
Gets the response status code.
The status code is a 3-digit integer result code of the server's attempt
to understand and satisfy the request.
</summary>
<returns>Status code.</returns>
</member>
<member name="M:Psr.Http.Message.ResponseInterface.withStatus(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified status code and, optionally, reason phrase.
If no reason phrase is specified, implementations MAY choose to default
to the RFC 7231 or IANA recommended reason phrase for the response's
status code.

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
updated status and reason phrase.
</summary>
<param name="code" type="int">The 3-digit integer result code to set.</param>
<param name="reasonPhrase" type="string">The reason phrase to use with the
provided status code; if none is provided, implementations MAY
use the defaults as suggested in the HTTP specification.</param>
<exception cref="InvalidArgumentException">For invalid status code arguments.</exception>
</member>
<member name="M:Psr.Http.Message.ResponseInterface.getReasonPhrase">
<summary>
Gets the response reason phrase associated with the status code.
Because a reason phrase is not a required element in a response
status line, the reason phrase value MAY be null. Implementations MAY
choose to return the default RFC 7231 recommended reason phrase (or those
listed in the IANA HTTP Status Code Registry) for the response's
status code.
</summary>
<returns>Reason phrase; must return an empty string if none present.</returns>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.getServerParams">
<summary>
Retrieve server parameters.
Retrieves data related to the incoming request environment,
typically derived from PHP's $_SERVER superglobal. The data IS NOT
REQUIRED to originate from $_SERVER.
</summary>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.getCookieParams">
<summary>
Retrieve cookies.
Retrieves cookies sent by the client to the server.

The data MUST be compatible with the structure of the $_COOKIE
superglobal.
</summary>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.withCookieParams(Pchp.Core.PhpArray)">
<summary>
Return an instance with the specified cookies.
The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST
be compatible with the structure of $_COOKIE. Typically, this data will
be injected at instantiation.

This method MUST NOT update the related Cookie header of the request
instance, nor related values in the server params.

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
updated cookie values.
</summary>
<param name="cookies" type="array">Array of key/value pairs representing cookies.</param>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.getQueryParams">
<summary>
Retrieve query string arguments.
Retrieves the deserialized query string arguments, if any.

Note: the query params might not be in sync with the URI or server
params. If you need to ensure you are only getting the original
values, you may need to parse the query string from `getUri()-&gt;getQuery()`
or from the `QUERY_STRING` server param.
</summary>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.withQueryParams(Pchp.Core.PhpArray)">
<summary>
Return an instance with the specified query string arguments.
These values SHOULD remain immutable over the course of the incoming
request. They MAY be injected during instantiation, such as from PHP's
$_GET superglobal, or MAY be derived from some other value such as the
URI. In cases where the arguments are parsed from the URI, the data
MUST be compatible with what PHP's parse_str() would return for
purposes of how duplicate query parameters are handled, and how nested
sets are handled.

Setting query string arguments MUST NOT change the URI stored by the
request, nor the values in the server params.

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
updated query string arguments.
</summary>
<param name="query" type="array">Array of query string arguments, typically from
$_GET.</param>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.getUploadedFiles">
<summary>
Retrieve normalized file upload data.
This method returns upload metadata in a normalized tree, with each leaf
an instance of Psr\Http\Message\UploadedFileInterface.

These values MAY be prepared from $_FILES or the message body during
instantiation, or MAY be injected via withUploadedFiles().
</summary>
<returns>An array tree of UploadedFileInterface instances; an empty
array MUST be returned if no data is present.</returns>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.withUploadedFiles(Pchp.Core.PhpArray)">
<summary>
Create a new instance with the specified uploaded files.
This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
updated body parameters.
</summary>
<param name="uploadedFiles" type="array">An array tree of UploadedFileInterface instances.</param>
<exception cref="InvalidArgumentException">if an invalid structure is provided.</exception>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.getParsedBody">
<summary>
Retrieve any parameters provided in the request body.
If the request Content-Type is either application/x-www-form-urlencoded
or multipart/form-data, and the request method is POST, this method MUST
return the contents of $_POST.

Otherwise, this method may return any results of deserializing
the request body content; as parsing returns structured content, the
potential types MUST be arrays or objects only. A null value indicates
the absence of body content.
</summary>
<returns>The deserialized body parameters, if any.
These will typically be an array or object.</returns>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.withParsedBody(Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified body parameters.
These MAY be injected during instantiation.

If the request Content-Type is either application/x-www-form-urlencoded
or multipart/form-data, and the request method is POST, use this method
ONLY to inject the contents of $_POST.

The data IS NOT REQUIRED to come from $_POST, but MUST be the results of
deserializing the request body content. Deserialization/parsing returns
structured data, and, as such, this method ONLY accepts arrays or objects,
or a null value if nothing was available to parse.

As an example, if content negotiation determines that the request data
is a JSON payload, this method could be used to create a request
instance with the deserialized parameters.

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
updated body parameters.
</summary>
<param name="data" type="null|array|object">The deserialized body data. This will
typically be in an array or object.</param>
<exception cref="InvalidArgumentException">if an unsupported argument type is
provided.</exception>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.getAttributes">
<summary>
Retrieve attributes derived from the request.
The request "attributes" may be used to allow injection of any
parameters derived from the request: e.g., the results of path
match operations; the results of decrypting cookies; the results of
deserializing non-form-encoded message bodies; etc. Attributes
will be application and request specific, and CAN be mutable.
</summary>
<returns>Attributes derived from the request.</returns>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.getAttribute(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Retrieve a single derived request attribute.
Retrieves a single derived request attribute as described in
getAttributes(). If the attribute has not been previously set, returns
the default value as provided.

This method obviates the need for a hasAttribute() method, as it allows
specifying a default value to return if the attribute is not found.
</summary>
<param name="name" type="string">The attribute name.</param>
<param name="default" type="mixed">Default value to return if the attribute does not exist.</param>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.withAttribute(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified derived request attribute.
This method allows setting a single derived request attribute as
described in getAttributes().

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that has the
updated attribute.
</summary>
<param name="name" type="string">The attribute name.</param>
<param name="value" type="mixed">The value of the attribute.</param>
</member>
<member name="M:Psr.Http.Message.ServerRequestInterface.withoutAttribute(Pchp.Core.PhpValue)">
<summary>
Return an instance that removes the specified derived request attribute.
This method allows removing a single derived request attribute as
described in getAttributes().

This method MUST be implemented in such a way as to retain the
immutability of the message, and MUST return an instance that removes
the attribute.
</summary>
<param name="name" type="string">The attribute name.</param>
</member>
<member name="M:Psr.Http.Message.StreamInterface.__toString">
<summary>
Reads all data from the stream into a string, from the beginning to end.
This method MUST attempt to seek to the beginning of the stream before
reading data and read the stream until the end is reached.

Warning: This could attempt to load a large amount of data into memory.

This method MUST NOT raise an exception in order to conform with PHP's
string casting operations.
</summary>
</member>
<member name="M:Psr.Http.Message.StreamInterface.close">
<summary>
Closes the stream and any underlying resources.
</summary>
</member>
<member name="M:Psr.Http.Message.StreamInterface.detach">
<summary>
Separates any underlying resources from the stream.
After the stream has been detached, the stream is in an unusable state.
</summary>
<returns>Underlying PHP stream, if any</returns>
</member>
<member name="M:Psr.Http.Message.StreamInterface.getSize">
<summary>
Get the size of the stream if known.
</summary>
<returns>Returns the size in bytes if known, or null if unknown.</returns>
</member>
<member name="M:Psr.Http.Message.StreamInterface.tell">
<summary>
Returns the current position of the file read/write pointer
</summary>
<returns>Position of the file pointer</returns>
<exception cref="RuntimeException">on error.</exception>
</member>
<member name="M:Psr.Http.Message.StreamInterface.eof">
<summary>
Returns true if the stream is at the end of the stream.
</summary>
</member>
<member name="M:Psr.Http.Message.StreamInterface.isSeekable">
<summary>
Returns whether or not the stream is seekable.
</summary>
</member>
<member name="M:Psr.Http.Message.StreamInterface.seek(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Seek to a position in the stream.
</summary>
<param name="offset" type="int">Stream offset</param>
<param name="whence" type="int">Specifies how the cursor position will be calculated
based on the seek offset. Valid values are identical to the built-in
PHP $whence values for `fseek()`.  SEEK_SET: Set position equal to
offset bytes SEEK_CUR: Set position to current location plus offset
SEEK_END: Set position to end-of-stream plus offset.</param>
<exception cref="RuntimeException">on failure.</exception>
</member>
<member name="M:Psr.Http.Message.StreamInterface.rewind">
<summary>
Seek to the beginning of the stream.
If the stream is not seekable, this method will raise an exception;
otherwise, it will perform a seek(0).
</summary>
<exception cref="RuntimeException">on failure.</exception>
</member>
<member name="M:Psr.Http.Message.StreamInterface.isWritable">
<summary>
Returns whether or not the stream is writable.
</summary>
</member>
<member name="M:Psr.Http.Message.StreamInterface.write(Pchp.Core.PhpValue)">
<summary>
Write data to the stream.
</summary>
<param name="string" type="string">The string that is to be written.</param>
<returns>Returns the number of bytes written to the stream.</returns>
<exception cref="RuntimeException">on failure.</exception>
</member>
<member name="M:Psr.Http.Message.StreamInterface.isReadable">
<summary>
Returns whether or not the stream is readable.
</summary>
</member>
<member name="M:Psr.Http.Message.StreamInterface.read(Pchp.Core.PhpValue)">
<summary>
Read data from the stream.
</summary>
<param name="length" type="int">Read up to $length bytes from the object and return
them. Fewer than $length bytes may be returned if underlying stream
call returns fewer bytes.</param>
<returns>Returns the data read from the stream, or an empty string
if no bytes are available.</returns>
<exception cref="RuntimeException">if an error occurs.</exception>
</member>
<member name="M:Psr.Http.Message.StreamInterface.getContents">
<summary>
Returns the remaining contents in a string
</summary>
<exception cref="RuntimeException">if unable to read or an error occurs while
reading.</exception>
</member>
<member name="M:Psr.Http.Message.StreamInterface.getMetadata(Pchp.Core.PhpValue)">
<summary>
Get stream metadata as an associative array or retrieve a specific key.
The keys returned are identical to the keys returned from PHP's
stream_get_meta_data() function.
</summary>
<param name="key" type="string">Specific metadata to retrieve.</param>
<returns>Returns an associative array if no key is
provided. Returns a specific key value if a key is provided and the
value is found, or null if the key is not found.</returns>
</member>
<member name="M:Psr.Http.Message.UploadedFileInterface.getStream">
<summary>
Retrieve a stream representing the uploaded file.
This method MUST return a StreamInterface instance, representing the
uploaded file. The purpose of this method is to allow utilizing native PHP
stream functionality to manipulate the file upload, such as
stream_copy_to_stream() (though the result will need to be decorated in a
native PHP stream wrapper to work with such functions).

If the moveTo() method has been called previously, this method MUST raise
an exception.
</summary>
<returns>Stream representation of the uploaded file.</returns>
<exception cref="RuntimeException">in cases when no stream is available or can be
created.</exception>
</member>
<member name="M:Psr.Http.Message.UploadedFileInterface.moveTo(Pchp.Core.PhpValue)">
<summary>
Move the uploaded file to a new location.
Use this method as an alternative to move_uploaded_file(). This method is
guaranteed to work in both SAPI and non-SAPI environments.
Implementations must determine which environment they are in, and use the
appropriate method (move_uploaded_file(), rename(), or a stream
operation) to perform the operation.

$targetPath may be an absolute path, or a relative path. If it is a
relative path, resolution should be the same as used by PHP's rename()
function.

The original file or stream MUST be removed on completion.

If this method is called more than once, any subsequent calls MUST raise
an exception.

When used in an SAPI environment where $_FILES is populated, when writing
files via moveTo(), is_uploaded_file() and move_uploaded_file() SHOULD be
used to ensure permissions and upload status are verified correctly.

If you wish to move to a stream, use getStream(), as SAPI operations
cannot guarantee writing to stream destinations.
</summary>
<param name="targetPath" type="string">Path to which to move the uploaded file.</param>
<exception cref="InvalidArgumentException">if the $targetPath specified is invalid.</exception>
<exception cref="RuntimeException">on any error during the move operation, or on
the second or subsequent call to the method.</exception>
</member>
<member name="M:Psr.Http.Message.UploadedFileInterface.getSize">
<summary>
Retrieve the file size.
Implementations SHOULD return the value stored in the "size" key of
the file in the $_FILES array if available, as PHP calculates this based
on the actual size transmitted.
</summary>
<returns>The file size in bytes or null if unknown.</returns>
</member>
<member name="M:Psr.Http.Message.UploadedFileInterface.getError">
<summary>
Retrieve the error associated with the uploaded file.
The return value MUST be one of PHP's UPLOAD_ERR_XXX constants.

If the file was uploaded successfully, this method MUST return
UPLOAD_ERR_OK.

Implementations SHOULD return the value stored in the "error" key of
the file in the $_FILES array.
</summary>
<returns>One of PHP's UPLOAD_ERR_XXX constants.</returns>
</member>
<member name="M:Psr.Http.Message.UploadedFileInterface.getClientFilename">
<summary>
Retrieve the filename sent by the client.
Do not trust the value returned by this method. A client could send
a malicious filename with the intention to corrupt or hack your
application.

Implementations SHOULD return the value stored in the "name" key of
the file in the $_FILES array.
</summary>
<returns>The filename sent by the client or null if none
was provided.</returns>
</member>
<member name="M:Psr.Http.Message.UploadedFileInterface.getClientMediaType">
<summary>
Retrieve the media type sent by the client.
Do not trust the value returned by this method. A client could send
a malicious media type with the intention to corrupt or hack your
application.

Implementations SHOULD return the value stored in the "type" key of
the file in the $_FILES array.
</summary>
<returns>The media type sent by the client or null if none
was provided.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.getScheme">
<summary>
Retrieve the scheme component of the URI.
If no scheme is present, this method MUST return an empty string.

The value returned MUST be normalized to lowercase, per RFC 3986
Section 3.1.

The trailing ":" character is not part of the scheme and MUST NOT be
added.
</summary>
<returns>The URI scheme.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.getAuthority">
<summary>
Retrieve the authority component of the URI.
If no authority information is present, this method MUST return an empty
string.

The authority syntax of the URI is:

&lt;pre&gt;
[user-info@]host[:port]
&lt;/pre&gt;

If the port component is not set or is the standard port for the current
scheme, it SHOULD NOT be included.
</summary>
<returns>The URI authority, in "[user-info@]host[:port]" format.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.getUserInfo">
<summary>
Retrieve the user information component of the URI.
If no user information is present, this method MUST return an empty
string.

If a user is present in the URI, this will return that value;
additionally, if the password is also present, it will be appended to the
user value, with a colon (":") separating the values.

The trailing "@" character is not part of the user information and MUST
NOT be added.
</summary>
<returns>The URI user information, in "username[:password]" format.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.getHost">
<summary>
Retrieve the host component of the URI.
If no host is present, this method MUST return an empty string.

The value returned MUST be normalized to lowercase, per RFC 3986
Section 3.2.2.
</summary>
<returns>The URI host.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.getPort">
<summary>
Retrieve the port component of the URI.
If a port is present, and it is non-standard for the current scheme,
this method MUST return it as an integer. If the port is the standard port
used with the current scheme, this method SHOULD return null.

If no port is present, and no scheme is present, this method MUST return
a null value.

If no port is present, but a scheme is present, this method MAY return
the standard port for that scheme, but SHOULD return null.
</summary>
<returns>The URI port.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.getPath">
<summary>
Retrieve the path component of the URI.
The path can either be empty or absolute (starting with a slash) or
rootless (not starting with a slash). Implementations MUST support all
three syntaxes.

Normally, the empty path "" and absolute path "/" are considered equal as
defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically
do this normalization because in contexts with a trimmed base path, e.g.
the front controller, this difference becomes significant. It's the task
of the user to handle both "" and "/".

The value returned MUST be percent-encoded, but MUST NOT double-encode
any characters. To determine what characters to encode, please refer to
RFC 3986, Sections 2 and 3.3.

As an example, if the value should include a slash ("/") not intended as
delimiter between path segments, that value MUST be passed in encoded
form (e.g., "%2F") to the instance.
</summary>
<returns>The URI path.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.getQuery">
<summary>
Retrieve the query string of the URI.
If no query string is present, this method MUST return an empty string.

The leading "?" character is not part of the query and MUST NOT be
added.

The value returned MUST be percent-encoded, but MUST NOT double-encode
any characters. To determine what characters to encode, please refer to
RFC 3986, Sections 2 and 3.4.

As an example, if a value in a key/value pair of the query string should
include an ampersand ("&amp;") not intended as a delimiter between values,
that value MUST be passed in encoded form (e.g., "%26") to the instance.
</summary>
<returns>The URI query string.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.getFragment">
<summary>
Retrieve the fragment component of the URI.
If no fragment is present, this method MUST return an empty string.

The leading "#" character is not part of the fragment and MUST NOT be
added.

The value returned MUST be percent-encoded, but MUST NOT double-encode
any characters. To determine what characters to encode, please refer to
RFC 3986, Sections 2 and 3.5.
</summary>
<returns>The URI fragment.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.withScheme(Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified scheme.
This method MUST retain the state of the current instance, and return
an instance that contains the specified scheme.

Implementations MUST support the schemes "http" and "https" case
insensitively, and MAY accommodate other schemes if required.

An empty scheme is equivalent to removing the scheme.
</summary>
<param name="scheme" type="string">The scheme to use with the new instance.</param>
<returns>A new instance with the specified scheme.</returns>
<exception cref="InvalidArgumentException">for invalid or unsupported schemes.</exception>
</member>
<member name="M:Psr.Http.Message.UriInterface.withUserInfo(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified user information.
This method MUST retain the state of the current instance, and return
an instance that contains the specified user information.

Password is optional, but the user information MUST include the
user; an empty string for the user is equivalent to removing user
information.
</summary>
<param name="user" type="string">The user name to use for authority.</param>
<param name="password" type="null|string">The password associated with $user.</param>
<returns>A new instance with the specified user information.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.withHost(Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified host.
This method MUST retain the state of the current instance, and return
an instance that contains the specified host.

An empty host value is equivalent to removing the host.
</summary>
<param name="host" type="string">The hostname to use with the new instance.</param>
<returns>A new instance with the specified host.</returns>
<exception cref="InvalidArgumentException">for invalid hostnames.</exception>
</member>
<member name="M:Psr.Http.Message.UriInterface.withPort(Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified port.
This method MUST retain the state of the current instance, and return
an instance that contains the specified port.

Implementations MUST raise an exception for ports outside the
established TCP and UDP port ranges.

A null value provided for the port is equivalent to removing the port
information.
</summary>
<param name="port" type="null|int">The port to use with the new instance; a null value
removes the port information.</param>
<returns>A new instance with the specified port.</returns>
<exception cref="InvalidArgumentException">for invalid ports.</exception>
</member>
<member name="M:Psr.Http.Message.UriInterface.withPath(Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified path.
This method MUST retain the state of the current instance, and return
an instance that contains the specified path.

The path can either be empty or absolute (starting with a slash) or
rootless (not starting with a slash). Implementations MUST support all
three syntaxes.

If the path is intended to be domain-relative rather than path relative then
it must begin with a slash ("/"). Paths not starting with a slash ("/")
are assumed to be relative to some base path known to the application or
consumer.

Users can provide both encoded and decoded path characters.
Implementations ensure the correct encoding as outlined in getPath().
</summary>
<param name="path" type="string">The path to use with the new instance.</param>
<returns>A new instance with the specified path.</returns>
<exception cref="InvalidArgumentException">for invalid paths.</exception>
</member>
<member name="M:Psr.Http.Message.UriInterface.withQuery(Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified query string.
This method MUST retain the state of the current instance, and return
an instance that contains the specified query string.

Users can provide both encoded and decoded query characters.
Implementations ensure the correct encoding as outlined in getQuery().

An empty query string value is equivalent to removing the query string.
</summary>
<param name="query" type="string">The query string to use with the new instance.</param>
<returns>A new instance with the specified query string.</returns>
<exception cref="InvalidArgumentException">for invalid query strings.</exception>
</member>
<member name="M:Psr.Http.Message.UriInterface.withFragment(Pchp.Core.PhpValue)">
<summary>
Return an instance with the specified URI fragment.
This method MUST retain the state of the current instance, and return
an instance that contains the specified URI fragment.

Users can provide both encoded and decoded fragment characters.
Implementations ensure the correct encoding as outlined in getFragment().

An empty fragment value is equivalent to removing the fragment.
</summary>
<param name="fragment" type="string">The fragment to use with the new instance.</param>
<returns>A new instance with the specified fragment.</returns>
</member>
<member name="M:Psr.Http.Message.UriInterface.__toString">
<summary>
Return the string representation as a URI reference.
Depending on which components of the URI are present, the resulting
string is either a full URI or relative reference according to RFC 3986,
Section 4.1. The method concatenates the various components of the URI,
using the appropriate delimiters:

- If a scheme is present, it MUST be suffixed by ":".
- If an authority is present, it MUST be prefixed by "//".
- The path can be concatenated without delimiters. But there are two
cases where the path has to be adjusted to make the URI reference
valid as PHP does not allow to throw an exception in __toString():
- If the path is rootless and an authority is present, the path MUST
be prefixed by "/".
- If the path is starting with more than one "/" and no authority is
present, the starting slashes MUST be reduced to one.
- If a query is present, it MUST be prefixed by "?".
- If a fragment is present, it MUST be prefixed by "#".
</summary>
</member>
<member name="M:Sop.AESKW.AESKeyWrapAlgorithm.wrap(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Wrap a key using given key encryption key.
Key length must be at least 64 bits (8 octets) and a multiple
of 64 bits (8 octets). Use `wrapPad()` to wrap a key of arbitrary length.

Key encryption key must have a size of underlying AES algorithm,
ie. 128, 196 or 256 bits.
</summary>
<param name="key" type="string">Key to wrap</param>
<param name="kek" type="string">Key encryption key</param>
<exception cref="RuntimeException">For invalid inputs</exception>
<returns>Ciphertext</returns>
</member>
<member name="M:Sop.AESKW.AESKeyWrapAlgorithm.unwrap(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Unwrap a key from a ciphertext using given key encryption key.
</summary>
<param name="ciphertext" type="string">Ciphertext of the wrapped key</param>
<param name="kek" type="string">Key encryption key</param>
<exception cref="RuntimeException">For invalid inputs</exception>
<returns>Unwrapped key</returns>
</member>
<member name="M:Sop.AESKW.AESKeyWrapAlgorithm.wrapPad(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Wrap a key of arbitrary length using given key encryption key.
This variant of wrapping does not place any restriction on key size.

Key encryption key has the same restrictions as with `wrap()` method.
</summary>
<param name="key" type="string">Key to wrap</param>
<param name="kek" type="string">Key encryption key</param>
<exception cref="RuntimeException">For invalid inputs</exception>
<returns>Ciphertext</returns>
</member>
<member name="M:Sop.AESKW.AESKeyWrapAlgorithm.unwrapPad(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Unwrap a key from a padded ciphertext using given key encryption key.
This variant of unwrapping must be used if the key was wrapped using `wrapPad()`.
</summary>
<param name="ciphertext" type="string">Ciphertext of the wrapped and padded key</param>
<param name="kek" type="string">Key encryption key</param>
<exception cref="RuntimeException">For invalid inputs</exception>
<returns>Unwrapped key</returns>
</member>
<member name="M:Sop.AESKW.AESKW128._cipherMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.AESKW.AESKW128._keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.AESKW.AESKW192._cipherMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.AESKW.AESKW192._keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.AESKW.AESKW256._cipherMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.AESKW.AESKW256._keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.AESKW.Algorithm.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="iv" type="string">Initial value</param>
</member>
<member name="M:Sop.AESKW.Algorithm.wrap(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Wrap a key using given key encryption key.
Key length must be at least 64 bits (8 octets) and a multiple
of 64 bits (8 octets). Use `wrapPad()` to wrap a key of arbitrary length.

Key encryption key must have a size of underlying AES algorithm,
ie. 128, 196 or 256 bits.
</summary>
<param name="key" type="string">Key to wrap</param>
<param name="kek" type="string">Key encryption key</param>
<exception cref="UnexpectedValueException">If the key length is invalid</exception>
<returns>Ciphertext</returns>
</member>
<member name="M:Sop.AESKW.Algorithm.unwrap(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Unwrap a key from a ciphertext using given key encryption key.
</summary>
<param name="ciphertext" type="string">Ciphertext of the wrapped key</param>
<param name="kek" type="string">Key encryption key</param>
<exception cref="UnexpectedValueException">If the ciphertext is invalid</exception>
<returns>Unwrapped key</returns>
</member>
<member name="M:Sop.AESKW.Algorithm.wrapPad(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Wrap a key of arbitrary length using given key encryption key.
This variant of wrapping does not place any restriction on key size.

Key encryption key has the same restrictions as with `wrap()` method.
</summary>
<param name="key" type="string">Key to wrap</param>
<param name="kek" type="string">Key encryption key</param>
<exception cref="UnexpectedValueException">If the key length is invalid</exception>
<returns>Ciphertext</returns>
</member>
<member name="M:Sop.AESKW.Algorithm.unwrapPad(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Unwrap a key from a padded ciphertext using given key encryption key.
This variant of unwrapping must be used if the key was wrapped using `wrapPad()`.
</summary>
<param name="ciphertext" type="string">Ciphertext of the wrapped and padded key</param>
<param name="kek" type="string">Key encryption key</param>
<exception cref="UnexpectedValueException">If the ciphertext is invalid</exception>
<returns>Unwrapped key</returns>
</member>
<member name="M:Sop.AESKW.Algorithm._cipherMethod">
<summary>
Get OpenSSL cipher method.
</summary>
</member>
<member name="M:Sop.AESKW.Algorithm._keySize">
<summary>
Get key encryption key size.
</summary>
</member>
<member name="M:Sop.AESKW.Algorithm._checkKEKSize(Pchp.Core.PhpString)">
<summary>
Check KEK size.
</summary>
<param name="kek" type="string"></param>
</member>
<member name="M:Sop.AESKW.Algorithm._wrapBlocks(Pchp.Core.PhpArray,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Apply Key Wrap to data blocks.
Uses alternative version of the key wrap procedure described in the RFC.
</summary>
<param name="P" type="string[]">Plaintext, n 64-bit values `{P1, P2, ..., Pn}`</param>
<param name="kek" type="string">Key encryption key</param>
<param name="iv" type="string">Initial value</param>
<returns>Ciphertext, (n+1) 64-bit values `{C0, C1, ..., Cn}`</returns>
</member>
<member name="M:Sop.AESKW.Algorithm._unwrapPaddedCiphertext(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Unwrap the padded ciphertext producing plaintext and integrity value.
</summary>
<param name="ciphertext" type="string">Ciphertext</param>
<param name="kek" type="string">Encryption key</param>
<returns>Tuple of plaintext `{P1, P2, ..., Pn}` and integrity value `A`</returns>
</member>
<member name="M:Sop.AESKW.Algorithm._unwrapBlocks(Pchp.Core.PhpArray,Pchp.Core.PhpString)">
<summary>
Apply Key Unwrap to data blocks.
Uses the index based version of key unwrap procedure described in the RFC.

Does not compute step 3.
</summary>
<param name="C" type="string[]">Ciphertext, (n+1) 64-bit values `{C0, C1, ..., Cn}`</param>
<param name="kek" type="string">Key encryption key</param>
<returns>Tuple of integrity value `A` and register `R`</returns>
</member>
<member name="M:Sop.AESKW.Algorithm._padKey(Pchp.Core.PhpString)">
<summary>
Pad a key with zeroes and compute alternative initial value.
</summary>
<param name="key" type="string">Key</param>
<returns>Tuple of padded key and AIV</returns>
</member>
<member name="M:Sop.AESKW.Algorithm._checkPaddedIntegrity(Pchp.Core.PhpString)">
<summary>
Check that the integrity check value of the padded key is correct.
</summary>
<param name="A" type="string"></param>
</member>
<member name="M:Sop.AESKW.Algorithm._verifyPadding(Pchp.Core.PhpArray,Pchp.Core.PhpString)">
<summary>
Verify that the padding of the plaintext is valid.
</summary>
<param name="P" type="array">Plaintext, n 64-bit values `{P1, P2, ..., Pn}`</param>
<param name="A" type="string">Integrity check value</param>
<returns>Message length without padding</returns>
</member>
<member name="M:Sop.AESKW.Algorithm._encrypt(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Apply AES(K, W) operation (encrypt) to 64 bit block.
</summary>
<param name="kek" type="string"></param>
<param name="block" type="string"></param>
<exception cref="RuntimeException">If encrypt fails</exception>
</member>
<member name="M:Sop.AESKW.Algorithm._decrypt(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Apply AES-1(K, W) operation (decrypt) to 64 bit block.
</summary>
<param name="kek" type="string"></param>
<param name="block" type="string"></param>
<exception cref="RuntimeException">If decrypt fails</exception>
</member>
<member name="M:Sop.AESKW.Algorithm._getLastOpenSSLError">
<summary>
Get the latest OpenSSL error message.
</summary>
</member>
<member name="M:Sop.AESKW.Algorithm._msb64(Pchp.Core.PhpString)">
<summary>
Take 64 most significant bits from value.
</summary>
<param name="val" type="string"></param>
</member>
<member name="M:Sop.AESKW.Algorithm._lsb64(Pchp.Core.PhpString)">
<summary>
Take 64 least significant bits from value.
</summary>
<param name="val" type="string"></param>
</member>
<member name="M:Sop.AESKW.Algorithm._uint64(System.Int64)">
<summary>
Convert number to 64 bit unsigned integer octet string with
most significant bit first.
</summary>
<param name="num" type="int"></param>
</member>
<member name="M:Sop.ASN1.Component.Identifier.__construct(System.Int64,System.Int64,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="class" type="int">Type class</param>
<param name="pc" type="int">Primitive / Constructed</param>
<param name="tag" type="\GMP|int|string">Type tag number</param>
</member>
<member name="M:Sop.ASN1.Component.Identifier.fromDER(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Decode identifier component from DER data.
</summary>
<param name="data" type="string">DER encoded data</param>
<param name="offset" type="null|int">Reference to the variable that contains offset
into the data where to start parsing.
Variable is updated to the offset next to the
parsed identifier. If null, start from offset 0.</param>
<exception cref="DecodeException">If decoding fails</exception>
</member>
<member name="M:Sop.ASN1.Component.Identifier.toDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.typeClass">
<summary>
Get class of the type.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.pc">
<summary>
Get P/C.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.tag">
<summary>
Get the tag number.
</summary>
<returns>Base 10 integer string</returns>
</member>
<member name="M:Sop.ASN1.Component.Identifier.intTag">
<summary>
Get the tag as an integer.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.isUniversal">
<summary>
Check whether type is of an universal class.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.isApplication">
<summary>
Check whether type is of an application class.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.isContextSpecific">
<summary>
Check whether type is of a context specific class.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.isPrivate">
<summary>
Check whether type is of a private class.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.isPrimitive">
<summary>
Check whether content is primitive type.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.isConstructed">
<summary>
Check hether content is constructed type.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier.withClass(System.Int64)">
<summary>
Get self with given type class.
</summary>
<param name="class" type="int">One of `CLASS_*` enumerations</param>
</member>
<member name="M:Sop.ASN1.Component.Identifier.withTag(Pchp.Core.PhpValue)">
<summary>
Get self with given type tag.
</summary>
<param name="tag" type="\GMP|int|string">Tag number</param>
</member>
<member name="M:Sop.ASN1.Component.Identifier.classToName(Pchp.Core.Context,System.Int64)">
<summary>
Get human readable name of the type class.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Identifier._decodeLongFormTag(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Parse long form tag.
</summary>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Reference to the variable containing offset to data</param>
<exception cref="DecodeException">If decoding fails</exception>
<returns>Tag number</returns>
</member>
<member name="M:Sop.ASN1.Component.Length.__construct(Pchp.Core.PhpValue,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="length" type="\GMP|int|string">Length</param>
<param name="indefinite" type="bool">Whether length is indefinite</param>
</member>
<member name="M:Sop.ASN1.Component.Length.fromDER(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Decode length component from DER data.
</summary>
<param name="data" type="string">DER encoded data</param>
<param name="offset" type="null|int">Reference to the variable that contains offset
into the data where to start parsing.
Variable is updated to the offset next to the
parsed length component. If null, start from offset 0.</param>
<exception cref="DecodeException">If decoding fails</exception>
</member>
<member name="M:Sop.ASN1.Component.Length.expectFromDER(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpAlias,Pchp.Core.PhpValue)">
<summary>
Decode length from DER.
Throws an exception if length doesn't match with expected or if data
doesn't contain enough bytes.

Requirement of definite length is relaxed contrary to the specification
(sect. 10.1).
</summary>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Reference to the offset variable</param>
<param name="expected" type="null|int">Expected length, null to bypass checking</param>
<exception cref="DecodeException">If decoding or expectation fails</exception>
</member>
<member name="M:Sop.ASN1.Component.Length.toDER">
<summary>
{@inheritdoc}
</summary>
<exception cref="DomainException">If length is too large to encode</exception>
</member>
<member name="M:Sop.ASN1.Component.Length.length">
<summary>
Get the length.
</summary>
<exception cref="LogicException">If length is indefinite</exception>
<returns>Length as an integer string</returns>
</member>
<member name="M:Sop.ASN1.Component.Length.intLength">
<summary>
Get the length as an integer.
</summary>
<exception cref="LogicException">If length is indefinite</exception>
<exception cref="RuntimeException">If length overflows integer size</exception>
</member>
<member name="M:Sop.ASN1.Component.Length.isIndefinite">
<summary>
Whether length is indefinite.
</summary>
</member>
<member name="M:Sop.ASN1.Component.Length._decodeLongFormLength(Pchp.Core.Context,System.Int64,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Decode long form length.
</summary>
<param name="length" type="int">Number of octets</param>
<param name="data" type="string">Data</param>
<param name="offset" type="int">reference to the variable containing offset to the data</param>
<exception cref="DecodeException">If decoding fails</exception>
</member>
<member name="M:Sop.ASN1.DERData.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="data" type="string">DER encoded data</param>
<exception cref="Sop.ASN1.Exception.DecodeException">If data does not adhere to DER</exception>
</member>
<member name="M:Sop.ASN1.DERData.typeClass">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.DERData.isConstructed">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.DERData.toDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.DERData._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Element.typeClass">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Element.isConstructed">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Element.fromDER(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Decode element from DER data.
</summary>
<param name="data" type="string">DER encoded data</param>
<param name="offset" type="null|int">Reference to the variable that contains offset
into the data where to start parsing.
Variable is updated to the offset next to the
parsed element. If null, start from offset 0.</param>
<exception cref="DecodeException">If decoding fails</exception>
<exception cref="UnexpectedValueException">If called in the context of an expected
type, but decoding yields another type</exception>
</member>
<member name="M:Sop.ASN1.Element.toDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Element.tag">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Element.isType(System.Int64)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Element.expectType(System.Int64)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Element.isTagged">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Element.expectTagged(Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Element.hasIndefiniteLength">
<summary>
Whether element has indefinite length.
</summary>
</member>
<member name="M:Sop.ASN1.Element.withIndefiniteLength(System.Boolean)">
<summary>
Get self with indefinite length encoding set.
</summary>
<param name="indefinite" type="bool">True for indefinite length, false for definite length</param>
</member>
<member name="M:Sop.ASN1.Element.asElement">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Element.asUnspecified">
<summary>
Get element decorated with `UnspecifiedType` object.
</summary>
</member>
<member name="M:Sop.ASN1.Element.tagToName(Pchp.Core.Context,System.Int64)">
<summary>
Get human readable name for an universal tag.
</summary>
</member>
<member name="M:Sop.ASN1.Element._encodedContentDER">
<summary>
Get the content encoded in DER.
Returns the DER encoded content without identifier and length header octets.
</summary>
</member>
<member name="M:Sop.ASN1.Element._decodeFromDER(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Decode type-specific element from DER.
</summary>
<param name="identifier" type="Identifier">Pre-parsed identifier</param>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset in data to the next byte after identifier</param>
<exception cref="DecodeException">If decoding fails</exception>
</member>
<member name="M:Sop.ASN1.Element._determineImplClass(Pchp.Core.Context,Sop.ASN1.Component.Identifier)">
<summary>
Determine the class that implements the type.
</summary>
<returns>Class name</returns>
</member>
<member name="M:Sop.ASN1.Element._determineUniversalImplClass(Pchp.Core.Context,System.Int64)">
<summary>
Determine the class that implements an universal type of the given tag.
</summary>
<returns>Class name</returns>
</member>
<member name="M:Sop.ASN1.Element._typeDescriptorString">
<summary>
Get textual description of the type for debugging purposes.
</summary>
</member>
<member name="M:Sop.ASN1.Element._isConcreteType(System.Int64)">
<summary>
Check whether the element is a concrete type of a given tag.
</summary>
</member>
<member name="M:Sop.ASN1.Element._isPseudoType(System.Int64)">
<summary>
Check whether the element is a pseudotype.
</summary>
</member>
<member name="M:Sop.ASN1.Feature.ElementBase.typeClass">
<summary>
Get the class of the ASN.1 type.
One of `Identifier::CLASS_*` constants.
</summary>
</member>
<member name="M:Sop.ASN1.Feature.ElementBase.isConstructed">
<summary>
Check whether the element is constructed.
Otherwise it's primitive.
</summary>
</member>
<member name="M:Sop.ASN1.Feature.ElementBase.tag">
<summary>
Get the tag of the element.
Interpretation of the tag depends on the context. For example it may
represent a universal type tag or a tag of an implicitly or explicitly
tagged type.
</summary>
</member>
<member name="M:Sop.ASN1.Feature.ElementBase.isType(System.Int64)">
<summary>
Check whether the element is a type of a given tag.
</summary>
<param name="tag" type="int">Type tag</param>
</member>
<member name="M:Sop.ASN1.Feature.ElementBase.expectType(System.Int64)">
<summary>
Check whether the element is a type of a given tag.
Throws an exception if expectation fails.
</summary>
<param name="tag" type="int">Type tag</param>
<exception cref="UnexpectedValueException">If the element type differs from the expected</exception>
</member>
<member name="M:Sop.ASN1.Feature.ElementBase.isTagged">
<summary>
Check whether the element is tagged (context specific).
</summary>
</member>
<member name="M:Sop.ASN1.Feature.ElementBase.expectTagged(Pchp.Core.PhpValue)">
<summary>
Check whether the element is tagged (context specific) and optionally has
a given tag.
Throws an exception if the element is not tagged or tag differs from
the expected.
</summary>
<param name="tag" type="null|int">Optional type tag</param>
<exception cref="UnexpectedValueException">If expectation fails</exception>
</member>
<member name="M:Sop.ASN1.Feature.ElementBase.asElement">
<summary>
Get the object as an abstract `Element` instance.
</summary>
</member>
<member name="M:Sop.ASN1.Feature.ElementBase.asUnspecified">
<summary>
Get the object as an `UnspecifiedType` instance.
</summary>
</member>
<member name="M:Sop.ASN1.Feature.Encodable.toDER">
<summary>
Encode object to DER.
</summary>
</member>
<member name="M:Sop.ASN1.Feature.Stringable.__toString">
<summary>
Convert object to string.
</summary>
</member>
<member name="M:Sop.ASN1.Feature.Stringable.string">
<summary>
Get the string representation of the type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.BaseString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.BaseString.__toString">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.BaseString.string">
<summary>
Get the string value.
</summary>
</member>
<member name="M:Sop.ASN1.Type.BaseString._validateString(Pchp.Core.PhpString)">
<summary>
Check whether string is valid for the concrete type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.BaseTime.__construct(Pchp.Library.DateTime.DateTimeImmutable)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.BaseTime.__toString">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.BaseTime.fromString(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Initialize from datetime string.
</summary>
<param name="time" type="string">Time string</param>
<param name="tz" type="null|string">timezone, if null use default</param>
</member>
<member name="M:Sop.ASN1.Type.BaseTime.dateTime">
<summary>
Get the date and time.
</summary>
</member>
<member name="M:Sop.ASN1.Type.BaseTime.string">
<summary>
Get the date and time as a type specific string.
</summary>
</member>
<member name="M:Sop.ASN1.Type.BaseTime._createTimeZone(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Create `DateTimeZone` object from string.
</summary>
<exception cref="UnexpectedValueException">If timezone is invalid</exception>
</member>
<member name="M:Sop.ASN1.Type.BaseTime._getLastDateTimeImmutableErrorsStr(Pchp.Core.Context)">
<summary>
Get last error caused by `DateTimeImmutable`.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.ConstructedString.__construct(Sop.ASN1.Element[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.ConstructedString.__toString">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.ConstructedString.create(Pchp.Core.Context,Sop.ASN1.Type.StringType[])">
<summary>
Create from a list of string type elements.
All strings must have the same type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.ConstructedString.createWithTag(Pchp.Core.Context,System.Int64,Sop.ASN1.Type.StringType[])">
<summary>
Create from strings with a given type tag.
Does not perform any validation on types.
</summary>
<param name="tag" type="int">Type tag for the constructed string element</param>
</member>
<member name="M:Sop.ASN1.Type.Constructed.ConstructedString.strings">
<summary>
Get a list of strings in this structure.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.ConstructedString.string">
<summary>
Get the contained strings concatenated together.
NOTE: It's unclear how bit strings with unused bits should be concatenated.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.ConstructedString._decodeFromDER(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.Sequence.__construct(Sop.ASN1.Element[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.Set.__construct(Sop.ASN1.Element[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.Set.sortedSet">
<summary>
Sort by canonical ascending order.
Used for DER encoding of *SET* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Constructed.Set.sortedSetOf">
<summary>
Sort by encoding ascending order.
Used for DER encoding of *SET OF* type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString.__construct(Pchp.Core.PhpString,System.Int64)">
<summary>
Constructor.
</summary>
<param name="string" type="string">Content octets</param>
<param name="unused_bits" type="int">Number of unused bits in the last octet</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString.numBits">
<summary>
Get the number of bits in the string.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString.unusedBits">
<summary>
Get the number of unused bits in the last octet of the string.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString.testBit(System.Int64)">
<summary>
Test whether bit is set.
</summary>
<param name="idx" type="int">Bit index. Most significant bit of the first octet is index 0.</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString.range(System.Int64,System.Int64)">
<summary>
Get range of bits.
</summary>
<param name="start" type="int">Index of first bit</param>
<param name="length" type="int">Number of bits in range</param>
<returns>Integer of $length bits</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString.withoutTrailingZeroes">
<summary>
Get a copy of the bit string with trailing zeroes removed.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BitString._decodeFromDER(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BMPString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.BMPString._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Boolean.__construct(System.Boolean)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Boolean.value">
<summary>
Get the value.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Boolean._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Boolean._decodeFromDER(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.CharacterString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Enumerated.__construct(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="number" type="int|string"></param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.EOC.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.EOC._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.EOC._decodeFromDER(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralizedTime.__construct(Pchp.Library.DateTime.DateTimeImmutable)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralizedTime.__clone">
<summary>
Clear cached variables on clone.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralizedTime._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralizedTime._decodeFromDER(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GeneralString._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GraphicString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.GraphicString._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.IA5String.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.IA5String._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Integer.__construct(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="number" type="\GMP|int|string">Base 10 integer</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Integer.number">
<summary>
Get the number as a base 10.
</summary>
<returns>Integer as a string</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Integer.intNumber">
<summary>
Get the number as an integer type.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Integer._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Integer._decodeFromDER(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Integer._validateNumber(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Test that number is valid for this context.
</summary>
<param name="num" type="mixed"></param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NullType.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NullType._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NullType._decodeFromDER(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NumericString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.NumericString._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectDescriptor.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectDescriptor.descriptor">
<summary>
Get the object descriptor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="oid" type="string">OID in dotted format</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier.oid">
<summary>
Get OID in dotted format.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier._decodeFromDER(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier._explodeDottedOID(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Explode dotted OID to an array of sub ID's.
</summary>
<param name="oid" type="string">OID in dotted format</param>
<returns>Array of GMP numbers</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier._implodeSubIDs(Pchp.Core.Context,System.Object[])">
<summary>
Implode an array of sub IDs to dotted OID format.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier._encodeSubIDs(Pchp.Core.Context,System.Object[])">
<summary>
Encode sub ID's to DER.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.ObjectIdentifier._decodeSubIDs(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Decode sub ID's from DER data.
</summary>
<returns>Array of GMP numbers</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.OctetString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.PrintableString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.PrintableString._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpValue,System.Int64)">
<summary>
Constructor.
</summary>
<param name="mantissa" type="\GMP|int|string">Integer mantissa</param>
<param name="exponent" type="\GMP|int|string">Integer exponent</param>
<param name="base" type="int">Base, 2 or 10</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.__toString">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.fromFloat(Pchp.Core.Context,System.Double)">
<summary>
Create base 2 real number from float.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.fromString(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Create base 10 real number from string.
</summary>
<param name="number" type="string">Real number in base-10 textual form</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.withStrictDER(System.Boolean)">
<summary>
Get self with strict DER flag set or unset.
</summary>
<param name="strict" type="bool">whether to encode strictly in DER</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.mantissa">
<summary>
Get the mantissa.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.exponent">
<summary>
Get the exponent.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.base">
<summary>
Get the base.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.floatVal">
<summary>
Get number as a float.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real.nr3Val">
<summary>
Get number as a NR3 form string conforming to DER rules.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._encodeBinary">
<summary>
Encode in binary format.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._encodeDecimal">
<summary>
Encode in decimal format.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._encodeSpecial">
<summary>
Encode special value.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._decodeFromDER(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._decodeBinaryEncoding(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Decode binary encoding.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._decodeDecimalEncoding(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Decode decimal encoding.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._decodeSpecialRealValue(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Decode special encoding.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._prepareBinaryEncoding">
<summary>
Prepare value for binary encoding.
</summary>
<returns>(int) base, (int) sign, (\GMP) mantissa and (\GMP) exponent</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._fromInfinite(Pchp.Core.Context,System.Double)">
<summary>
Initialize from INF or -INF.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._parse754Double(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Parse IEEE 754 big endian formatted double precision float to base 2
mantissa and exponent.
</summary>
<param name="octets" type="string">64 bits</param>
<returns>Tuple of mantissa and exponent</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._parseString(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Parse textual REAL number to base 10 mantissa and exponent.
</summary>
<param name="str" type="string">Number</param>
<returns>Tuple of mantissa and exponent</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._parsePHPExponentMatch(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Parse PHP form float to base 10 mantissa and exponent.
</summary>
<param name="match" type="array">Regexp match</param>
<returns>Tuple of mantissa and exponent</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._parseNR3Match(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Parse NR3 form number to base 10 mantissa and exponent.
</summary>
<param name="match" type="array">Regexp match</param>
<returns>Tuple of mantissa and exponent</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._parseNR2Match(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Parse NR2 form number to base 10 mantissa and exponent.
</summary>
<param name="match" type="array">Regexp match</param>
<returns>Tuple of mantissa and exponent</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.Real._parseNR1Match(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Parse NR1 form number to base 10 mantissa and exponent.
</summary>
<param name="match" type="array">Regexp match</param>
<returns>Tuple of mantissa and exponent</returns>
</member>
<member name="M:Sop.ASN1.Type.Primitive.RelativeOID.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="oid" type="string">OID in dotted format</param>
</member>
<member name="M:Sop.ASN1.Type.Primitive.RelativeOID._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.RelativeOID._decodeFromDER(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.T61String.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.T61String._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UniversalString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UniversalString._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTCTime.__construct(Pchp.Library.DateTime.DateTimeImmutable)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTCTime._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTCTime._decodeFromDER(Pchp.Core.Context,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTF8String.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.UTF8String._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.VideotexString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.VideotexString._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.VisibleString.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Primitive.VisibleString._validateString(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.PrimitiveString._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.PrimitiveString._decodeFromDER(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.PrimitiveType`1`1.isConstructed">
</member>
<member name="M:Sop.ASN1.Type.Structure.__construct(Sop.ASN1.Feature.ElementBase[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Structure.__clone">
<summary>
Clone magic method.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Structure.isConstructed">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Structure.explodeDER(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Explode DER structure to DER encoded components that it contains.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Structure.withReplaced(System.Int64,Sop.ASN1.Element)">
<summary>
Get self with an element at the given index replaced by another.
</summary>
<param name="idx" type="int">Element index</param>
<param name="el" type="Element">New element to insert into the structure</param>
</member>
<member name="M:Sop.ASN1.Type.Structure.withInserted(System.Int64,Sop.ASN1.Element)">
<summary>
Get self with an element inserted before the given index.
</summary>
<param name="idx" type="int">Element index</param>
<param name="el" type="Element">New element to insert into the structure</param>
</member>
<member name="M:Sop.ASN1.Type.Structure.withAppended(Sop.ASN1.Element)">
<summary>
Get self with an element appended to the end.
</summary>
<param name="el" type="Element">Element to insert into the structure</param>
</member>
<member name="M:Sop.ASN1.Type.Structure.withPrepended(Sop.ASN1.Element)">
<summary>
Get self with an element prepended in the beginning.
</summary>
<param name="el" type="Element">Element to insert into the structure</param>
</member>
<member name="M:Sop.ASN1.Type.Structure.withoutElement(System.Int64)">
<summary>
Get self with an element at the given index removed.
</summary>
<param name="idx" type="int">Element index</param>
</member>
<member name="M:Sop.ASN1.Type.Structure.elements">
<summary>
Get elements in the structure.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Structure.has(System.Int64,Pchp.Core.PhpValue)">
<summary>
Check whether the structure has an element at the given index, optionally
satisfying given tag expectation.
</summary>
<param name="idx" type="int">Index 0..n</param>
<param name="expectedTag" type="null|int">Optional type tag expectation</param>
</member>
<member name="M:Sop.ASN1.Type.Structure.at(System.Int64)">
<summary>
Get the element at the given index, optionally checking that the element
has a given tag.
</summary>
<param name="idx" type="int">Index 0..n</param>
<exception cref="OutOfBoundsException">If element doesn't exists</exception>
<exception cref="UnexpectedValueException">If expectation fails</exception>
</member>
<member name="M:Sop.ASN1.Type.Structure.hasTagged(System.Int64)">
<summary>
Check whether the structure contains a context specific element with a
given tag.
</summary>
<param name="tag" type="int">Tag number</param>
</member>
<member name="M:Sop.ASN1.Type.Structure.getTagged(System.Int64)">
<summary>
Get a context specific element tagged with a given tag.
</summary>
<exception cref="LogicException">If tag doesn't exists</exception>
</member>
<member name="M:Sop.ASN1.Type.Structure.count">
</member>
<member name="M:Sop.ASN1.Type.Structure.getIterator">
<summary>
Get an iterator for the `UnspecifiedElement` objects.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Structure._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Structure._decodeFromDER(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Structure._decodeDefiniteLength(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString,Pchp.Core.PhpAlias,System.Int64)">
<summary>
Decode elements for a definite length.
</summary>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to data</param>
<param name="length" type="int">Number of bytes to decode</param>
</member>
<member name="M:Sop.ASN1.Type.Structure._decodeIndefiniteLength(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Decode elements for an indefinite length.
</summary>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to data</param>
</member>
<member name="M:Sop.ASN1.Type.Tagged.DERTaggedType.__construct(Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,System.Int64,System.Int64,System.Int64,System.Boolean)">
<summary>
Constructor.
</summary>
<param name="identifier" type="Identifier">Pre-parsed identifier</param>
<param name="data" type="string">DER data</param>
<param name="offset" type="int">Offset to next byte after identifier</param>
<param name="value_offset" type="int">Offset to content</param>
<param name="value_length" type="int">Content length</param>
</member>
<member name="M:Sop.ASN1.Type.Tagged.DERTaggedType.typeClass">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.DERTaggedType.isConstructed">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.DERTaggedType.implicit(System.Int64,System.Int64)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.DERTaggedType.explicit">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.DERTaggedType._decodeFromDER(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Component.Identifier,Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.DERTaggedType._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ExplicitlyTaggedType.__construct(System.Int64,Sop.ASN1.Element,System.Int64)">
<summary>
Constructor.
</summary>
<param name="tag" type="int">Tag number</param>
<param name="element" type="Element">Wrapped element</param>
<param name="class" type="int">Type class</param>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ExplicitlyTaggedType.isConstructed">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ExplicitlyTaggedType.explicit">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ExplicitlyTaggedType._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ExplicitTagging.explicit">
<summary>
Get explicitly tagged wrapped element.
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ImplicitlyTaggedType.__construct(System.Int64,Sop.ASN1.Element,System.Int64)">
<summary>
Constructor.
</summary>
<param name="tag" type="int">Tag number</param>
<param name="element" type="Element">Wrapped element</param>
<param name="class" type="int">Type class</param>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ImplicitlyTaggedType.isConstructed">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ImplicitlyTaggedType.implicit(System.Int64,System.Int64)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ImplicitlyTaggedType._encodedContentDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.Tagged.ImplicitTagging.implicit(System.Int64,System.Int64)">
<summary>
Get implicitly tagged wrapped element.
</summary>
<param name="tag" type="int">Tag of the element</param>
<param name="class" type="int">Expected type class of the element</param>
<exception cref="UnexpectedValueException">If expectation fails</exception>
</member>
<member name="M:Sop.ASN1.Type.Tagged.TaggedTypeWrap.typeClass">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.TaggedType.expectExplicit(Pchp.Core.PhpValue)">
<summary>
Check whether element supports explicit tagging.
</summary>
<param name="expectedTag" type="null|int">Optional outer tag expectation</param>
<exception cref="UnexpectedValueException">If expectation fails</exception>
</member>
<member name="M:Sop.ASN1.Type.TaggedType.asExplicit(Pchp.Core.PhpValue)">
<summary>
Get the wrapped inner element employing explicit tagging.
</summary>
<param name="expectedTag" type="null|int">Optional outer tag expectation</param>
<exception cref="UnexpectedValueException">If expectation fails</exception>
</member>
<member name="M:Sop.ASN1.Type.TaggedType.expectImplicit(Pchp.Core.PhpValue)">
<summary>
Check whether element supports implicit tagging.
</summary>
<param name="expectedTag" type="null|int">Optional outer tag expectation</param>
<exception cref="UnexpectedValueException">If expectation fails</exception>
</member>
<member name="M:Sop.ASN1.Type.TaggedType.asImplicit(System.Int64,Pchp.Core.PhpValue,System.Int64)">
<summary>
Get the wrapped inner element employing implicit tagging.
</summary>
<param name="tag" type="int">Type tag of the inner element</param>
<param name="expectedTag" type="null|int">Optional outer tag expectation</param>
<param name="expectedClass" type="int">Optional inner type class expectation</param>
<exception cref="UnexpectedValueException">If expectation fails</exception>
</member>
<member name="M:Sop.ASN1.Type.TimeType.dateTime">
<summary>
Get the date and time.
</summary>
</member>
<member name="M:Sop.ASN1.Type.UniversalClass`1`1.typeClass">
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.__construct(Sop.ASN1.Element)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.fromDER(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from DER data.
</summary>
<param name="data" type="string">DER encoded data</param>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.fromElementBase(Pchp.Core.Context,Sop.ASN1.Feature.ElementBase)">
<summary>
Initialize from `ElementBase` interface.
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asTagged">
<summary>
Get the wrapped element as a context specific tagged type.
</summary>
<exception cref="UnexpectedValueException">If the element is not tagged</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asApplication">
<summary>
Get the wrapped element as an application specific type.
</summary>
<exception cref="UnexpectedValueException">If element is not application specific</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asPrivate">
<summary>
Get the wrapped element as a private tagged type.
</summary>
<exception cref="UnexpectedValueException">If element is not using private tagging</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asBoolean">
<summary>
Get the wrapped element as a boolean type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a boolean</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asInteger">
<summary>
Get the wrapped element as an integer type.
</summary>
<exception cref="UnexpectedValueException">If the element is not an integer</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asBitString">
<summary>
Get the wrapped element as a bit string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a bit string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asOctetString">
<summary>
Get the wrapped element as an octet string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not an octet string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asNull">
<summary>
Get the wrapped element as a null type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a null</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asObjectIdentifier">
<summary>
Get the wrapped element as an object identifier type.
</summary>
<exception cref="UnexpectedValueException">If the element is not an object identifier</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asObjectDescriptor">
<summary>
Get the wrapped element as an object descriptor type.
</summary>
<exception cref="UnexpectedValueException">If the element is not an object descriptor</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asReal">
<summary>
Get the wrapped element as a real type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a real</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asEnumerated">
<summary>
Get the wrapped element as an enumerated type.
</summary>
<exception cref="UnexpectedValueException">If the element is not an enumerated</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asUTF8String">
<summary>
Get the wrapped element as a UTF8 string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a UTF8 string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asRelativeOID">
<summary>
Get the wrapped element as a relative OID type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a relative OID</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asSequence">
<summary>
Get the wrapped element as a sequence type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a sequence</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asSet">
<summary>
Get the wrapped element as a set type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a set</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asNumericString">
<summary>
Get the wrapped element as a numeric string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a numeric string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asPrintableString">
<summary>
Get the wrapped element as a printable string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a printable string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asT61String">
<summary>
Get the wrapped element as a T61 string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a T61 string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asVideotexString">
<summary>
Get the wrapped element as a videotex string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a videotex string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asIA5String">
<summary>
Get the wrapped element as a IA5 string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a IA5 string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asUTCTime">
<summary>
Get the wrapped element as an UTC time type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a UTC time</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asGeneralizedTime">
<summary>
Get the wrapped element as a generalized time type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a generalized time</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asGraphicString">
<summary>
Get the wrapped element as a graphic string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a graphic string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asVisibleString">
<summary>
Get the wrapped element as a visible string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a visible string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asGeneralString">
<summary>
Get the wrapped element as a general string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not general string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asUniversalString">
<summary>
Get the wrapped element as a universal string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a universal string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asCharacterString">
<summary>
Get the wrapped element as a character string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a character string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asBMPString">
<summary>
Get the wrapped element as a BMP string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a bmp string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asConstructedString">
<summary>
Get the wrapped element as a constructed string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a constructed string</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asString">
<summary>
Get the wrapped element as any string type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a string type</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asTime">
<summary>
Get the wrapped element as any time type.
</summary>
<exception cref="UnexpectedValueException">If the element is not a time type</exception>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asElement">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.asUnspecified">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.toDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.typeClass">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.tag">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.isConstructed">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.isType(System.Int64)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.isTagged">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.expectType(System.Int64)">
<summary>
{@inheritdoc}
Consider using any of the `as*` accessor methods instead.
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType.expectTagged(Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
Consider using `asTagged()` method instead and chaining
with `TaggedType::asExplicit()` or `TaggedType::asImplicit()`.
</summary>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType._generateExceptionMessage(System.Int64)">
<summary>
Generate message for exceptions thrown by `as*` methods.
</summary>
<param name="tag" type="int">Type tag of the expected element</param>
</member>
<member name="M:Sop.ASN1.Type.UnspecifiedType._typeDescriptorString">
<summary>
Get textual description of the wrapped element for debugging purposes.
</summary>
</member>
<member name="M:Sop.ASN1.Util.BigInt.__construct(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="num" type="\GMP|int|string">Integer number in base 10</param>
</member>
<member name="M:Sop.ASN1.Util.BigInt.fromUnsignedOctets(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from an arbitrary length of octets as an unsigned integer.
</summary>
</member>
<member name="M:Sop.ASN1.Util.BigInt.fromSignedOctets(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from an arbitrary length of octets as an signed integer
having two's complement encoding.
</summary>
</member>
<member name="M:Sop.ASN1.Util.BigInt.base10">
<summary>
Get the number as a base 10 integer string.
</summary>
</member>
<member name="M:Sop.ASN1.Util.BigInt.intVal">
<summary>
Get the number as an integer.
</summary>
<exception cref="RuntimeException">If number overflows integer size</exception>
</member>
<member name="M:Sop.ASN1.Util.BigInt.gmpObj">
<summary>
Get the number as a `GMP` object.
</summary>
<exception cref="RuntimeException">if number is not a valid integer</exception>
</member>
<member name="M:Sop.ASN1.Util.BigInt.unsignedOctets">
<summary>
Get the number as an unsigned integer encoded in binary.
</summary>
</member>
<member name="M:Sop.ASN1.Util.BigInt.signedOctets">
<summary>
Get the number as a signed integer encoded in two's complement binary.
</summary>
</member>
<member name="M:Sop.ASN1.Util.BigInt._signedPositiveOctets">
<summary>
Encode positive integer in two's complement binary.
</summary>
</member>
<member name="M:Sop.ASN1.Util.BigInt._signedNegativeOctets">
<summary>
Encode negative integer in two's complement binary.
</summary>
</member>
<member name="M:Sop.ASN1.Util.BigInt._intMaxGmp">
<summary>
Get the maximum integer value.
</summary>
</member>
<member name="M:Sop.ASN1.Util.BigInt._intMinGmp">
<summary>
Get the minimum integer value.
</summary>
</member>
<member name="M:Sop.ASN1.Util.Flags.__construct(Pchp.Core.PhpValue,System.Int64)">
<summary>
Constructor.
</summary>
<param name="flags" type="int|string">Flags</param>
<param name="width" type="int">The number of flags. If width is larger than
number of bits in $flags, zeroes are prepended
to flag field.</param>
</member>
<member name="M:Sop.ASN1.Util.Flags.fromBitString(Pchp.Core.Context,Sop.ASN1.Type.Primitive.BitString,System.Int64)">
<summary>
Initialize from `BitString`.
</summary>
</member>
<member name="M:Sop.ASN1.Util.Flags.test(System.Int64)">
<summary>
Check whether a bit at given index is set.
Index 0 is the leftmost bit.
</summary>
</member>
<member name="M:Sop.ASN1.Util.Flags.string">
<summary>
Get flags as an octet string.
Zeroes are appended to the last octet if width is not divisible by 8.
</summary>
</member>
<member name="M:Sop.ASN1.Util.Flags.number">
<summary>
Get flags as a base 10 integer.
</summary>
<returns>Integer as a string</returns>
</member>
<member name="M:Sop.ASN1.Util.Flags.intNumber">
<summary>
Get flags as an integer.
</summary>
</member>
<member name="M:Sop.ASN1.Util.Flags.bitString">
<summary>
Get flags as a `BitString` object.
Unused bits are set accordingly. Trailing zeroes are not stripped.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEM.__construct(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="type" type="string">Content type</param>
<param name="data" type="string">Payload</param>
</member>
<member name="M:Sop.CryptoEncoding.PEM.__toString">
</member>
<member name="M:Sop.CryptoEncoding.PEM.fromString(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from a PEM-formatted string.
</summary>
<param name="str" type="string"></param>
<exception cref="UnexpectedValueException">If string is not valid PEM</exception>
</member>
<member name="M:Sop.CryptoEncoding.PEM.fromFile(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from a file.
</summary>
<param name="filename" type="string">Path to file</param>
<exception cref="RuntimeException">If file reading fails</exception>
</member>
<member name="M:Sop.CryptoEncoding.PEM.type">
<summary>
Get content type.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEM.data">
<summary>
Get payload.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEM.string">
<summary>
Encode to PEM string.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.__construct(Sop.CryptoEncoding.PEM[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.__toString">
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.fromString(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from a string.
</summary>
<param name="str" type="string"></param>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.fromFile(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from a file.
</summary>
<param name="filename" type="string"></param>
<exception cref="RuntimeException">If file reading fails</exception>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.withPEMs(Sop.CryptoEncoding.PEM[])">
<summary>
Get self with PEM objects appended.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.all">
<summary>
Get all PEMs in a bundle.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.first">
<summary>
Get the first PEM in a bundle.
</summary>
<exception cref="LogicException">If bundle contains no PEM objects</exception>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.last">
<summary>
Get the last PEM in a bundle.
</summary>
<exception cref="LogicException">If bundle contains no PEM objects</exception>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.count">
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.getIterator">
<summary>
Get iterator for PEMs.
</summary>
</member>
<member name="M:Sop.CryptoEncoding.PEMBundle.string">
<summary>
Encode bundle to a string of contiguous PEM blocks.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifier.fromASN1(Pchp.Core.Context,Sop.ASN1.Type.Constructed.Sequence)">
<summary>
Initialize from ASN.1.
</summary>
<param name="seq" type="Sequence"></param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifier.oid">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifier.toASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifier._paramsASN1">
<summary>
Get algorithm identifier parameters as ASN.1.
If type allows parameters to be omitted, return null.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierFactory.__construct(Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierProvider[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierFactory.getClass(Pchp.Core.PhpString)">
<summary>
Get the name of a class that implements algorithm identifier for given
OID.
</summary>
<param name="oid" type="string">Object identifier in dotted format</param>
<returns>Fully qualified class name or null if not supported</returns>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierFactory.parse(Sop.ASN1.Type.Constructed.Sequence)">
<summary>
Parse AlgorithmIdentifier from an ASN.1 sequence.
</summary>
<param name="seq" type="Sequence"></param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierProvider.supportsOID(Pchp.Core.PhpString)">
<summary>
Check whether this provider supports algorithm identifier of given OID.
</summary>
<param name="oid" type="string">Object identifier in dotted format</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifierProvider.getClassByOID(Pchp.Core.PhpString)">
<summary>
Get the name of a class that implements algorithm identifier for given
OID.
</summary>
<param name="oid" type="string">Object identifier in dotted format</param>
<exception cref="UnexpectedValueException">If OID is not supported</exception>
<returns>Fully qualified name of a class that extends
SpecificAlgorithmIdentifier</returns>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="named_curve" type="string">Curve identifier</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier.namedCurve">
<summary>
Get OID of the named curve.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.ECPublicKeyAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.RSAEncryptionAlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.RSAEncryptionAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.RSAEncryptionAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Asymmetric.RSAEncryptionAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES128CBCAlgorithmIdentifier.__construct(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES128CBCAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES128CBCAlgorithmIdentifier.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES192CBCAlgorithmIdentifier.__construct(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES192CBCAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES192CBCAlgorithmIdentifier.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES256CBCAlgorithmIdentifier.__construct(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES256CBCAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AES256CBCAlgorithmIdentifier.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AESCBCAlgorithmIdentifier.__construct(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AESCBCAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AESCBCAlgorithmIdentifier.blockSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AESCBCAlgorithmIdentifier.ivSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.AESCBCAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.BlockCipherAlgorithmIdentifier.blockSize">
<summary>
Get block size in bytes.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.CipherAlgorithmIdentifier.keySize">
<summary>
Get key size in bytes.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.CipherAlgorithmIdentifier.ivSize">
<summary>
Get the initialization vector size in bytes.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.CipherAlgorithmIdentifier.initializationVector">
<summary>
Get initialization vector.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.CipherAlgorithmIdentifier.withInitializationVector(Pchp.Core.PhpValue)">
<summary>
Get copy of the object with given initialization vector.
</summary>
<param name="iv" type="null|string">Initialization vector or null to remove</param>
<exception cref="UnexpectedValueException">If initialization vector size is invalid</exception>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.CipherAlgorithmIdentifier._checkIVSize(Pchp.Core.PhpValue)">
<summary>
Check that initialization vector size is valid for the cipher.
</summary>
<param name="iv" type="null|string"></param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier.__construct(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier.blockSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier.ivSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESCBCAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier.__construct(Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier.blockSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier.ivSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.DESEDE3CBCAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier.__construct(System.Int64,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="key_bits" type="int">Number of effective key bits</param>
<param name="iv" type="null|string">Initialization vector</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier.effectiveKeyBits">
<summary>
Get number of effective key bits.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier.blockSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier.ivSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Cipher.RC2CBCAlgorithmIdentifier._versionToEKB(Pchp.Core.Context,System.Int64)">
<summary>
Translate version number to number of effective key bits.
</summary>
<param name="version" type="int"></param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType.oid">
<summary>
Get the object identifier of the algorithm.
</summary>
<returns>Object identifier in dotted format</returns>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType.name">
<summary>
Get a human readable name of the algorithm.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType.toASN1">
<summary>
Generate ASN.1 structure.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Feature.SignatureAlgorithmIdentifier.supportsKeyAlgorithm(Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifier)">
<summary>
Check whether signature algorithm supports given key algorithm.
</summary>
<param name="algo" type="AlgorithmIdentifier"></param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.GenericAlgorithmIdentifier.__construct(Pchp.Core.PhpString,Sop.ASN1.Type.UnspecifiedType)">
<summary>
Constructor.
</summary>
<param name="oid" type="string">Algorithm OID</param>
<param name="params" type="null|UnspecifiedType">Parameters</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.GenericAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.GenericAlgorithmIdentifier.parameters">
<summary>
Get parameters.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.GenericAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA1AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA1AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA1AlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA1AlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA224AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA224AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA256AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA256AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA384AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA384AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA512AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.HMACWithSHA512AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.MD5AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.MD5AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.MD5AlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.MD5AlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.RFC4231HMACAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.RFC4231HMACAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA1AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA1AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA1AlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA1AlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA224AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA224AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA256AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA256AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA2AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA2AlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA2AlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA384AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA384AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA512AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Hash.SHA512AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA1AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA1AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA224AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA224AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA256AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA256AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA384AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA384AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA512AlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECDSAWithSHA512AlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECSignatureAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECSignatureAlgorithmIdentifier.supportsKeyAlgorithm(Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifier)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.ECSignatureAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD2WithRSAEncryptionAlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD2WithRSAEncryptionAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD4WithRSAEncryptionAlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD4WithRSAEncryptionAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD5WithRSAEncryptionAlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.MD5WithRSAEncryptionAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.RFC3279RSASignatureAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.RFC3279RSASignatureAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.RFC4055RSASignatureAlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.RFC4055RSASignatureAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Type.UnspecifiedType)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.RFC4055RSASignatureAlgorithmIdentifier._paramsASN1">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.RSASignatureAlgorithmIdentifier.supportsKeyAlgorithm(Sop.CryptoTypes.AlgorithmIdentifier.AlgorithmIdentifier)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA1WithRSAEncryptionAlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA1WithRSAEncryptionAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA224WithRSAEncryptionAlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA224WithRSAEncryptionAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA256WithRSAEncryptionAlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA256WithRSAEncryptionAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA384WithRSAEncryptionAlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA384WithRSAEncryptionAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA512WithRSAEncryptionAlgorithmIdentifier.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SHA512WithRSAEncryptionAlgorithmIdentifier.name">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SignatureAlgorithmIdentifierFactory.algoForAsymmetricCrypto(Pchp.Core.Context,Sop.CryptoTypes.AlgorithmIdentifier.Feature.AsymmetricCryptoAlgorithmIdentifier,Sop.CryptoTypes.AlgorithmIdentifier.Feature.HashAlgorithmIdentifier)">
<summary>
Get signature algorithm identifier of given asymmetric cryptographic type
utilizing given hash algorithm.
</summary>
<param name="crypto_algo" type="AsymmetricCryptoAlgorithmIdentifier">Cryptographic algorithm identifier, eg. RSA or EC</param>
<param name="hash_algo" type="HashAlgorithmIdentifier">Hash algorithm identifier</param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SignatureAlgorithmIdentifierFactory._oidForRSA(Pchp.Core.Context,Sop.CryptoTypes.AlgorithmIdentifier.Feature.HashAlgorithmIdentifier)">
<summary>
Get RSA signature algorithm OID for the given hash algorithm identifier.
</summary>
<param name="hash_algo" type="HashAlgorithmIdentifier"></param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.Signature.SignatureAlgorithmIdentifierFactory._oidForEC(Pchp.Core.Context,Sop.CryptoTypes.AlgorithmIdentifier.Feature.HashAlgorithmIdentifier)">
<summary>
Get EC signature algorithm OID for the given hash algorithm identifier.
</summary>
<param name="hash_algo" type="HashAlgorithmIdentifier"></param>
</member>
<member name="M:Sop.CryptoTypes.AlgorithmIdentifier.SpecificAlgorithmIdentifier.fromASN1Params(Pchp.Core.Context,Sop.ASN1.Type.UnspecifiedType)">
<summary>
Initialize object from algorithm identifier parameters.
</summary>
<param name="params" type="null|UnspecifiedType">Parameters or null if none</param>
<exception cref="UnexpectedValueException">If parameters are invalid for the algorithm</exception>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECConversion.bitStringToOctetString(Pchp.Core.Context,Sop.ASN1.Type.Primitive.BitString)">
<summary>
Perform Bit-String-to-Octet-String Conversion.
Defined in SEC 1 section 2.3.1.
</summary>
<param name="bs" type="BitString"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECConversion.octetStringToBitString(Pchp.Core.Context,Sop.ASN1.Type.Primitive.OctetString)">
<summary>
Perform Octet-String-to-Bit-String Conversion.
Defined in SEC 1 section 2.3.2.
</summary>
<param name="os" type="OctetString"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECConversion.integerToOctetString(Pchp.Core.Context,Sop.ASN1.Type.Primitive.Integer,Pchp.Core.PhpValue)">
<summary>
Perform Integer-to-Octet-String Conversion.
Defined in SEC 1 section 2.3.7.
</summary>
<param name="num" type="Integer"></param>
<param name="mlen" type="null|int">Optional desired output length</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECConversion.octetStringToInteger(Pchp.Core.Context,Sop.ASN1.Type.Primitive.OctetString)">
<summary>
Perform Octet-String-to-Integer Conversion.
Defined in SEC 1 section 2.3.8.
</summary>
<param name="os" type="OctetString"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECConversion.numberToOctets(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Convert a base-10 number to octets.
This is a convenicence method for integer &lt;-&gt; octet string conversion
without the need for external ASN.1 dependencies.
</summary>
<param name="num" type="int|string">Number in base-10</param>
<param name="mlen" type="null|int">Optional desired output length</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECConversion.octetsToNumber(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Convert octets to a base-10 number.
This is a convenicence method for integer &lt;-&gt; octet string conversion
without the need for external ASN.1 dependencies.
</summary>
<param name="str" type="string"></param>
<returns>Number in base-10</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.__construct(Pchp.Core.PhpString,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="private_key" type="string">Private key</param>
<param name="named_curve" type="null|string">OID of the named curve</param>
<param name="public_key" type="null|string">ECPoint value</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.fromASN1(Pchp.Core.Context,Sop.ASN1.Type.Constructed.Sequence)">
<summary>
Initialize from ASN.1.
</summary>
<param name="seq" type="Sequence"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.fromDER(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from DER data.
</summary>
<param name="data" type="string"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<param name="pem" type="PEM"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.privateKeyOctets">
<summary>
Get the EC private key value.
</summary>
<returns>Octets of the private key</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.hasNamedCurve">
<summary>
Whether named curve is present.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.namedCurve">
<summary>
Get named curve OID.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.withNamedCurve(Pchp.Core.PhpValue)">
<summary>
Get self with named curve.
</summary>
<param name="named_curve" type="null|string">Named curve OID</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.algorithmIdentifier">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.hasPublicKey">
<summary>
Whether public key is present.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.publicKey">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.toASN1">
<summary>
Generate ASN.1 structure.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.toDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey.toPEM">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.__construct(Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="ec_point" type="string">ECPoint</param>
<param name="named_curve" type="null|string">Named curve OID</param>
<exception cref="InvalidArgumentException">If ECPoint is invalid</exception>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.fromCoordinates(Pchp.Core.Context,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Initialize from curve point coordinates.
</summary>
<param name="x" type="int|string">X coordinate as a base10 number</param>
<param name="y" type="int|string">Y coordinate as a base10 number</param>
<param name="named_curve" type="null|string">Named curve OID</param>
<param name="bits" type="null|int">Size of *p* in bits</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<param name="pem" type="PEM"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.ECPoint">
<summary>
Get ECPoint value.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.curvePoint">
<summary>
Get curve point coordinates.
</summary>
<returns>Tuple of X and Y coordinates as base-10 numbers</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.curvePointOctets">
<summary>
Get curve point coordinates in octet string representation.
</summary>
<returns>tuple of X and Y field elements as a string</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.isCompressed">
<summary>
Whether ECPoint is in compressed form.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.hasNamedCurve">
<summary>
Whether named curve is present.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.namedCurve">
<summary>
Get named curve OID.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.algorithmIdentifier">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.toASN1">
<summary>
Generate ASN.1 element.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.toDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey.subjectPublicKeyData">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.EC.ECPublicKey._curveSize(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Get the curve size *p* in bits.
</summary>
<param name="oid" type="string">Curve OID</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.__construct(Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="AlgorithmIdentifierType">Algorithm</param>
<param name="key" type="string">Private key data</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.fromASN1(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.ASN1.Type.Constructed.Sequence)">
<summary>
Initialize from ASN.1.
</summary>
<param name="seq" type="Sequence"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.fromDER(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString)">
<summary>
Initialize from DER data.
</summary>
<param name="data" type="string"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.fromPrivateKey(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.CryptoTypes.Asymmetric.PrivateKey)">
<summary>
Initialize from a PrivateKey.
</summary>
<param name="private_key" type="PrivateKey"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.fromPEM(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.CryptoEncoding.PEM)">
<summary>
Initialize from PEM.
</summary>
<param name="pem" type="PEM"></param>
<exception cref="UnexpectedValueException">If PEM type is not supported</exception>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.algorithmIdentifier">
<summary>
Get algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.privateKeyData">
<summary>
Get private key data.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.privateKey">
<summary>
Get private key.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.publicKeyInfo">
<summary>
Get public key info corresponding to the private key.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.toASN1">
<summary>
Generate ASN.1 structure.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.toDER">
<summary>
Generate DER encoding.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.OneAsymmetricKey.toPEM">
<summary>
Generate PEM.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PrivateKey.algorithmIdentifier">
<summary>
Get the private key algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PrivateKey.publicKey">
<summary>
Get public key component of the asymmetric key pair.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PrivateKey.toDER">
<summary>
Get DER encoding of the private key.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PrivateKey.toPEM">
<summary>
Get the private key as a PEM.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PrivateKey.privateKeyInfo">
<summary>
Get the private key as a PrivateKeyInfo type.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PrivateKey.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<summary>
Initialize private key from PEM.
</summary>
<param name="pem" type="PEM"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKey.algorithmIdentifier">
<summary>
Get the public key algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKey.toDER">
<summary>
Get DER encoding of the public key.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKey.subjectPublicKeyData">
<summary>
Get the public key data for subjectPublicKey in PublicKeyInfo.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKey.publicKeyInfo">
<summary>
Get the public key as a PublicKeyInfo type.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKey.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<summary>
Initialize public key from PEM.
</summary>
<param name="pem" type="PEM"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.__construct(Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="AlgorithmIdentifierType">Algorithm</param>
<param name="key" type="string">Public key data</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.fromASN1(Pchp.Core.Context,Sop.ASN1.Type.Constructed.Sequence)">
<summary>
Initialize from ASN.1.
</summary>
<param name="seq" type="Sequence"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.fromPublicKey(Pchp.Core.Context,Sop.CryptoTypes.Asymmetric.PublicKey)">
<summary>
Inititalize from a PublicKey.
</summary>
<param name="public_key" type="PublicKey"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<summary>
Initialize from PEM.
</summary>
<param name="pem" type="PEM"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.fromDER(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from DER data.
</summary>
<param name="data" type="string"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.algorithmIdentifier">
<summary>
Get algorithm identifier.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.publicKeyData">
<summary>
Get public key data.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.publicKey">
<summary>
Get public key.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.keyIdentifier">
<summary>
Get key identifier using method 1 as described by RFC 5280.
</summary>
<returns>20 bytes (160 bits) long identifier</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.keyIdentifier64">
<summary>
Get key identifier using method 2 as described by RFC 5280.
</summary>
<returns>8 bytes (64 bits) long identifier</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.toASN1">
<summary>
Generate ASN.1 structure.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.toDER">
<summary>
Generate DER encoding.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.PublicKeyInfo.toPEM">
<summary>
Generate PEM.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="n" type="int|string">Modulus</param>
<param name="e" type="int|string">Public exponent</param>
<param name="d" type="int|string">Private exponent</param>
<param name="p" type="int|string">First prime factor</param>
<param name="q" type="int|string">Second prime factor</param>
<param name="dp" type="int|string">First factor exponent</param>
<param name="dq" type="int|string">Second factor exponent</param>
<param name="qi" type="int|string">CRT coefficient of the second factor</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.fromASN1(Pchp.Core.Context,Sop.ASN1.Type.Constructed.Sequence)">
<summary>
Initialize from ASN.1.
</summary>
<param name="seq" type="Sequence"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.fromDER(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from DER data.
</summary>
<param name="data" type="string"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<param name="pem" type="PEM"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.modulus">
<summary>
Get modulus.
</summary>
<returns>Base 10 integer</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.publicExponent">
<summary>
Get public exponent.
</summary>
<returns>Base 10 integer</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.privateExponent">
<summary>
Get private exponent.
</summary>
<returns>Base 10 integer</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.prime1">
<summary>
Get first prime factor.
</summary>
<returns>Base 10 integer</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.prime2">
<summary>
Get second prime factor.
</summary>
<returns>Base 10 integer</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.exponent1">
<summary>
Get first factor exponent.
</summary>
<returns>Base 10 integer</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.exponent2">
<summary>
Get second factor exponent.
</summary>
<returns>Base 10 integer</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.coefficient">
<summary>
Get CRT coefficient of the second factor.
</summary>
<returns>Base 10 integer</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.algorithmIdentifier">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.publicKey">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.toASN1">
<summary>
Generate ASN.1 structure.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.toDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey.toPEM">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="n" type="int|string">Modulus</param>
<param name="e" type="int|string">Public exponent</param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.fromASN1(Pchp.Core.Context,Sop.ASN1.Type.Constructed.Sequence)">
<summary>
Initialize from ASN.1.
</summary>
<param name="seq" type="Sequence"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.fromDER(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from DER data.
</summary>
<param name="data" type="string"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<param name="pem" type="PEM"></param>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.modulus">
<summary>
Get modulus.
</summary>
<returns>Base 10 integer</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.publicExponent">
<summary>
Get public exponent.
</summary>
<returns>Base 10 integer</returns>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.algorithmIdentifier">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.toASN1">
<summary>
Generate ASN.1 structure.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.toDER">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey.toPEM">
<summary>
Generate PEM.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.__construct(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="r" type="int|string">Signature's `r` value</param>
<param name="s" type="int|string">Signature's `s` value</param>
</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.fromASN1(Pchp.Core.Context,Sop.ASN1.Type.Constructed.Sequence)">
<summary>
Initialize from ASN.1.
</summary>
<param name="seq" type="Sequence"></param>
</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.fromDER(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from DER.
</summary>
<param name="data" type="string"></param>
</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.r">
<summary>
Get the r-value.
</summary>
<returns>Base 10 integer string</returns>
</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.s">
<summary>
Get the s-value.
</summary>
<returns>Base 10 integer string</returns>
</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.toASN1">
<summary>
Generate ASN.1 structure.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.toDER">
<summary>
Get DER encoding of the signature.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.ECSignature.bitString">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.GenericSignature.__construct(Sop.ASN1.Type.Primitive.BitString,Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType)">
<summary>
Constructor.
</summary>
<param name="signature" type="BitString">Signature value</param>
<param name="algo" type="AlgorithmIdentifierType">Algorithm identifier</param>
</member>
<member name="M:Sop.CryptoTypes.Signature.GenericSignature.signatureAlgorithm">
<summary>
Get the signature algorithm.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.GenericSignature.bitString">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.RSASignature.__construct">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.RSASignature.fromSignatureString(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from RSA signature *S*.
Signature value *S* is the result of last step in RSA signature
process defined in PKCS #1.
</summary>
<param name="signature" type="string">Signature bits</param>
</member>
<member name="M:Sop.CryptoTypes.Signature.RSASignature.bitString">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.Signature.bitString">
<summary>
Get the signature as a BitString.
</summary>
</member>
<member name="M:Sop.CryptoTypes.Signature.Signature.fromSignatureData(Pchp.Core.Context,Pchp.Core.PhpString,Sop.CryptoTypes.AlgorithmIdentifier.Feature.AlgorithmIdentifierType)">
<summary>
Get signature object by signature data and used algorithm.
</summary>
<param name="data" type="string">Signature value</param>
<param name="algo" type="AlgorithmIdentifierType">Algorithm identifier</param>
</member>
<member name="M:Sop.GCM.AESGCM.encrypt(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,System.Int64)">
<summary>
Encrypt plaintext.
</summary>
<param name="plaintext" type="string">Plaintext to encrypt</param>
<param name="aad" type="string">Additional authenticated data</param>
<param name="key" type="string">Encryption key</param>
<param name="iv" type="string">Initialization vector</param>
<param name="tag_length" type="int">Authentication tag length in bytes</param>
<returns>Tuple of ciphertext and authentication tag</returns>
</member>
<member name="M:Sop.GCM.AESGCM.decrypt(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Decrypt ciphertext.
</summary>
<param name="ciphertext" type="string">Ciphertext to decrypt</param>
<param name="auth_tag" type="string">Authentication tag to verify</param>
<param name="aad" type="string">Additional authenticated data</param>
<param name="key" type="string">Encryption key</param>
<param name="iv" type="string">Initialization vector</param>
<exception cref="Sop.GCM.Exception.AuthenticationException">If message authentication fails</exception>
<returns>Plaintext</returns>
</member>
<member name="M:Sop.GCM.AESGCM._getGCM(Pchp.Core.Context,Sop.GCM.Cipher.AES.AESCipher,System.Int64)">
<summary>
Get GCM instance.
</summary>
<param name="cipher" type="AESCipher">Cipher instance</param>
<param name="tag_length" type="int">Authentication tag length</param>
</member>
<member name="M:Sop.GCM.Cipher.AES.AES128Cipher._cipherName">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AES128Cipher._nativeCipherName">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AES128Cipher._keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AES192Cipher._cipherName">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AES192Cipher._nativeCipherName">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AES192Cipher._keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AES256Cipher._cipherName">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AES256Cipher._nativeCipherName">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AES256Cipher._keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AESCipher.fromKeyLength(Pchp.Core.Context,System.Int64)">
<summary>
Get AES cipher instance by key length.
</summary>
<param name="len" type="int">Key length in bytes</param>
</member>
<member name="M:Sop.GCM.Cipher.AES.AESCipher.encrypt(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
<exception cref="UnexpectedValueException">If key size is incorrect</exception>
<exception cref="RuntimeException">For generic errors</exception>
</member>
<member name="M:Sop.GCM.Cipher.AES.AESCipher.hasNativeCipher">
<summary>
Check whether OpenSSL has native AES-GCM cipher available.
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AESCipher.nativeEncrypt(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,System.Int64)">
<summary>
Encrypt plaintext using native OpenSSL.
</summary>
<param name="plaintext" type="string">Plaintext to encrypt</param>
<param name="aad" type="string">Additional authenticated data</param>
<param name="key" type="string">Encryption key</param>
<param name="iv" type="string">Initialization vector</param>
<param name="tag_length" type="int">Authentication tag length in bytes</param>
<returns>Tuple of ciphertext and authentication tag</returns>
</member>
<member name="M:Sop.GCM.Cipher.AES.AESCipher.nativeDecrypt(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Decrypt ciphertext using native OpenSSL.
</summary>
<param name="ciphertext" type="string">Ciphertext to decrypt</param>
<param name="auth_tag" type="string">Authentication tag to verify</param>
<param name="aad" type="string">Additional authenticated data</param>
<param name="key" type="string">Encryption key</param>
<param name="iv" type="string">Initialization vector</param>
<returns>Plaintext</returns>
</member>
<member name="M:Sop.GCM.Cipher.AES.AESCipher._cipherName">
<summary>
Get the AES-ECB cipher method name recognized by OpenSSL.
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AESCipher._nativeCipherName">
<summary>
Get the AES-GCM cipher method recognized by OpenSSL.
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AESCipher._keySize">
<summary>
Get the key size in bytes.
</summary>
</member>
<member name="M:Sop.GCM.Cipher.AES.AESCipher._getLastOpenSSLError(Pchp.Core.Context)">
<summary>
Get latest OpenSSL error message.
</summary>
</member>
<member name="M:Sop.GCM.Cipher.Cipher.encrypt(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Encrypt data.
</summary>
<param name="data" type="string">Data to encrypt</param>
<param name="key" type="string">Encryption key</param>
<returns>Encrypted data</returns>
</member>
<member name="M:Sop.GCM.GCM.__construct(Sop.GCM.Cipher.Cipher,System.Int64)">
<summary>
Constructor.
</summary>
<param name="cipher" type="Cipher">Cipher implementation</param>
<param name="tag_length" type="int">Authentication tag length in bytes</param>
<exception cref="DomainException">If tag length is not supported</exception>
</member>
<member name="M:Sop.GCM.GCM.encrypt(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Encrypt plaintext.
</summary>
<param name="P" type="string">Plaintext</param>
<param name="A" type="string">Additional authenticated data</param>
<param name="K" type="string">Encryption key</param>
<param name="IV" type="string">Initialization vector</param>
<exception cref="RuntimeException">For generic errors</exception>
<returns>Tuple of ciphertext `C` and authentication tag `T`</returns>
</member>
<member name="M:Sop.GCM.GCM.decrypt(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Decrypt ciphertext.
</summary>
<param name="C" type="string">Ciphertext</param>
<param name="T" type="string">Authentication tag</param>
<param name="A" type="string">Additional authenticated data</param>
<param name="K" type="string">Encryption key</param>
<param name="IV" type="string">Initialization vector</param>
<exception cref="AuthenticationException">If message authentication fails</exception>
<exception cref="RuntimeException">For generic errors</exception>
<returns>Plaintext `P`</returns>
</member>
<member name="M:Sop.GCM.GCM.strToGMP(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Convert string to GMP number.
String is interpreted as an unsigned integer with big endian order and
the most significant byte first.
</summary>
<param name="data" type="string">Binary data</param>
</member>
<member name="M:Sop.GCM.GCM.gmpToStr(Pchp.Core.Context,System.Object,System.Int64)">
<summary>
Convert GMP number to string.
Returned string represents an unsigned integer with big endian order and
the most significant byte first.
</summary>
<param name="num" type="\GMP">GMP number</param>
<param name="size" type="int">Width of the string in bytes</param>
<returns>Binary data</returns>
</member>
<member name="M:Sop.GCM.GCM._generateJ0(Pchp.Core.PhpString,Sop.GCM.GHASH)">
<summary>
Generate pre-counter block.
See NIST SP-300-38D section 7.1 step 2 for the details.
</summary>
<param name="IV" type="string">Initialization vector</param>
<param name="ghash" type="GHASH">GHASH functor</param>
</member>
<member name="M:Sop.GCM.GCM._gctr(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Apply GCTR algorithm.
See NIST SP-300-38D section 6.5 for the details.
</summary>
<param name="ICB" type="string">Initial counter block</param>
<param name="X" type="string">Input data</param>
<param name="K" type="string">Encryption key</param>
<returns>Output data</returns>
</member>
<member name="M:Sop.GCM.GCM._computeAuthTag(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Sop.GCM.GHASH)">
<summary>
Compute authentication tag.
See NIST SP-300-38D section 7.1 steps 5-6 for the details.
</summary>
<param name="A" type="string">Additional authenticated data</param>
<param name="C" type="string">Ciphertext</param>
<param name="J0" type="string">Pre-counter block</param>
<param name="K" type="string">Encryption key</param>
<param name="ghash" type="GHASH">GHASH functor</param>
<returns>Authentication tag `T`</returns>
</member>
<member name="M:Sop.GCM.GCM._pad128(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Pad data to 128 bit block boundary.
</summary>
<param name="data" type="string"></param>
</member>
<member name="M:Sop.GCM.GCM._inc32(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Increment 32 rightmost bits of the counter block.
See NIST SP-300-38D section 6.2 for the details.
</summary>
<param name="X" type="string"></param>
</member>
<member name="M:Sop.GCM.GCM._uint64(Pchp.Core.Context,System.Int64)">
<summary>
Convert integer to 64 bit big endian binary string.
</summary>
<param name="num" type="int"></param>
</member>
<member name="M:Sop.GCM.GHASH.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="subkey" type="string">Hash subkey</param>
</member>
<member name="M:Sop.GCM.GHASH.__invoke(Pchp.Core.PhpString)">
<summary>
Functor method for `compute`.
</summary>
<param name="arg" type="string"></param>
</member>
<member name="M:Sop.GCM.GHASH.compute(Pchp.Core.PhpString)">
<summary>
Compute hash.
</summary>
<param name="X" type="string">Input string</param>
<returns>Hash</returns>
</member>
<member name="M:Sop.GCM.GHASH._mult(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Apply block multiplication operation.
See NIST SP-800-38D, chapter 6.3 for the details.
</summary>
<param name="X" type="string"></param>
<param name="Y" type="string"></param>
</member>
<member name="M:Sop.JWX.JWA.JWA.deriveAlgorithmName(Pchp.Core.Context,Sop.JWX.JWT.Header.Header,Sop.JWX.JWK.JWK)">
<summary>
Derive algorithm name from the header and optionally from the given JWK.
</summary>
<param name="header" type="Header">Header</param>
<param name="jwk" type="JWK">Optional JWK</param>
<exception cref="UnexpectedValueException">if algorithm parameter is not present
or header and JWK algorithms differ</exception>
<returns>Algorithm name</returns>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.compress(Pchp.Core.PhpString)">
<summary>
Compress data.
</summary>
<param name="data" type="string">Uncompressed data</param>
<returns>Compressed data</returns>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.decompress(Pchp.Core.PhpString)">
<summary>
Decompress data.
</summary>
<param name="data" type="string">Compressed data</param>
<returns>Uncompressed data</returns>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.CompressionFactory.algoByName(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Get the compression algorithm by name.
</summary>
<exception cref="UnexpectedValueException">If algorithm is not supported</exception>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.CompressionFactory.algoByHeader(Pchp.Core.Context,Sop.JWX.JWT.Header.Header)">
<summary>
Get the compression algorithm as specified in the given header.
</summary>
<param name="header" type="Header">Header</param>
<exception cref="UnexpectedValueException">If compression algorithm parameter is
not present or algorithm is not supported</exception>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.DeflateAlgorithm.__construct(System.Int64)">
<summary>
Constructor.
</summary>
<param name="level" type="int">Compression level 0..9</param>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.DeflateAlgorithm.compress(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.DeflateAlgorithm.decompress(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.DeflateAlgorithm.compressionParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.CompressionAlgorithm.DeflateAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.ContentEncryptionAlgorithm.encrypt(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Encrypt plaintext.
</summary>
<param name="plaintext" type="string">Data to encrypt</param>
<param name="key" type="string">Encryption key</param>
<param name="iv" type="string">Initialization vector</param>
<param name="aad" type="string">Additional authenticated data</param>
<returns>Tuple of ciphertext and authentication tag</returns>
</member>
<member name="M:Sop.JWX.JWE.ContentEncryptionAlgorithm.decrypt(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Decrypt ciphertext.
</summary>
<param name="ciphertext" type="string">Data to decrypt</param>
<param name="key" type="string">Encryption key</param>
<param name="iv" type="string">Initialization vector</param>
<param name="aad" type="string">Additional authenticated data</param>
<param name="auth_tag" type="string">Authentication tag to compare</param>
<returns>Plaintext</returns>
</member>
<member name="M:Sop.JWX.JWE.ContentEncryptionAlgorithm.keySize">
<summary>
Get the required key size in bytes.
</summary>
</member>
<member name="M:Sop.JWX.JWE.ContentEncryptionAlgorithm.ivSize">
<summary>
Get the required IV size in bytes.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A128CBCHS256Algorithm.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A128CBCHS256Algorithm.encryptionAlgorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A128CBCHS256Algorithm._cipherMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A128CBCHS256Algorithm._hashAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A128CBCHS256Algorithm._encKeyLen">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A128CBCHS256Algorithm._macKeyLen">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A128CBCHS256Algorithm._tagLen">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A128GCMAlgorithm.encryptionAlgorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A128GCMAlgorithm.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A192CBCHS384Algorithm.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A192CBCHS384Algorithm.encryptionAlgorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A192CBCHS384Algorithm._cipherMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A192CBCHS384Algorithm._hashAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A192CBCHS384Algorithm._encKeyLen">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A192CBCHS384Algorithm._macKeyLen">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A192CBCHS384Algorithm._tagLen">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A192GCMAlgorithm.encryptionAlgorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A192GCMAlgorithm.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A256CBCHS512Algorithm.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A256CBCHS512Algorithm.encryptionAlgorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A256CBCHS512Algorithm._cipherMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A256CBCHS512Algorithm._hashAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A256CBCHS512Algorithm._encKeyLen">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A256CBCHS512Algorithm._macKeyLen">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A256CBCHS512Algorithm._tagLen">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A256GCMAlgorithm.encryptionAlgorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.A256GCMAlgorithm.keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm.encrypt(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm.decrypt(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm.ivSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._cipherMethod">
<summary>
Get cipher method name that is recognized by OpenSSL.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._hashAlgo">
<summary>
Get algorithm name that is recognized by the Hash extension.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._encKeyLen">
<summary>
Get length of the encryption key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._macKeyLen">
<summary>
Get length of the MAC key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._tagLen">
<summary>
Get length of the authentication tag.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._getCipherMethod">
<summary>
Get cipher method and verify that it's supported.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._validateKey(Pchp.Core.PhpString)">
<summary>
Check that key is valid.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._validateIV(Pchp.Core.PhpString)">
<summary>
Check that IV is valid.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._macKey(Pchp.Core.PhpString)">
<summary>
Get MAC key from CEK.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._encKey(Pchp.Core.PhpString)">
<summary>
Get encryption key from CEK.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._aadLen(Pchp.Core.PhpString)">
<summary>
Compute AL value.
</summary>
<returns>64 bits</returns>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._computeAuthTag(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Compute authentication tag.
</summary>
<param name="key" type="string">CEK</param>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESCBCAlgorithm._getLastOpenSSLError">
<summary>
Get last OpenSSL error message.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESGCMAlgorithm.encrypt(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESGCMAlgorithm.decrypt(Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESGCMAlgorithm.ivSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESGCMAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESGCMAlgorithm._validateKey(Pchp.Core.PhpString)">
<summary>
Check that key is valid.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.AESGCMAlgorithm._validateIV(Pchp.Core.PhpString)">
<summary>
Check that IV is valid.
</summary>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.EncryptionAlgorithmFactory.algoByName(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Get the content encryption algorithm by algorithm name.
</summary>
<param name="name" type="string">Algorithm name</param>
<exception cref="UnexpectedValueException">if algorithm is not supported</exception>
</member>
<member name="M:Sop.JWX.JWE.EncryptionAlgorithm.EncryptionAlgorithmFactory.algoByHeader(Pchp.Core.Context,Sop.JWX.JWT.Header.Header)">
<summary>
Get the content encryption algorithm as specified in the given header.
</summary>
<param name="header" type="Header">Header</param>
<exception cref="UnexpectedValueException">If content encryption algorithm
parameter is not present or algorithm
is not supported</exception>
</member>
<member name="M:Sop.JWX.JWE.JWE.__construct(Sop.JWX.JWT.Header.Header,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="protected_header" type="Header">JWE Protected Header</param>
<param name="encrypted_key" type="string">Encrypted key</param>
<param name="iv" type="string">Initialization vector</param>
<param name="ciphertext" type="string">Ciphertext</param>
<param name="auth_tag" type="string">Authentication tag</param>
<param name="aad" type="null|string">Additional authenticated data</param>
</member>
<member name="M:Sop.JWX.JWE.JWE.__toString">
<summary>
Convert JWE to string.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.fromCompact(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from compact serialization.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.fromParts(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Initialize from parts of compact serialization.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.encrypt(Pchp.Core.Context,Pchp.Core.PhpString,Sop.JWX.JWE.KeyManagementAlgorithm,Sop.JWX.JWE.ContentEncryptionAlgorithm,Sop.JWX.JWE.CompressionAlgorithm,Sop.JWX.JWT.Header.Header,Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Initialize by encrypting the given payload.
</summary>
<param name="payload" type="string">Payload</param>
<param name="key_algo" type="KeyManagementAlgorithm">Key management algorithm</param>
<param name="enc_algo" type="ContentEncryptionAlgorithm">Content encryption algorithm</param>
<param name="zip_algo" type="null|CompressionAlgorithm">Optional compression algorithm</param>
<param name="header" type="null|Header">Optional desired header.
Algorithm specific parameters are
automatically added.</param>
<param name="cek" type="null|string">Optional content encryption key.
Randomly enerated if not set.</param>
<param name="iv" type="null|string">Optional initialization vector.
Randomly generated if not set.</param>
<exception cref="RuntimeException">If encrypt fails</exception>
</member>
<member name="M:Sop.JWX.JWE.JWE.decrypt(Sop.JWX.JWE.KeyManagementAlgorithm,Sop.JWX.JWE.ContentEncryptionAlgorithm)">
<summary>
Decrypt the content using explicit algorithms.
</summary>
<param name="key_algo" type="KeyManagementAlgorithm">Key management algorithm</param>
<param name="enc_algo" type="ContentEncryptionAlgorithm">Content encryption algorithm</param>
<exception cref="RuntimeException">If decrypt fails</exception>
<returns>Plaintext payload</returns>
</member>
<member name="M:Sop.JWX.JWE.JWE.decryptWithJWK(Sop.JWX.JWK.JWK)">
<summary>
Decrypt content using given JWK.
Key management and content encryption algorithms are determined from the
header.
</summary>
<param name="jwk" type="JWK">JSON Web Key</param>
<exception cref="RuntimeException">If algorithm initialization fails</exception>
<returns>Plaintext payload</returns>
</member>
<member name="M:Sop.JWX.JWE.JWE.decryptWithJWKSet(Sop.JWX.JWK.JWKSet)">
<summary>
Decrypt content using a key from the given JWK set.
Correct key shall be sought by the key ID indicated by the header.
</summary>
<param name="set" type="JWKSet">Set of JSON Web Keys</param>
<exception cref="RuntimeException">If algorithm initialization fails</exception>
<returns>Plaintext payload</returns>
</member>
<member name="M:Sop.JWX.JWE.JWE.header">
<summary>
Get JOSE header.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.algorithmName">
<summary>
Get the name of the key management algorithm.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.encryptionAlgorithmName">
<summary>
Get the name of the encryption algorithm.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.encryptedKey">
<summary>
Get encrypted CEK.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.initializationVector">
<summary>
Get initialization vector.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.ciphertext">
<summary>
Get ciphertext.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.authenticationTag">
<summary>
Get authentication tag.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE.toCompact">
<summary>
Convert to compact serialization.
</summary>
</member>
<member name="M:Sop.JWX.JWE.JWE._encryptContent(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString,Sop.JWX.JWE.KeyManagementAlgorithm,Sop.JWX.JWE.ContentEncryptionAlgorithm,Sop.JWX.JWT.Header.Header)">
<summary>
Encrypt content with explicit parameters.
</summary>
<param name="plaintext" type="string">Plaintext content to encrypt</param>
<param name="cek" type="string">Content encryption key</param>
<param name="iv" type="string">Initialization vector</param>
<param name="key_algo" type="KeyManagementAlgorithm">Key management algorithm</param>
<param name="enc_algo" type="ContentEncryptionAlgorithm">Content encryption algorithm</param>
<param name="header" type="Header">Header</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128GCMKWAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128GCMKWAlgorithm._keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128KWAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128KWAlgorithm._kekSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A128KWAlgorithm._AESKWAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192GCMKWAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192GCMKWAlgorithm._keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192KWAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192KWAlgorithm._kekSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A192KWAlgorithm._AESKWAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256GCMKWAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256GCMKWAlgorithm._keySize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256KWAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256KWAlgorithm._kekSize">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.A256KWAlgorithm._AESKWAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm.__construct(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
<param name="iv" type="string">Initialization vector</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Sop.JWX.JWT.Header.Header)">
<summary>
Initialize from JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm.fromKey(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString)">
<summary>
Initialize from key encryption key with random IV.
Key size must match the underlying cipher.
</summary>
<param name="key" type="string">Key encryption key</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm._keySize">
<summary>
Get the required key size.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm._encryptKey(Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESGCMKWAlgorithm._decryptKey(Pchp.Core.PhpString,Sop.JWX.JWT.Header.Header)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="kek" type="string">Key encryption key</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Sop.JWX.JWT.Header.Header)">
<summary>
Initialize from JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm._kekSize">
<summary>
Get the size of the key encryption key in bytes.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm._AESKWAlgo">
<summary>
Get key wrapping algorithm instance.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm._kw">
<summary>
Get key wrapping algorithm.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm._encryptKey(Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.AESKWAlgorithm._decryptKey(Pchp.Core.PhpString,Sop.JWX.JWT.Header.Header)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="cek" type="string">Content encryption key</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Sop.JWX.JWT.Header.Header)">
<summary>
Initialize from JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm.cek">
<summary>
Get content encryption key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm.cekForEncryption(System.Int64)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm._encryptKey(Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.DirectCEKAlgorithm._decryptKey(Pchp.Core.PhpString,Sop.JWX.JWT.Header.Header)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.Feature.RandomCEK`1`1.cekForEncryption(System.Int64)">
<summary>
Generate a random content encryption key.
</summary>
<param name="length" type="int">Key length in bytes</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.KeyAlgorithmFactory.__construct(Sop.JWX.JWT.Header.Header)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.KeyAlgorithmFactory.algoByKey(Sop.JWX.JWK.JWK)">
<summary>
Get key management algorithm by given JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.KeyAlgorithmFactory.algoByKeys(Sop.JWX.JWK.JWKSet)">
<summary>
Get key management algorithm using a matching key from given JWK set.
</summary>
<exception cref="UnexpectedValueException">If a key cannot be found</exception>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.KeyAlgorithmFactory._algoClassByName(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Get the algorithm implementation class name by an algorithm name.
</summary>
<param name="alg" type="string">Algorithm name</param>
<returns>Class name</returns>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm.__construct(Pchp.Core.PhpString,Pchp.Core.PhpString,System.Int64)">
<summary>
Constructor.
</summary>
<param name="password" type="string">Password</param>
<param name="salt_input" type="string">Salt input</param>
<param name="count" type="int">Iteration count</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Sop.JWX.JWT.Header.Header)">
<summary>
Initialize from JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm.fromPassword(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString,System.Int64,System.Int64)">
<summary>
Initialize from a password with random salt and default iteration count.
</summary>
<param name="password" type="string">Password</param>
<param name="count" type="int">Optional user defined iteration count</param>
<param name="salt_bytes" type="int">Optional user defined salt length</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm.saltInput">
<summary>
Get salt input.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm.salt">
<summary>
Get computed salt.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm.iterationCount">
<summary>
Get iteration count.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm._hashAlgo">
<summary>
Get hash algorithm for hash_pbkdf2.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm._keyLength">
<summary>
Get derived key length.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm._kwAlgo">
<summary>
Get key wrapping algoritym.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm._derivedKey">
<summary>
Get derived key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm._encryptKey(Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2Algorithm._decryptKey(Pchp.Core.PhpString,Sop.JWX.JWT.Header.Header)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS256A128KWAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS256A128KWAlgorithm._hashAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS256A128KWAlgorithm._keyLength">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS256A128KWAlgorithm._kwAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS384A192KWAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS384A192KWAlgorithm._hashAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS384A192KWAlgorithm._keyLength">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS384A192KWAlgorithm._kwAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS512A256KWAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS512A256KWAlgorithm._hashAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS512A256KWAlgorithm._keyLength">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.PBES2HS512A256KWAlgorithm._kwAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm.__construct(Sop.JWX.JWK.RSA.RSAPublicKeyJWK,Sop.JWX.JWK.RSA.RSAPrivateKeyJWK)">
<summary>
Constructor.
Use `fromPublicKey` or `fromPrivateKey` instead!
</summary>
<param name="pub_key" type="RSAPublicKeyJWK">RSA public key</param>
<param name="priv_key" type="RSAPrivateKeyJWK">Optional RSA private key</param>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Sop.JWX.JWT.Header.Header)">
<summary>
Initialize from JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm.fromPublicKey(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.JWX.JWK.RSA.RSAPublicKeyJWK)">
<summary>
Initialize from a public key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm.fromPrivateKey(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.JWX.JWK.RSA.RSAPrivateKeyJWK)">
<summary>
Initialize from a private key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm.publicKey">
<summary>
Get the public key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm.hasPrivateKey">
<summary>
Check whether the private key is present.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm.privateKey">
<summary>
Get the private key.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm._paddingScheme">
<summary>
Get the padding scheme.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm._encryptKey(Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm._decryptKey(Pchp.Core.PhpString,Sop.JWX.JWT.Header.Header)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESKeyAlgorithm._getLastOpenSSLError">
<summary>
Get last OpenSSL error message.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESOAEPAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESOAEPAlgorithm._paddingScheme">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESPKCS1Algorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyAlgorithm.RSAESPKCS1Algorithm._paddingScheme">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyManagementAlgorithm.encrypt(Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Encrypt a key to be inserted into JWE header.
</summary>
<param name="cek" type="string">Content encryption key</param>
<param name="header" type="null|Header">Optional reference to the Header variable,
which may be updated to contain parameters
specific to this encrypt invocation.
If the variable is referenced, but is a null,
it shall be initialized to an empty Header.</param>
<exception cref="RuntimeException">For generic errors</exception>
<returns>Encrypted key</returns>
</member>
<member name="M:Sop.JWX.JWE.KeyManagementAlgorithm.decrypt(Pchp.Core.PhpString,Sop.JWX.JWT.Header.Header)">
<summary>
Decrypt a CEK from the encrypted data.
</summary>
<param name="data" type="string">Encrypted key</param>
<param name="header" type="null|Header">Optional header containing parameters
required to decrypt the key</param>
<exception cref="RuntimeException">For generic errors</exception>
<returns>Content encryption key</returns>
</member>
<member name="M:Sop.JWX.JWE.KeyManagementAlgorithm.cekForEncryption(System.Int64)">
<summary>
Get content encryption key for the encryption.
Returned key may be random depending on the key management algorithm.
</summary>
<param name="length" type="int">Required key size in bytes</param>
</member>
<member name="M:Sop.JWX.JWE.KeyManagementAlgorithm.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Sop.JWX.JWT.Header.Header)">
<summary>
Initialize key management algorithm from a JWK and a header.
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyManagementAlgorithm.withKeyID(Pchp.Core.PhpValue)">
<summary>
Get self with key ID.
</summary>
<param name="id" type="null|string">Key ID or null to remove</param>
</member>
<member name="M:Sop.JWX.JWE.KeyManagementAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWE.KeyManagementAlgorithm._encryptKey(Pchp.Core.PhpString,Pchp.Core.PhpAlias)">
<summary>
Encrypt a key.
</summary>
<param name="key" type="string">Key to be encrypted</param>
<param name="header" type="Header">Reference to the Header variable, that shall
be updated to contain parameters specific to the encryption</param>
<returns>Ciphertext</returns>
</member>
<member name="M:Sop.JWX.JWE.KeyManagementAlgorithm._decryptKey(Pchp.Core.PhpString,Sop.JWX.JWT.Header.Header)">
<summary>
Decrypt a key.
</summary>
<param name="ciphertext" type="string">Ciphertext of the encrypted key</param>
<param name="header" type="Header">Header possibly containing encoding specific
parameters</param>
<returns>Plaintext key</returns>
</member>
<member name="M:Sop.JWX.JWK.Asymmetric.PrivateKeyJWK.publicKey">
<summary>
Get the public key component of the asymmetric key pair.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Asymmetric.PrivateKeyJWK.toPEM">
<summary>
Convert private key to PEM.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Asymmetric.PrivateKeyJWK.fromPrivateKey(Pchp.Core.Context,Sop.CryptoTypes.Asymmetric.PrivateKey)">
<summary>
Initialize from a PrivateKey object.
</summary>
<param name="priv_key" type="PrivateKey">Private key</param>
</member>
<member name="M:Sop.JWX.JWK.Asymmetric.PrivateKeyJWK.fromPrivateKeyInfo(Pchp.Core.Context,Sop.CryptoTypes.Asymmetric.PrivateKeyInfo)">
<summary>
Initialize from a PrivateKeyInfo object.
</summary>
<param name="pki" type="PrivateKeyInfo">PrivateKeyInfo</param>
</member>
<member name="M:Sop.JWX.JWK.Asymmetric.PublicKeyJWK.toPEM">
<summary>
Convert public key to PEM.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Asymmetric.PublicKeyJWK.fromPublicKey(Pchp.Core.Context,Sop.CryptoTypes.Asymmetric.PublicKey)">
<summary>
Initialize from a PublicKey object.
</summary>
<param name="pub_key" type="PublicKey">Public key</param>
</member>
<member name="M:Sop.JWX.JWK.Asymmetric.PublicKeyJWK.fromPublicKeyInfo(Pchp.Core.Context,Sop.CryptoTypes.Asymmetric.PublicKeyInfo)">
<summary>
Initialize from a PublicKeyInfo object.
</summary>
<param name="pki" type="PublicKeyInfo">Public key info</param>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPrivateKeyJWK.__construct(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPrivateKeyJWK.fromECPrivateKey(Pchp.Core.Context,Sop.CryptoTypes.Asymmetric.EC.ECPrivateKey)">
<summary>
Initialize from ECPrivateKey.
</summary>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPrivateKeyJWK.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<summary>
Initialize from PEM.
</summary>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPrivateKeyJWK.publicKey">
<summary>
Get the public key component of the EC private key.
</summary>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPrivateKeyJWK.toPEM">
<summary>
Convert EC private key to PEM.
</summary>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPublicKeyJWK.__construct(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPublicKeyJWK.fromECPublicKey(Pchp.Core.Context,Sop.CryptoTypes.Asymmetric.EC.ECPublicKey)">
<summary>
Initialize from ECPublicKey.
</summary>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPublicKeyJWK.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<summary>
Initialize from PEM.
</summary>
</member>
<member name="M:Sop.JWX.JWK.EC.ECPublicKeyJWK.toPEM">
<summary>
Convert EC public key to PEM.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.__construct(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.fromArray(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpArray)">
<summary>
Initialize from an array representing a JSON object.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.fromJSON(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString)">
<summary>
Initialize from a JSON string.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.fromJWK(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.JWX.JWK.JWK)">
<summary>
Initialize from another JWK.
Allows casting to subclass by late static binding.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.withParameters(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Get self with parameters added.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.parameters">
<summary>
Get all parameters.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.withKeyID(Pchp.Core.PhpString)">
<summary>
Get self with given key ID added to parameters.
</summary>
<param name="id" type="string">Key ID as a string</param>
</member>
<member name="M:Sop.JWX.JWK.JWK.has(Pchp.Core.PhpString[])">
<summary>
Whether parameters are present.
Returns false if any of the given parameters is not set.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.get(Pchp.Core.PhpString)">
<summary>
Get a parameter.
</summary>
<param name="name" type="string">Parameter name</param>
</member>
<member name="M:Sop.JWX.JWK.JWK.toArray">
<summary>
Convert to array.
</summary>
<returns>Parameter values keyed by parameter names</returns>
</member>
<member name="M:Sop.JWX.JWK.JWK.toJSON">
<summary>
Convert to JSON.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.count">
<summary>
Get the number of parameters.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWK.getIterator">
<summary>
Get iterator for the parameters.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.__construct(Sop.JWX.JWK.JWK[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.__clone">
<summary>
Reset internal cache variables on clone.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.fromArray(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Initialize from an array representing a JSON object.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.fromJSON(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from a JSON string.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.withKeys(Sop.JWX.JWK.JWK[])">
<summary>
Get self with keys added.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.keys">
<summary>
Get all JWK's in a set.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.first">
<summary>
Get the first JWK in the set.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.hasKeyID(Pchp.Core.PhpString)">
<summary>
Check whether set has a JWK with a given key ID.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.keyByID(Pchp.Core.PhpString)">
<summary>
Get a JWK by a key ID.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.toArray">
<summary>
Convert to array.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.toJSON">
<summary>
Convert to JSON.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.count">
<summary>
Get the number of keys.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet.getIterator">
<summary>
Get iterator for JWK objects.
</summary>
</member>
<member name="M:Sop.JWX.JWK.JWKSet._getKeyByID(Pchp.Core.PhpString)">
<summary>
Get JWK by key ID.
</summary>
<returns>Null if not found</returns>
</member>
<member name="M:Sop.JWX.JWK.JWKSet._getMapping(Pchp.Core.PhpString)">
<summary>
Get mapping from parameter values of given parameter name to JWK.
Later duplicate value shall override earlier JWK.
</summary>
<param name="name" type="string">Parameter name</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.AlgorithmParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="string">Algorithm name</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.CoordinateParameter.coordinateOctets">
<summary>
Get coordinate in octet string representation.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.CurveParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="curve" type="string">Curve name</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.CurveParameter.fromOID(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from curve OID.
</summary>
<param name="oid" type="string">Object identifier in dotted format</param>
<exception cref="UnexpectedValueException">If the curve is not supported</exception>
</member>
<member name="M:Sop.JWX.JWK.Parameter.CurveParameter.keySizeBits">
<summary>
Get key size in bits for the curve.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.CurveParameter.nameToOID(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Get the curve OID by curve name.
</summary>
<param name="name" type="string">Curve parameter name</param>
<exception cref="UnexpectedValueException">If the curve is not supported</exception>
<returns>OID in dotted format</returns>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ECCPrivateKeyParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Private key in base64url encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ECCPrivateKeyParameter.privateKeyOctets">
<summary>
Get the EC private key in octet string representation.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ExponentParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="e" type="string">Exponent in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstCRTCoefficientParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="qi" type="string">First CRT coefficient in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstFactorCRTExponentParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="dp" type="string">First factor CRT exponent in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.FirstPrimeFactorParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="p" type="string">First prime factor in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.JWKParameter.__construct(Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="name" type="string">Parameter name</param>
<param name="value" type="mixed">Parameter value</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.JWKParameter.fromNameAndValue(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Initialize from a name and a value.
Returns a parameter specific object if one is implemented.
</summary>
<param name="name" type="string">Parameter name</param>
<param name="value" type="mixed">Parameter value</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.JWKParameter.fromJSONValue(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Initialize from a JSON value.
</summary>
<param name="value" type="mixed"></param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyIDParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="id" type="string">Key ID</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyOperationsParameter.__construct(Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyTypeParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="type" type="string">Key type</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyValueParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Base64url encoded key</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.KeyValueParameter.key">
<summary>
Get key in binary format.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.ModulusParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="n" type="string">Modulus in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.OtherPrimesInfoParameter.__construct(Pchp.Core.PhpValue[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.PrivateExponentParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="d" type="string">Private exponent in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.PublicKeyUseParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="use" type="string">Intended use of the public key</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.SecondFactorCRTExponentParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="dq" type="string">Second factor CRT exponent in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.SecondPrimeFactorParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="q" type="string">Second prime factor in base64urlUInt encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateChainParameter.__construct(Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateSHA1ThumbprintParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-1 hash</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509CertificateSHA256ThumbprintParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-256 hash</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.X509URLParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Parameter.XCoordinateParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="coord" type="string">X coordinate in base64url encoding</param>
</member>
<member name="M:Sop.JWX.JWK.Parameter.YCoordinateParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="coord" type="string">Y coordinate in base64url encoding</param>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPrivateKeyJWK.__construct(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPrivateKeyJWK.fromRSAPrivateKey(Pchp.Core.Context,Sop.CryptoTypes.Asymmetric.RSA.RSAPrivateKey)">
<summary>
Initialize from RSAPrivateKey.
</summary>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPrivateKeyJWK.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<summary>
Initialize from PEM.
</summary>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPrivateKeyJWK.publicKey">
<summary>
Get public key component.
</summary>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPrivateKeyJWK.toPEM">
<summary>
Convert JWK to PEM.
</summary>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPublicKeyJWK.__construct(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPublicKeyJWK.fromRSAPublicKey(Pchp.Core.Context,Sop.CryptoTypes.Asymmetric.RSA.RSAPublicKey)">
<summary>
Initialize from RSAPublicKey.
</summary>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPublicKeyJWK.fromPEM(Pchp.Core.Context,Sop.CryptoEncoding.PEM)">
<summary>
Initialize from PEM.
</summary>
</member>
<member name="M:Sop.JWX.JWK.RSA.RSAPublicKeyJWK.toPEM">
<summary>
Convert JWK to PEM.
</summary>
</member>
<member name="M:Sop.JWX.JWK.Symmetric.SymmetricKeyJWK.__construct(Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Constructor.
</summary>
<exception cref="UnexpectedValueException">If missing required parameter</exception>
</member>
<member name="M:Sop.JWX.JWK.Symmetric.SymmetricKeyJWK.fromKey(Pchp.Core.Context,Pchp.Core.PhpString,Sop.JWX.JWK.Parameter.JWKParameter[])">
<summary>
Initialize from a key string.
</summary>
<param name="key" type="string">Symmetric key</param>
</member>
<member name="M:Sop.JWX.JWK.Symmetric.SymmetricKeyJWK.key">
<summary>
Get the symmetric key.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.has(Pchp.Core.PhpString[])">
<summary>
Whether parameters are present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.get(Pchp.Core.PhpString)">
<summary>
Get a parameter.
</summary>
<param name="name" type="string">Parameter name</param>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasAlgorithmParameter">
<summary>
Check whether the algorithm parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.algorithmParameter">
<summary>
Get the algorithm parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasCurveParameter">
<summary>
Check whether the curve parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.curveParameter">
<summary>
Get the curve parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasECCPrivateKeyParameter">
<summary>
Check whether the ECC private key parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.ECCPrivateKeyParameter">
<summary>
Get the ECC private key parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasExponentParameter">
<summary>
Check whether the exponent parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.exponentParameter">
<summary>
Get the exponent parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasFirstCRTCoefficientParameter">
<summary>
Check whether the first CRT coefficient parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.firstCRTCoefficientParameter">
<summary>
Get the first CRT coefficient parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasFirstFactorCRTExponentParameter">
<summary>
Check whether the first factor CRT exponent parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.firstFactorCRTExponentParameter">
<summary>
Get the first factor CRT exponent parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasFirstPrimeFactorParameter">
<summary>
Check whether the first prime factor parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.firstPrimeFactorParameter">
<summary>
Get the first prime factor parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasKeyIDParameter">
<summary>
Check whether the key ID parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.keyIDParameter">
<summary>
Get the key ID parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasKeyOperationsParameter">
<summary>
Check whether the key operations parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.keyOperationsParameter">
<summary>
Get the key operations parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasKeyTypeParameter">
<summary>
Check whether the key type parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.keyTypeParameter">
<summary>
Get the key type parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasKeyValueParameter">
<summary>
Check whether the key value parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.keyValueParameter">
<summary>
Get the key value parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasModulusParameter">
<summary>
Check whether the modulus parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.modulusParameter">
<summary>
Get the modulus parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasOtherPrimesInfoParameter">
<summary>
Check whether the other primes info parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.otherPrimesInfoParameter">
<summary>
Get the other primes info parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasPrivateExponentParameter">
<summary>
Check whether the private exponent parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.privateExponentParameter">
<summary>
Get the private exponent parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasPublicKeyUseParameter">
<summary>
Check whether the public key use parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.publicKeyUseParameter">
<summary>
Get the public key use parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasSecondFactorCRTExponentParameter">
<summary>
Check whether the second factor CRT exponent parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.secondFactorCRTExponentParameter">
<summary>
Get the second factor CRT exponent parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasSecondPrimeFactorParameter">
<summary>
Check whether the second prime factor parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.secondPrimeFactorParameter">
<summary>
Get the second prime factor parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasX509CertificateChainParameter">
<summary>
Check whether the X.509 certificate chain parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.X509CertificateChainParameter">
<summary>
Get the X.509 certificate chain parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasX509CertificateSHA1ThumbprintParameter">
<summary>
Check whether the X.509 certificate SHA-1 thumbprint parameter is
present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.X509CertificateSHA1ThumbprintParameter">
<summary>
Get the X.509 certificate SHA-1 thumbprint parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasX509CertificateSHA256ThumbprintParameter">
<summary>
Check whether the X.509 certificate SHA-256 thumbprint parameter is
present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.X509CertificateSHA256ThumbprintParameter">
<summary>
Get the X.509 certificate SHA-256 thumbprint parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasX509URLParameter">
<summary>
Check whether the X.509 URL parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.X509URLParameter">
<summary>
Get the X.509 URL parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasXCoordinateParameter">
<summary>
Check whether the X coordinate parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.XCoordinateParameter">
<summary>
Get the X coordinate parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.hasYCoordinateParameter">
<summary>
Check whether the Y coordinate parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1.YCoordinateParameter">
<summary>
Get the Y coordinate parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWK.TypedJWK`1`1._checkType(Pchp.Core.Context,Sop.JWX.JWK.Parameter.JWKParameter,Pchp.Core.PhpString)">
<summary>
Check that the parameter is an instance of the given class.
</summary>
<param name="param" type="Parameter\JWKParameter">Parameter</param>
<param name="cls" type="string">Class name</param>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ECDSAAlgorithm.__construct(Sop.JWX.JWK.EC.ECPublicKeyJWK,Sop.JWX.JWK.EC.ECPrivateKeyJWK)">
<summary>
Constructor.
</summary>
<param name="priv_key" type="ECPrivateKeyJWK"></param>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ECDSAAlgorithm.fromPublicKey(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.JWX.JWK.EC.ECPublicKeyJWK)">
<summary>
Initialize from a public key.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ECDSAAlgorithm.fromPrivateKey(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.JWX.JWK.EC.ECPrivateKeyJWK)">
<summary>
Initialize from a private key.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ECDSAAlgorithm.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Sop.JWX.JWT.Header.Header)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ECDSAAlgorithm.computeSignature(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ECDSAAlgorithm.validateSignature(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
<exception cref="UnexpectedValueException">If signature length is invalid</exception>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ECDSAAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ECDSAAlgorithm._curveName">
<summary>
Get the name of the curve used by this algorithm.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES256Algorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES256Algorithm._curveName">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES256Algorithm._mdMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES384Algorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES384Algorithm._curveName">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES384Algorithm._mdMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES512Algorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES512Algorithm._curveName">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.ES512Algorithm._mdMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HMACAlgorithm.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="key" type="string">Shared secret key</param>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HMACAlgorithm.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Sop.JWX.JWT.Header.Header)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HMACAlgorithm.computeSignature(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
<exception cref="RuntimeException">For generic errors</exception>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HMACAlgorithm.validateSignature(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HMACAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HMACAlgorithm._hashAlgo">
<summary>
Get algorithm name recognized by the Hash extension.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS256Algorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS256Algorithm._hashAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS384Algorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS384Algorithm._hashAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS512Algorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.HS512Algorithm._hashAlgo">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.NoneAlgorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.NoneAlgorithm.computeSignature(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.NoneAlgorithm.validateSignature(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.NoneAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.OpenSSLSignatureAlgorithm.computeSignature(Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
<exception cref="LogicException">If private key was not provided</exception>
<exception cref="RuntimeException">For generic errors</exception>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.OpenSSLSignatureAlgorithm.validateSignature(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
{@inheritdoc}
</summary>
<exception cref="RuntimeException">For generic errors</exception>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.OpenSSLSignatureAlgorithm._mdMethod">
<summary>
Get the signature algorithm identifier supported by OpenSSL.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.OpenSSLSignatureAlgorithm._getLastOpenSSLError">
<summary>
Get the last OpenSSL error message.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS256Algorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS256Algorithm._mdMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS384Algorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS384Algorithm._mdMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS512Algorithm.algorithmParamValue">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RS512Algorithm._mdMethod">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RSASSAPKCS1Algorithm.__construct(Sop.JWX.JWK.RSA.RSAPublicKeyJWK,Sop.JWX.JWK.RSA.RSAPrivateKeyJWK)">
<summary>
Constructor.
</summary>
<param name="priv_key" type="RSAPrivateKeyJWK"></param>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RSASSAPKCS1Algorithm.fromPublicKey(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.JWX.JWK.RSA.RSAPublicKeyJWK)">
<summary>
Initialize from a public key.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RSASSAPKCS1Algorithm.fromPrivateKey(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Sop.JWX.JWK.RSA.RSAPrivateKeyJWK)">
<summary>
Initialize from a private key.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RSASSAPKCS1Algorithm.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Sop.JWX.JWT.Header.Header)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.RSASSAPKCS1Algorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.SignatureAlgorithmFactory.__construct(Sop.JWX.JWT.Header.Header)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.SignatureAlgorithmFactory.algoByKey(Sop.JWX.JWK.JWK)">
<summary>
Get signature algorithm by given JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.SignatureAlgorithmFactory.algoByKeys(Sop.JWX.JWK.JWKSet)">
<summary>
Get signature algorithm using a matching key from given JWK set.
</summary>
<exception cref="UnexpectedValueException">If a key cannot be found</exception>
</member>
<member name="M:Sop.JWX.JWS.Algorithm.SignatureAlgorithmFactory._algoClassByName(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Get the algorithm implementation class name by an algorithm name.
</summary>
<param name="alg" type="string">Algorithm name</param>
<returns>Class name</returns>
</member>
<member name="M:Sop.JWX.JWS.JWS.__construct(Sop.JWX.JWT.Header.Header,Pchp.Core.PhpString,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="protected_header" type="Header">JWS Protected Header</param>
<param name="payload" type="string">JWS Payload</param>
<param name="signature_input" type="string">Input value for the signature computation</param>
<param name="signature" type="string">JWS Signature</param>
</member>
<member name="M:Sop.JWX.JWS.JWS.__toString">
<summary>
Convert JWS to string.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS.fromCompact(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from a compact serialization.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS.fromParts(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Initialize from the parts of a compact serialization.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS.sign(Pchp.Core.Context,Pchp.Core.PhpString,Sop.JWX.JWS.SignatureAlgorithm,Sop.JWX.JWT.Header.Header)">
<summary>
Initialize by signing the payload with given algorithm.
</summary>
<param name="payload" type="string">JWS Payload</param>
<param name="algo" type="SignatureAlgorithm">Signature algorithm</param>
<param name="header" type="null|Header">Desired header. Algorithm specific
parameters are added automatically.</param>
<exception cref="RuntimeException">If signature computation fails</exception>
</member>
<member name="M:Sop.JWX.JWS.JWS.header">
<summary>
Get JOSE header.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS.algorithmName">
<summary>
Get the signature algorithm name.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS.isUnsecured">
<summary>
Check whether JWS is unsecured, that is, contains no signature.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS.payload">
<summary>
Get the payload.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS.signature">
<summary>
Get the signature.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS.validate(Sop.JWX.JWS.SignatureAlgorithm)">
<summary>
Validate the signature using explicit algorithm.
</summary>
<exception cref="UnexpectedValueException">If using different signature algorithm
then specified by the header</exception>
<exception cref="RuntimeException">If signature computation fails</exception>
<returns>True if signature is valid</returns>
</member>
<member name="M:Sop.JWX.JWS.JWS.validateWithJWK(Sop.JWX.JWK.JWK)">
<summary>
Validate the signature using the given JWK.
Signature algorithm is determined from the header.
</summary>
<param name="jwk" type="JWK">JSON Web Key</param>
<exception cref="RuntimeException">If algorithm initialization fails</exception>
<returns>True if signature is valid</returns>
</member>
<member name="M:Sop.JWX.JWS.JWS.validateWithJWKSet(Sop.JWX.JWK.JWKSet)">
<summary>
Validate the signature using a key from the given JWK set.
Correct key shall be sought by the key ID indicated by the header.
</summary>
<param name="set" type="JWKSet">Set of JSON Web Keys</param>
<exception cref="RuntimeException">If algorithm initialization fails</exception>
<returns>True if signature is valid</returns>
</member>
<member name="M:Sop.JWX.JWS.JWS.toCompact">
<summary>
Convert to compact serialization.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS.toCompactDetached">
<summary>
Convert to compact serialization with payload detached.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS._encodedPayload">
<summary>
Get the payload encoded for serialization.
</summary>
</member>
<member name="M:Sop.JWX.JWS.JWS._generateSignatureInput(Pchp.Core.Context,Pchp.Core.PhpString,Sop.JWX.JWT.Header.Header)">
<summary>
Generate input for the signature computation.
</summary>
<param name="payload" type="string">Payload</param>
<param name="header" type="Header">Protected header</param>
</member>
<member name="M:Sop.JWX.JWS.SignatureAlgorithm.computeSignature(Pchp.Core.PhpString)">
<summary>
Compute signature.
</summary>
<param name="data" type="string">Data for which the signature is computed</param>
</member>
<member name="M:Sop.JWX.JWS.SignatureAlgorithm.validateSignature(Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Validate signature.
</summary>
<param name="data" type="string">Data to validate</param>
<param name="signature" type="string">Signature to compare</param>
</member>
<member name="M:Sop.JWX.JWS.SignatureAlgorithm.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Sop.JWX.JWT.Header.Header)">
<summary>
Initialize signature algorithm from a JWK and a header.
</summary>
<param name="jwk" type="JWK">JSON Web Key</param>
<param name="header" type="Header">Header</param>
</member>
<member name="M:Sop.JWX.JWS.SignatureAlgorithm.withKeyID(Pchp.Core.PhpValue)">
<summary>
Get self with key ID.
</summary>
<param name="id" type="null|string">Key ID or null to remove</param>
</member>
<member name="M:Sop.JWX.JWS.SignatureAlgorithm.headerParameters">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.AudienceClaim.__construct(Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.AudienceClaim.fromJSONValue(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Claim.__construct(Pchp.Core.PhpString,Pchp.Core.PhpValue,Sop.JWX.JWT.Claim.Validator.Validator)">
<summary>
Constructor.
</summary>
<param name="name" type="string">Claim name</param>
<param name="value" type="mixed">Claim value</param>
<param name="validator" type="null|Validator">Claim validator or null if claim doesn't
provide validation</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.Claim.fromNameAndValue(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Initialize from a name and a value.
Returns a specific claim object if applicable.
</summary>
<param name="name" type="string">Claim name</param>
<param name="value" type="mixed">Claim value</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.Claim.name">
<summary>
Get the claim name.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Claim.value">
<summary>
Get the claim value.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Claim.validate(Pchp.Core.PhpValue)">
<summary>
Validate the claim against a given constraint.
</summary>
<param name="constraint" type="mixed">Constraint value</param>
<returns>True if the claim is valid</returns>
</member>
<member name="M:Sop.JWX.JWT.Claim.Claim.validateWithContext(Sop.JWX.JWT.ValidationContext)">
<summary>
Validate the claim in a given context.
Overridden in specific claims that provide default validation.
</summary>
<returns>True if claim is valid</returns>
</member>
<member name="M:Sop.JWX.JWT.Claim.ExpirationTimeClaim.__construct(System.Int64)">
<summary>
Constructor.
</summary>
<param name="exp_time" type="int">Expiration time as a unix timestamp</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.Feature.NumericDateClaim`1`1.__construct(System.Int64)">
<summary>
Constructor.
</summary>
<param name="timestamp" type="int">Unix timestamp</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.Feature.NumericDateClaim`1`1.value">
<summary>
Get the parameter value.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Feature.NumericDateClaim`1`1.fromString(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString,Pchp.Core.PhpString)">
<summary>
Initialize instance from date/time string.
</summary>
<param name="time" type="string">`strtotime` compatible time string</param>
<param name="tz" type="string">Default timezone</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.Feature.NumericDateClaim`1`1.timestamp">
<summary>
Get date as a unix timestamp.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Feature.NumericDateClaim`1`1.dateTime(Pchp.Core.PhpString)">
<summary>
Get date as a datetime object.
</summary>
<param name="tz" type="string">Timezone</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.Feature.NumericDateClaim`1`1._createTimeZone(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Create DateTimeZone object from string.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Feature.NumericDateClaim`1`1._getLastDateTimeImmutableErrorsStr(Pchp.Core.Context)">
<summary>
Get last error caused by DateTimeImmutable.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Feature.ReferenceTimeValidation`1`1.validate(Pchp.Core.PhpValue)">
<summary>
Validate the claim against given constraint.
</summary>
<param name="constraint" type="mixed"></param>
</member>
<member name="M:Sop.JWX.JWT.Claim.Feature.ReferenceTimeValidation`1`1.validateWithContext(Sop.JWX.JWT.ValidationContext)">
<summary>
Override default Claim validation.
Uses reference time of the validation context as a constraint.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.IssuedAtClaim.__construct(System.Int64)">
<summary>
Constructor.
</summary>
<param name="issue_time" type="int">Issued at time as a unix timestamp</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.IssuedAtClaim.now(Pchp.Core.Context)">
<summary>
Initialize with time set to current time.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.IssuerClaim.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.JWTIDClaim.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="id" type="string">JWT unique identifier</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.NotBeforeClaim.__construct(System.Int64)">
<summary>
Constructor.
</summary>
<param name="not_before" type="int">Not before time as a unix timestamp</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.NotBeforeClaim.now(Pchp.Core.Context)">
<summary>
Initialize with time set to current time.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.RegisteredClaim.__construct(Pchp.Core.PhpValue[])">
<summary>
Constructor.
Defined here for type strictness. Parameters are passed to the
superclass.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.RegisteredClaim.fromJSONValue(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpValue)">
<summary>
Initialize concrete claim instance from a JSON value.
</summary>
<param name="value" type="mixed"></param>
</member>
<member name="M:Sop.JWX.JWT.Claim.SubjectClaim.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="subject" type="string">Subject</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.has(Pchp.Core.PhpString)">
<summary>
Check whether the claim is present.
</summary>
<param name="name" type="string">Claim name</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.get(Pchp.Core.PhpString)">
<summary>
Get the claim by name.
</summary>
<param name="name" type="string">Claim name</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.hasIssuer">
<summary>
Check whether the issuer claim is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.issuer">
<summary>
Get the issuer claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.hasSubject">
<summary>
Check whether the subject claim is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.subject">
<summary>
Get the subject claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.hasAudience">
<summary>
Check whether the audience claim is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.audience">
<summary>
Get the audience claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.hasExpirationTime">
<summary>
Check whether the expiration time claim is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.expirationTime">
<summary>
Get the expiration time claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.hasNotBefore">
<summary>
Check whether the not before claim is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.notBefore">
<summary>
Get the not before claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.hasIssuedAt">
<summary>
Check whether the issued at claim is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.issuedAt">
<summary>
Get the issued at claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.hasJWTID">
<summary>
Check whether the JWT ID claim is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1.JWTID">
<summary>
Get the JWT ID claim.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.TypedClaims`1`1._checkType(Pchp.Core.Context,Sop.JWX.JWT.Claim.Claim,Pchp.Core.PhpString)">
<summary>
Check that the claim is an instance of the given class.
</summary>
<param name="claim" type="Claim">Claim object</param>
<param name="cls" type="string">Class name</param>
</member>
<member name="M:Sop.JWX.JWT.Claim.Validator.ContainsValidator.validate(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Validator.EqualsValidator.validate(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Validator.GreaterOrEqualValidator.validate(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Validator.GreaterValidator.validate(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Validator.LessOrEqualValidator.validate(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Validator.LessValidator.validate(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claim.Validator.Validator.__invoke(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Functor method.
</summary>
<param name="value" type="mixed"></param>
<param name="constraint" type="mixed"></param>
</member>
<member name="M:Sop.JWX.JWT.Claim.Validator.Validator.validate(Pchp.Core.PhpValue,Pchp.Core.PhpValue)">
<summary>
Check whether value is valid by given constraint.
</summary>
<param name="value" type="mixed">Value to assert</param>
<param name="constraint" type="mixed">Constraint</param>
<returns>True if value is valid</returns>
</member>
<member name="M:Sop.JWX.JWT.Claims.__construct(Sop.JWX.JWT.Claim.Claim[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claims.__toString">
<summary>
Convert to string.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claims.fromJSON(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from a JSON string.
</summary>
<param name="json" type="string">JSON</param>
<exception cref="UnexpectedValueException">If JSON is malformed</exception>
</member>
<member name="M:Sop.JWX.JWT.Claims.withClaims(Sop.JWX.JWT.Claim.Claim[])">
<summary>
Get self with Claim objects added.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claims.all">
<summary>
Get all claims.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claims.has(Pchp.Core.PhpString)">
<summary>
Check whether claim is present.
</summary>
<param name="name" type="string">Claim name</param>
</member>
<member name="M:Sop.JWX.JWT.Claims.get(Pchp.Core.PhpString)">
<summary>
Get claim by name.
</summary>
<param name="name" type="string">Claim name</param>
<exception cref="LogicException">If claim is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Claims.toJSON">
<summary>
Convert to a JSON.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claims.isValid(Sop.JWX.JWT.ValidationContext)">
<summary>
Check whether a claims set is valid in the given context.
</summary>
<param name="ctx" type="ValidationContext">Validation context</param>
</member>
<member name="M:Sop.JWX.JWT.Claims.count">
<summary>
Get the number of claims.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Claims.getIterator">
<summary>
Get iterator for Claim objects keyed by claim name.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.__construct(Sop.JWX.JWT.Parameter.JWTParameter[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.fromArray(Pchp.Core.Context,Pchp.Core.PhpArray)">
<summary>
Initialize from an array representing a JSON object.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.fromJSON(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from a JSON.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.withParameters(Sop.JWX.JWT.Parameter.JWTParameter[])">
<summary>
Get self with parameters added.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.parameters">
<summary>
Get all parameters.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.has(Pchp.Core.PhpString[])">
<summary>
Whether parameters are present.
Returns false if any of the given parameters is not set.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.get(Pchp.Core.PhpString)">
<summary>
Get a parameter.
</summary>
<param name="name" type="string">Parameter name</param>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.toJSON">
<summary>
Convert to a JSON.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.count">
<summary>
Get the number of parameters.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.Header.getIterator">
<summary>
Get iterator for the parameters.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.HeaderParameters.headerParameters">
<summary>
Get an array of JOSE header parameters representing this object.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.JOSE.__construct(Sop.JWX.JWT.Header.Header[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.JOSE.withHeader(Sop.JWX.JWT.Header.Header)">
<summary>
Get self merged with another Header.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.JOSE.isJWS">
<summary>
Whether JOSE is for a JWS.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.JOSE.isJWE">
<summary>
Whether JOSE is for a JWE.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.has(Pchp.Core.PhpString[])">
<summary>
Whether parameters are present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.get(Pchp.Core.PhpString)">
<summary>
Get a parameter.
</summary>
<param name="name" type="string">Parameter name</param>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasAlgorithm">
<summary>
Check whether the algorithm parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.algorithm">
<summary>
Get the algorithm parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasAuthenticationTag">
<summary>
Check whether the authentication tag parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.authenticationTag">
<summary>
Get the authentication tag parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasB64Payload">
<summary>
Check whether the 'base64url-encode payload' parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.B64Payload">
<summary>
Get the 'base64url-encode payload' parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasCompressionAlgorithm">
<summary>
Check whether the compression algorithm parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.compressionAlgorithm">
<summary>
Get the compression algorithm parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasContentType">
<summary>
Check whether the content type parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.contentType">
<summary>
Get the content type parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasCritical">
<summary>
Check whether the critical parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.critical">
<summary>
Get the critical parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasEncryptionAlgorithm">
<summary>
Check whether the encryption algorithm parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.encryptionAlgorithm">
<summary>
Get the encryption algorithm parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasInitializationVector">
<summary>
Check whether the initialization vector parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.initializationVector">
<summary>
Get the initialization vector parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasJSONWebKey">
<summary>
Check whether the JSON web key parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.JSONWebKey">
<summary>
Get the JSON web key parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasJWKSetURL">
<summary>
Check whether the JWK set URL parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.JWKSetURL">
<summary>
Get the JWK set URL parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasKeyID">
<summary>
Check whether the key ID parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.keyID">
<summary>
Get the key ID parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasPBES2Count">
<summary>
Check whether the PBES2 count parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.PBES2Count">
<summary>
Get the PBES2 count parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasPBES2SaltInput">
<summary>
Check whether the PBES2 salt input parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.PBES2SaltInput">
<summary>
Get the PBES2 salt input parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasType">
<summary>
Check whether the type parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.type">
<summary>
Get the type parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasX509CertificateChain">
<summary>
Check whether the X.509 certificate chain parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.X509CertificateChain">
<summary>
Get the X.509 certificate chain parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasX509CertificateSHA1Thumbprint">
<summary>
Check whether the X.509 certificate SHA-1 thumbprint parameter is
present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.X509CertificateSHA1Thumbprint">
<summary>
Get the X.509 certificate SHA-1 thumbprint parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasX509CertificateSHA256Thumbprint">
<summary>
Check whether the X.509 certificate SHA-256 thumbprint parameter is
present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.X509CertificateSHA256Thumbprint">
<summary>
Get the X.509 certificate SHA-256 thumbprint parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.hasX509URL">
<summary>
Check whether the X.509 URL parameter is present.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1.X509URL">
<summary>
Get the X.509 URL parameter.
</summary>
<exception cref="UnexpectedValueException">If the parameter has a wrong class</exception>
<exception cref="LogicException">If the parameter is not present</exception>
</member>
<member name="M:Sop.JWX.JWT.Header.TypedHeader`1`1._checkType(Pchp.Core.Context,Sop.JWX.JWT.Parameter.JWTParameter,Pchp.Core.PhpString)">
<summary>
Check that the parameter is an instance of the given class.
</summary>
<param name="param" type="\Sop\JWX\JWT\Parameter\JWTParameter">Parameter</param>
<param name="cls" type="string">Class name</param>
</member>
<member name="M:Sop.JWX.JWT.JWT.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="token" type="string">JWT string</param>
</member>
<member name="M:Sop.JWX.JWT.JWT.__toString">
<summary>
Convert JWT to string.
</summary>
</member>
<member name="M:Sop.JWX.JWT.JWT.unsecuredFromClaims(Pchp.Core.Context,Sop.JWX.JWT.Claims,Sop.JWX.JWT.Header.Header)">
<summary>
Convert claims set to an unsecured JWT.
Unsecured JWT is not signed nor encrypted neither integrity protected,
and should thus be handled with care!
</summary>
<param name="claims" type="Claims">Claims set</param>
<param name="header" type="null|Header">Optional header</param>
<exception cref="RuntimeException">For generic errors</exception>
</member>
<member name="M:Sop.JWX.JWT.JWT.signedFromClaims(Pchp.Core.Context,Sop.JWX.JWT.Claims,Sop.JWX.JWS.SignatureAlgorithm,Sop.JWX.JWT.Header.Header)">
<summary>
Convert claims set to a signed JWS token.
</summary>
<param name="claims" type="Claims">Claims set</param>
<param name="algo" type="SignatureAlgorithm">Signature algorithm</param>
<param name="header" type="null|Header">Optional header</param>
<exception cref="RuntimeException">For generic errors</exception>
</member>
<member name="M:Sop.JWX.JWT.JWT.encryptedFromClaims(Pchp.Core.Context,Sop.JWX.JWT.Claims,Sop.JWX.JWE.KeyManagementAlgorithm,Sop.JWX.JWE.ContentEncryptionAlgorithm,Sop.JWX.JWE.CompressionAlgorithm,Sop.JWX.JWT.Header.Header)">
<summary>
Convert claims set to an encrypted JWE token.
</summary>
<param name="claims" type="Claims">Claims set</param>
<param name="key_algo" type="KeyManagementAlgorithm">Key management algorithm</param>
<param name="enc_algo" type="ContentEncryptionAlgorithm">Content encryption algorithm</param>
<param name="zip_algo" type="null|CompressionAlgorithm">Optional compression algorithm</param>
<param name="header" type="null|Header">Optional header</param>
<exception cref="RuntimeException">For generic errors</exception>
</member>
<member name="M:Sop.JWX.JWT.JWT.claims(Sop.JWX.JWT.ValidationContext)">
<summary>
Get claims from the JWT.
Claims shall be validated according to given validation context.
Validation context must contain all the necessary keys for the signature
validation and/or content decryption.

If validation context contains only one key, it shall be used explicitly.
If multiple keys are provided, they must contain a JWK ID parameter for
the key identification.
</summary>
<exception cref="ValidationException">if signature is invalid, or decryption fails,
or claims validation fails</exception>
<exception cref="RuntimeException">For generic errors</exception>
</member>
<member name="M:Sop.JWX.JWT.JWT.signNested(Sop.JWX.JWS.SignatureAlgorithm,Sop.JWX.JWT.Header.Header)">
<summary>
Sign self producing a nested JWT.
Note that if JWT is to be signed and encrypted, it should be done in
sign-then-encrypt order. Please refer to links for security information.
</summary>
<param name="algo" type="SignatureAlgorithm">Signature algorithm</param>
<param name="header" type="null|Header">Optional header</param>
<exception cref="RuntimeException">For generic errors</exception>
</member>
<member name="M:Sop.JWX.JWT.JWT.encryptNested(Sop.JWX.JWE.KeyManagementAlgorithm,Sop.JWX.JWE.ContentEncryptionAlgorithm,Sop.JWX.JWE.CompressionAlgorithm,Sop.JWX.JWT.Header.Header)">
<summary>
Encrypt self producing a nested JWT.
This JWT should be a JWS, that is, the order of nesting should be
sign-then-encrypt.
</summary>
<param name="key_algo" type="KeyManagementAlgorithm">Key management algorithm</param>
<param name="enc_algo" type="ContentEncryptionAlgorithm">Content encryption algorithm</param>
<param name="zip_algo" type="null|CompressionAlgorithm">Optional compression algorithm</param>
<param name="header" type="null|Header">Optional header</param>
<exception cref="RuntimeException">For generic errors</exception>
</member>
<member name="M:Sop.JWX.JWT.JWT.isJWS">
<summary>
Whether JWT is a JWS.
</summary>
</member>
<member name="M:Sop.JWX.JWT.JWT.JWS">
<summary>
Get JWT as a JWS.
</summary>
</member>
<member name="M:Sop.JWX.JWT.JWT.isJWE">
<summary>
Whether JWT is a JWE.
</summary>
</member>
<member name="M:Sop.JWX.JWT.JWT.JWE">
<summary>
Get JWT as a JWE.
</summary>
</member>
<member name="M:Sop.JWX.JWT.JWT.isNested">
<summary>
Check whether JWT contains another nested JWT.
</summary>
</member>
<member name="M:Sop.JWX.JWT.JWT.isUnsecured">
<summary>
Check whether JWT is unsecured, that is, it's neither integrity protected
nor encrypted.
</summary>
</member>
<member name="M:Sop.JWX.JWT.JWT.header">
<summary>
Get JWT header.
</summary>
</member>
<member name="M:Sop.JWX.JWT.JWT.token">
<summary>
Get JWT as a string.
</summary>
</member>
<member name="M:Sop.JWX.JWT.JWT._claimsFromNestedPayload(Pchp.Core.PhpString,Sop.JWX.JWT.ValidationContext)">
<summary>
Get claims from a nested payload.
</summary>
<param name="payload" type="string">JWT payload</param>
<param name="ctx" type="ValidationContext">Validation context</param>
</member>
<member name="M:Sop.JWX.JWT.JWT._validatedPayloadFromJWS(Pchp.Core.Context,Sop.JWX.JWS.JWS,Sop.JWX.JWT.ValidationContext)">
<summary>
Get validated payload from JWS.
</summary>
<param name="jws" type="JWS">JWS</param>
<param name="ctx" type="ValidationContext">Validation context</param>
<exception cref="ValidationException">If signature validation fails</exception>
</member>
<member name="M:Sop.JWX.JWT.JWT._validatedPayloadFromUnsecuredJWS(Pchp.Core.Context,Sop.JWX.JWS.JWS,Sop.JWX.JWT.ValidationContext)">
<summary>
Get validated payload from an unsecured JWS.
</summary>
<param name="jws" type="JWS">JWS</param>
<param name="ctx" type="ValidationContext">Validation context</param>
<exception cref="ValidationException">If unsecured JWT's are not allowed, or JWS
token is malformed</exception>
</member>
<member name="M:Sop.JWX.JWT.JWT._validatedPayloadFromSignedJWS(Pchp.Core.Context,Sop.JWX.JWS.JWS,Sop.JWX.JWK.JWKSet)">
<summary>
Get validated payload from a signed JWS.
</summary>
<param name="jws" type="JWS">JWS</param>
<param name="keys" type="JWKSet">Set of allowed keys for the signature validation</param>
<exception cref="ValidationException">If validation fails</exception>
</member>
<member name="M:Sop.JWX.JWT.JWT._validatedPayloadFromJWE(Pchp.Core.Context,Sop.JWX.JWE.JWE,Sop.JWX.JWT.ValidationContext)">
<summary>
Get validated payload from an encrypted JWE.
</summary>
<param name="jwe" type="JWE">JWE</param>
<param name="ctx" type="ValidationContext">Validation context</param>
<exception cref="ValidationException">If decryption fails</exception>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AlgorithmParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="string">Algorithm name</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AlgorithmParameter.fromAlgorithm(Pchp.Core.Context,Sop.JWX.JWT.Parameter.AlgorithmParameterValue)">
<summary>
Initialize from AlgorithmParameterValue.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AlgorithmParameterValue.algorithmParamValue">
<summary>
Get algorithm type as an 'alg' parameter value.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AuthenticationTagParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="tag" type="string">Base64url encoded authentication tag</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.AuthenticationTagParameter.authenticationTag">
<summary>
Get the authentication tag.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.B64PayloadParameter.__construct(System.Boolean)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.B64PayloadParameter.fromJSONValue(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Initialize from a JSON value.
</summary>
<param name="value" type="bool"></param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CompressionAlgorithmParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CompressionAlgorithmParameter.fromAlgorithm(Pchp.Core.Context,Sop.JWX.JWT.Parameter.CompressionAlgorithmParameterValue)">
<summary>
Initialize from CompressionAlgorithmParameterValue.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CompressionAlgorithmParameterValue.compressionParamValue">
<summary>
Get compression algorithm type as an 'zip' parameter value.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.ContentTypeParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CriticalParameter.__construct(Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CriticalParameter.withParamName(Pchp.Core.PhpString)">
<summary>
Get self with parameter name added.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CriticalParameter.has(Pchp.Core.PhpString)">
<summary>
Check whether given parameter name is critical.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.CriticalParameter.names">
<summary>
Get critical header parameter names.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.EncryptionAlgorithmParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="algo" type="string">Algorithm name</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.EncryptionAlgorithmParameter.fromAlgorithm(Pchp.Core.Context,Sop.JWX.JWT.Parameter.EncryptionAlgorithmParameterValue)">
<summary>
Initialize from EncryptionAlgorithmParameterValue.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.EncryptionAlgorithmParameterValue.encryptionAlgorithmParamValue">
<summary>
Get algorithm type as an 'enc' parameter value.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.InitializationVectorParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="iv" type="string">Base64url encoded initialization vector</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.InitializationVectorParameter.initializationVector">
<summary>
Get the initialization vector.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JSONWebKeyParameter.__construct(Sop.JWX.JWK.JWK)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JSONWebKeyParameter.fromJSONValue(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpValue)">
<summary>
{@inheritdoc}
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JSONWebKeyParameter.jwk">
<summary>
Get value as a JWK.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JWKSetURLParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JWTParameter.__construct(Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Constructor.
</summary>
<param name="name" type="string">Parameter name</param>
<param name="value" type="mixed">Parameter value</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JWTParameter.fromNameAndValue(Pchp.Core.Context,Pchp.Core.PhpString,Pchp.Core.PhpValue)">
<summary>
Initialize from a name and a value.
Returns a parameter specific object if one is implemented.
</summary>
<param name="name" type="string">Parameter name</param>
<param name="value" type="mixed">Parameter value</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.JWTParameter.fromJSONValue(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Initialize from a JSON value.
</summary>
<param name="value" type="mixed"></param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.KeyIDParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2CountParameter.__construct(System.Int64)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2CountParameter.fromJSONValue(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Initialize from a JSON value.
</summary>
<param name="value" type="int"></param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2SaltInputParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="salt" type="string">Base64url encoded salt input value</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2SaltInputParameter.saltInput">
<summary>
Get salt input value.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.PBES2SaltInputParameter.salt(Sop.JWX.JWT.Parameter.AlgorithmParameter)">
<summary>
Get computed salt value.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.ReplicatedClaimParameter.__construct(Sop.JWX.JWT.Claim.Claim)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.TypeParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateChainParameter.__construct(Pchp.Core.PhpString[])">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateSHA1ThumbprintParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-1 hash</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509CertificateSHA256ThumbprintParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="thumbprint" type="string">Base64url encoded SHA-256 hash</param>
</member>
<member name="M:Sop.JWX.JWT.Parameter.X509URLParameter.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.__construct(Pchp.Core.PhpValue,Sop.JWX.JWK.JWKSet)">
<summary>
Constructor.
</summary>
<param name="constraints" type="null|array">Optional array of constraints for the
registered claims</param>
<param name="keys" type="null|JWKSet">Optional set of JSON Web Keys used for
signature validation and/or decryption</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.fromJWK(Pchp.Core.Context,Sop.JWX.JWK.JWK,Pchp.Core.PhpValue)">
<summary>
Initialize with a single JSON Web Key.
</summary>
<param name="key" type="JWK">JSON Web Key</param>
<param name="constraints" type="null|array">Optional constraints</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.withReferenceTime(Pchp.Core.PhpValue)">
<summary>
Get self with the reference time.
</summary>
<param name="ts" type="null|int">Unix timestamp</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.hasReferenceTime">
<summary>
Check whether the reference time is set.
</summary>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.referenceTime">
<summary>
Get the reference time.
</summary>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.withLeeway(System.Int64)">
<summary>
Get self with the reference time leeway.
</summary>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.leeway">
<summary>
Get the reference time leeway.
</summary>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.withConstraint(Pchp.Core.PhpString,Pchp.Core.PhpValue,Sop.JWX.JWT.Claim.Validator.Validator)">
<summary>
Get self with a validation constraint.
If the claim does not provide its own validator, an explicit validator
must be given.
</summary>
<param name="name" type="string">Claim name</param>
<param name="constraint" type="mixed">Value to check claim against</param>
<param name="validator" type="null|Validator">Optional explicit validator</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.withIssuer(Pchp.Core.PhpString)">
<summary>
Get self with the issuer constraint.
</summary>
<param name="issuer" type="string">Issuer name</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.withSubject(Pchp.Core.PhpString)">
<summary>
Get self with the subject constraint.
</summary>
<param name="subject" type="string">Subject name</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.withAudience(Pchp.Core.PhpString)">
<summary>
Get self with the audience constraint.
</summary>
<param name="audience" type="string">Audience name</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.withID(Pchp.Core.PhpString)">
<summary>
Get self with the JWT ID constraint.
</summary>
<param name="id" type="string">JWT ID</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.hasConstraint(Pchp.Core.PhpString)">
<summary>
Check whether a named constraint is present.
</summary>
<param name="name" type="string">Claim name</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.constraint(Pchp.Core.PhpString)">
<summary>
Get a constraint value by the claim name.
</summary>
<param name="name" type="string">Claim name</param>
<exception cref="LogicException">If constraint is not set</exception>
<returns>Constraint value</returns>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.hasValidator(Pchp.Core.PhpString)">
<summary>
Check whether a validator is defined for the given claim name.
</summary>
<param name="name" type="string">Claim name</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.validator(Pchp.Core.PhpString)">
<summary>
Get explicitly defined validator by the claim name.
</summary>
<param name="name" type="string">Claim name</param>
<exception cref="LogicException">If validator is not set</exception>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.keys">
<summary>
Get a set of JSON Web Keys defined in this context.
</summary>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.withUnsecuredAllowed(System.Boolean)">
<summary>
Get self with 'allow unsecured' flag set.
If the unsecured JWT's are allowed, claims shall be considered valid even
though they are not signed nor encrypted.
</summary>
<param name="allow" type="bool">Whether to allow unsecured JWT's</param>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.isUnsecuredAllowed">
<summary>
Check whether the unsecured JWT's are allowed.
</summary>
</member>
<member name="M:Sop.JWX.JWT.ValidationContext.validate(Sop.JWX.JWT.Claims)">
<summary>
Validate claims.
</summary>
<exception cref="ValidationException">If any of the claims is not valid</exception>
</member>
<member name="M:Sop.JWX.Parameter.Feature.ArrayParameterValue`1`1.fromJSONValue(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpValue)">
<summary>
Initialize from a JSON value.
</summary>
<param name="value" type="array"></param>
</member>
<member name="M:Sop.JWX.Parameter.Feature.Base64UIntValue`1`1.fromNumber(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpValue)">
<summary>
Initialize parameter from base10 number.
</summary>
<param name="number" type="int|string"></param>
</member>
<member name="M:Sop.JWX.Parameter.Feature.Base64UIntValue`1`1.number">
<summary>
Get value as a number.
</summary>
</member>
<member name="M:Sop.JWX.Parameter.Feature.Base64URLValue`1`1.value">
<summary>
Get the parameter value.
</summary>
</member>
<member name="M:Sop.JWX.Parameter.Feature.Base64URLValue`1`1.fromString(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpString)">
<summary>
Initialize from native value.
Value shall be encoded using Base64url encoding.
</summary>
</member>
<member name="M:Sop.JWX.Parameter.Feature.Base64URLValue`1`1.string">
<summary>
Get the parameter value as a decoded string.
</summary>
</member>
<member name="M:Sop.JWX.Parameter.Feature.Base64URLValue`1`1._validateEncoding(Pchp.Core.PhpString)">
<summary>
Validate that value is validly base64url encoded.
</summary>
</member>
<member name="M:Sop.JWX.Parameter.Feature.StringParameterValue`1`1.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="value" type="string">Parameter value</param>
</member>
<member name="M:Sop.JWX.Parameter.Feature.StringParameterValue`1`1.fromJSONValue(Pchp.Core.Context,Pchp.Core.Reflection.PhpTypeInfo,Pchp.Core.PhpValue)">
<summary>
Initialize from a JSON value.
</summary>
<param name="value" type="string"></param>
</member>
<member name="M:Sop.JWX.Parameter.Parameter.name">
<summary>
Get the parameter name.
</summary>
</member>
<member name="M:Sop.JWX.Parameter.Parameter.value">
<summary>
Get the parameter value.
</summary>
</member>
<member name="M:Sop.JWX.Util.Base64.urlEncode(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Encode a string using base64url variant.
</summary>
</member>
<member name="M:Sop.JWX.Util.Base64.urlDecode(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Decode a string using base64url variant.
</summary>
</member>
<member name="M:Sop.JWX.Util.Base64.isValidURLEncoding(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Check whether string is validly base64url encoded.
</summary>
</member>
<member name="M:Sop.JWX.Util.Base64.encode(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Encode a string in base64.
</summary>
</member>
<member name="M:Sop.JWX.Util.Base64.decode(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Decode a string from base64 encoding.
</summary>
<exception cref="RuntimeException">If decoding fails</exception>
</member>
<member name="M:Sop.JWX.Util.Base64.isValid(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Check whether string is validly base64 encoded.
</summary>
</member>
<member name="M:Sop.JWX.Util.BigInt.__construct(System.Object)">
<summary>
Constructor.
</summary>
<param name="num" type="\GMP">GMP number</param>
</member>
<member name="M:Sop.JWX.Util.BigInt.fromBase10(Pchp.Core.Context,Pchp.Core.PhpValue)">
<summary>
Initialize from a base10 number.
</summary>
<param name="number" type="int|string"></param>
</member>
<member name="M:Sop.JWX.Util.BigInt.fromBase256(Pchp.Core.Context,Pchp.Core.PhpString)">
<summary>
Initialize from a base256 number.
Base64 number is an octet string of big endian, most significant word
first integer.
</summary>
</member>
<member name="M:Sop.JWX.Util.BigInt.base10">
<summary>
Convert to base10 string.
</summary>
</member>
<member name="M:Sop.JWX.Util.BigInt.base16">
<summary>
Convert to base16 string.
</summary>
</member>
<member name="M:Sop.JWX.Util.BigInt.base256">
<summary>
Convert to base256 string.
</summary>
</member>
<member name="M:Sop.JWX.Util.UUIDv4.__construct(Pchp.Core.PhpString)">
<summary>
Constructor.
</summary>
<param name="uuid" type="string">UUIDv4 in canonical hexadecimal format</param>
</member>
<member name="M:Sop.JWX.Util.UUIDv4.createRandom(Pchp.Core.Context)">
<summary>
Create new random UUIDv4.
</summary>
</member>
<member name="M:Sop.JWX.Util.UUIDv4.canonical">
<summary>
Get UUIDv4 in canonical form.
</summary>
</member>
</members>
</doc>
